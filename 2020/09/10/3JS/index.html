<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/blue/pace-theme-fill-left.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"example.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="js"><meta property="og:type" content="article"><meta property="og:title" content="javascript基础知识"><meta property="og:url" content="http://example.com/2020/09/10/3JS/index.html"><meta property="og:site_name" content="boke"><meta property="og:description" content="js"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200623154300455.png"><meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200623155743706.png"><meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200623162117442.png"><meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200530195614893.png"><meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200701164451220.png"><meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200702194328105.png"><meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200702200442330.png"><meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200702200525000.png"><meta property="article:published_time" content="2020-09-10T08:37:40.000Z"><meta property="article:modified_time" content="2020-09-21T02:43:03.024Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="javascript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200623154300455.png"><link rel="canonical" href="http://example.com/2020/09/10/3JS/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>javascript基础知识 | boke</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="boke" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage"><script color="0,0,0" opacity="0.8" zindex="-2" count="200" type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">boke</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2020/09/10/3JS/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3684345252,2646729991&fm=26&gp=0.jpg"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="boke"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">javascript基础知识</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-09-10 16:37:40" itemprop="dateCreated datePublished" datetime="2020-09-10T16:37:40+08:00">2020-09-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-09-21 10:43:03" itemprop="dateModified" datetime="2020-09-21T10:43:03+08:00">2020-09-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">前端基础</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2020/09/10/3JS/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/09/10/3JS/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>106k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1:36</span></span><div class="post-description">js</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="javascript基础"><a href="#javascript基础" class="headerlink" title="javascript基础"></a>javascript基础</h1><h2 id="JS概述"><a href="#JS概述" class="headerlink" title="JS概述"></a>JS概述</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><ol><li>验证表单（以前的网速慢）</li><li>页面特效（PC端的网页效果）<a id="more"></a></li><li>移动端（移动web和app）</li><li>异步和服务器交互（AJAX）</li><li>服务端开发（nodejs）</li></ol><h3 id="2-解析执行与编译执行"><a href="#2-解析执行与编译执行" class="headerlink" title="2.解析执行与编译执行"></a>2.解析执行与编译执行</h3><p>编译执行：把代码编译成CPU认识的语言(文件)，然后整体的执行。</p><p>解析执行：一行一行解析，解析一行执行一行。</p><h3 id="3-脚本调用策略"><a href="#3-脚本调用策略" class="headerlink" title="3.脚本调用策略"></a>3.脚本调用策略</h3><p>要让脚本调用的时机符合预期，需要解决一系列的问题。这里看似简单，实际大有文章。最常见的问题就是：HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">文档对象模型</a> DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。</p><p>上述的脚本阻塞问题实际有两种解决方案 —— <code>async</code> 和 <code>defer</code></p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>浏览器遇到 <code>async</code> 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，<code>async</code> 是最理想的选择。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>三者的调用顺序是不确定的。<code>jquery.js</code> 可能在 <code>script2</code> 和 <code>script3</code> 之前或之后调用，如果这样，后两个脚本中依赖 <code>jquery</code> 的函数将产生错误，因为脚本运行时 <code>jquery</code> 尚未加载。</p><p>解决这一问题可使用 <code>defer</code> 属性，脚本将按照在页面中出现的顺序加载和运行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/script3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加 <code>defer</code> 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 <code>jquery.js</code>必定加载于 <code>script2.js</code> 和 <code>script3.js</code> 之前，同时 <code>script2.js</code> 必定加载于 <code>script3.js</code>之前。</p><h4 id="脚本调用策略小结："><a href="#脚本调用策略小结：" class="headerlink" title="脚本调用策略小结："></a>脚本调用策略小结：</h4><ul><li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li><li>如果脚本无需等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li></ul><h3 id="4-js组成"><a href="#4-js组成" class="headerlink" title="4.js组成"></a>4.js组成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS  &#x3D;  ECMAScript  +  DOM  +  BOM + 高级</span><br></pre></td></tr></table></figure><ul><li><p>ECMAScript（前身为欧洲计算机制造商协会）</p><ul><li>JavaScript的语法规范</li></ul></li><li><p>DOM（Document Object Model 的简称）</p><ul><li>JavaScript操作网页上元素的API</li></ul></li><li><p>BOM（Browser Object Model 的简称）</p><ul><li>JavaScript操作浏览器部分功能的API</li></ul></li></ul><h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5.变量"></a>5.变量</h3><h4 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1.命名规则"></a>1.命名规则</h4><p>驼峰命名规则：getElementById/matherAndFather/aaaOrBbbAndCcc</p><p>遵从规则：</p><p>1.变量命名必须以字母或是下标符号”_”或者”$”为开头。</p><p>2.变量名长度不能超过255个字符。</p><p>3.变量名中不允许使用空格，首个字不能为数字。</p><p>4.不用使用脚本语言中保留的关键字及保留符号作为变量名。</p><p>5.变量名区分大小写。(javascript是区分大小写的语言)</p><p>6.汉语可以作为变量名。但是不建议使用！！！（low）</p><h4 id="2-定义变量"><a href="#2-定义变量" class="headerlink" title="2.定义变量"></a>2.定义变量</h4><ol><li>var es6之前用的定义变量</li><li>let es6变量，let声明的变量只在它所在的代码块有效。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li>let特性：<ul><li>不存在变量提升</li><li>暂时性死区</li><li>不允许重复声明</li><li>块级作用域</li></ul></li></ul><ol start="3"><li>const es6常量定义，声明一个只读的常量。一旦声明，常量的值就不能改变。</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1-数据类型划分"><a href="#1-数据类型划分" class="headerlink" title="1.数据类型划分"></a>1.数据类型划分</h3><ul><li>使用关键字typeof, typeof name 或者 typeof(name)</li><li>typeof 运算符： 只能识别<strong>值类型</strong>的变量，对于引用类型的值，只能大概识别</li><li>值类型<ul><li>String（字符串） Number（数字） Boolean（布尔） undefined（未定义） null（空）</li></ul></li><li>引用类型<ul><li>Object、function、Array、Date、RegExp、Error</li></ul></li></ul><h3 id="2-值类型"><a href="#2-值类型" class="headerlink" title="2.值类型"></a>2.值类型</h3><h4 id="2-1-undefined"><a href="#2-1-undefined" class="headerlink" title="2.1.undefined"></a>2.1.undefined</h4><ol><li>定义：使用var声明变量但为初始化</li><li>区分空对象指针与尚未定义的变量：对未初始化的变量及未声明的变量使用typeof运算符均会返回undefined</li></ol><h4 id="2-2-null"><a href="#2-2-null" class="headerlink" title="2.2.null"></a>2.2.null</h4><ol><li>定义：逻辑上null表示一个空对象的指针，使用typeof检测时会返回object</li><li>undefined与null的关系<ul><li>undefined派生于null,因此在使用“==”进行比较时会返回true</li><li>没有必要将变量显示声明为undefined</li><li>声明空对象时应该将其赋值为null</li></ul></li></ol><h4 id="2-3-boolean"><a href="#2-3-boolean" class="headerlink" title="2.3.boolean"></a>2.3.boolean</h4><ol><li>true为真，false为假</li><li>使用Boolean()进行转换<ul><li>转换为true<ul><li>任何非空字符串</li><li>任何非零数值</li><li>任何非空对象</li></ul></li><li>转换为false<ul><li>空字符串</li><li>0以及NaN</li><li>null及undefined</li></ul></li></ul></li></ol><h4 id="2-4-字符串"><a href="#2-4-字符串" class="headerlink" title="2.4.字符串"></a>2.4.字符串</h4><ol><li><h5 id="定义方式：用引号时，可单可双，唯独不可一单一双。可用-length看有几个字符。"><a href="#定义方式：用引号时，可单可双，唯独不可一单一双。可用-length看有几个字符。" class="headerlink" title="定义方式：用引号时，可单可双，唯独不可一单一双。可用.length看有几个字符。"></a>定义方式：用引号时，可单可双，唯独不可一单一双。可用.length看有几个字符。</h5></li><li><h5 id="转译：无法输出的字符，使用转译字符输出，例如：-‘’-‘-等。"><a href="#转译：无法输出的字符，使用转译字符输出，例如：-‘’-‘-等。" class="headerlink" title="转译：无法输出的字符，使用转译字符输出，例如：/    ‘’     ‘      //等。"></a>转译：无法输出的字符，使用转译字符输出，例如：/ ‘’ ‘ //等。</h5></li><li><h5 id="字符串的连接，使用“-”字符连接，可以是字符变量"><a href="#字符串的连接，使用“-”字符连接，可以是字符变量" class="headerlink" title="字符串的连接，使用“+”字符连接，可以是字符变量"></a>字符串的连接，使用“+”字符连接，可以是字符变量</h5></li><li><h5 id="转换：toString"><a href="#转换：toString" class="headerlink" title="转换：toString()"></a>转换：toString()</h5></li><li><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul><li>string.length 获取字符串的长度</li><li>string[i] 检索值为i对应的特定字符串字符</li><li>string.indexOf(‘zilla’) 在字符串中查找子字符串并提取它,当在主字符串中找不到子字符串（在本例中为“vanilla”）时将返回 <code>-1</code>。</li><li>slice(0,3) 提取字符串中0到3位置的字符，如果只有一个值，表示从当前值的位置截取剩下的所有</li><li>toLowerCase() 字符串转换为小写</li><li>toUpperCase() 字符串转换为大写</li><li>replace(‘要被替换下的字符串’,’要被替换上的字符串’) 它不会自动更新子串的值，需要重新赋值一下</li></ul></li><li><h5 id="ES6提供的新方法"><a href="#ES6提供的新方法" class="headerlink" title="ES6提供的新方法"></a>ES6提供的新方法</h5><ol><li><code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。在作用上，正好与下面的<code>codePointAt()</code>方法相反。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>ES6 还为原生的 String 对象，提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span></span><br><span class="line"><span class="comment">// 实际返回 &quot;Hi\\n5!&quot;，显示的是转义后的结果 &quot;Hi\n5!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 实际返回 &quot;Hi\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\u000A!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要<code>4</code>个字节储存。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt()</code>方法无法读取整个字符，<code>charCodeAt()</code>方法只能分别返回前两个字节和后两个字节的值。</p><p>ES6 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span></span><br><span class="line">s.charCodeAt(<span class="number">2</span>).toString(<span class="number">16</span>)  <span class="comment">// &quot;61&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x61</span>)    <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>includes(), startsWith(), endsWith()确定一个字符串是否包含在另一个字符串中</p></li></ol><ul><li><p>**includes()**：返回布尔值，表示是否找到了参数字符串。</p></li><li><p>**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。</p></li><li><p>**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p></blockquote><p>​ 5. <code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>) <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.repeat(<span class="number">2</span>) <span class="comment">// &quot;hellohello&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">0</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">2.9</span>) <span class="comment">// &quot;nana&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="string">&#x27;3&#x27;</span>) <span class="comment">// &quot;nanana&quot;</span></span><br></pre></td></tr></table></figure><p>​ 6. 字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p><p>​ <code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000001&quot;</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000012&quot;</span></span><br><span class="line"><span class="string">&#x27;123456&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000123456&quot;</span></span><br></pre></td></tr></table></figure><p>另一个用途是提示字符串格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-MM-12&quot;</span></span><br><span class="line"><span class="string">&#x27;09-12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-09-12&quot;</span></span><br></pre></td></tr></table></figure><p>​ 7. <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-string-left-right-trim">ES2019</a> 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.trimStart() <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">f.trimLeft()  <span class="comment">//&quot;abc   &quot;</span></span><br><span class="line">s.trimEnd()   <span class="comment">// &quot;  abc&quot;</span></span><br><span class="line">f.trimRight() <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，<code>trimStart()</code>只消除头部的空格，保留尾部的空格。<code>trimEnd()</code>也是类似行为。除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p></blockquote><ol start="7"><li><h5 id="字符串的遍历"><a href="#字符串的遍历" class="headerlink" title="字符串的遍历"></a>字符串的遍历</h5></li></ol><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><ol start="8"><li><h5 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h5></li></ol><p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-well-formed-stringify">ES2019</a> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="comment">// &quot;&quot;\\uD834&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\uDF06\uD834&#x27;</span>) <span class="comment">// &quot;&quot;\\udf06\\ud834&quot;&quot;</span></span><br></pre></td></tr></table></figure><ol start="9"><li><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5></li></ol><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。如果不想要，使用<code>trim()</code>方法消除他</p></li><li><p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p></li><li><p>可调用函数</p></li></ol></blockquote><p><strong>模板编译</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<code>&lt;%...%&gt;</code>放置 JavaScript 代码，使用<code>&lt;%= ... %&gt;</code>输出 JavaScript 表达式。</p><p><strong>标签模板</strong></p><ul><li>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能</li><li>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</li><li>如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数</li></ul><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sender = <span class="string">&#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-Number"><a href="#2-5-Number" class="headerlink" title="2.5.Number"></a>2.5.Number</h4><ul><li><strong>整数</strong> 就是整数,例如 10, 400, 或者 -5.</li><li><strong>浮点数</strong> (浮点) 有小数点或小数位，例如 12.5，和 56.7786543。</li><li><strong>双精度</strong>双精度是一种特定类型的浮点数，它们具有比标准浮点数更高的精度（这意味着它们精确到更大的小数位数）。</li></ul><p>甚至有不同类型的数字系统！ 十进制是基数10（意味着它在每列使用0-9），但是我们也有这样的东西：</p><ul><li><p><strong>二进制</strong> — 计算机的最基础语言; 0s and 1s</p></li><li><p><strong>八进制</strong> — 基数8，每列使用0-7</p></li><li><p><strong>十六进制</strong> — 基数16，每列使用0-9，然后使用a-f。 在CSS中设置颜色时，可能会遇到这些数字。</p><p>数制转换：</p></li></ul><ol><li>Number()</li></ol><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200623154300455.png" alt="image-20200623154300455"></p><ol start="2"><li>parseInt()</li></ol><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200623155743706.png" alt="image-20200623155743706"></p><ol start="3"><li>parseFloat()</li></ol><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200623162117442.png" alt="image-20200623162117442"></p><ol start="4"><li>toFixed()　将一个数字转换为包含指定小数位数的字符串。</li><li>valueOf()　　　　返回一个Number对象的原始值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D; 2.13456;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; -2.13456;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; 0;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; 0&#x2F;0;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; &#39;ab&#39;;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; &#39;12&#39;;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">&gt; 2.13456</span><br><span class="line">&gt; -2.13456</span><br><span class="line">&gt; 0</span><br><span class="line">&gt; NaN</span><br><span class="line">&gt; &quot;ab&quot;</span><br><span class="line">&gt; &quot;12&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>toLocaleString()　　将一个数字转换为本地数字格式的字符串。</li><li>toExponential()　　用于将数字转化为指数形式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2.13456</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential());</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">num = <span class="number">2123.1345</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">&gt; <span class="string">&quot;2.13456e+0&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;2e+0&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;2.13e+0&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;2.13456000e+0&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;2.1231345e+3&quot;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>Number.isInteger() 判断是否是整数。返回true 或者 false</li><li>Number.isNaN() 判断一个数字是不是<code>NaN</code>。 返回true 或者 false</li><li><code>Number.isFinite()</code>用于判断一个数字是否是有限数字。返回true 或者 false</li><li>isSafeInteger()该方法用于判断一个数字是否是一个安全数，那么问题来了，啥叫安全数：一个数字可以表示为IEEE-754双精度数，即从<code>(253−1) (2^&#123;53&#125;-1)(2的53−1)到−(253−1) -(2^&#123;53&#125;-1)−(2的53 −1)</code>。</li></ol><p><strong>Math对象</strong></p><ul><li><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p></li><li><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p><p>它会返回五种值。</p><ul><li>参数为正数，返回<code>+1</code>；</li><li>参数为负数，返回<code>-1</code>；</li><li>参数为 0，返回<code>0</code>；</li><li>参数为-0，返回<code>-0</code>;</li><li>其他值，返回<code>NaN</code>。</li></ul></li><li><p><code>Math.cbrt()</code>方法用于计算一个数的立方根。</p></li><li><p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p></li></ul><p><strong>NaN</strong></p><ol><li><p>NaN 非数值（Not a Number的简写）</p><ul><li>console.log(“abc”/18); //结果是NaN</li><li>undefined和任何数值计算为NaN;</li><li>NaN 与任何值都不相等，包括 NaN 本身</li></ul></li><li><pre><code>Number.isNaN`，你可以检测你传递的值是否为 *数字值* 并且是否等价于 `NaN
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. isNaN() :任何不能被转换为数值的值都会导致这个函数返回 true </span><br><span class="line"></span><br><span class="line">&gt; （isNaN译为是否符合一个标准，什么标准呢？不是一个数字的标	 准，如果符合了那么就不是一个数字，不符合就是一个数字）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">isNaN(NaN);&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">isNaN(“blue”); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">isNaN(123); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>


</code></pre></li></ol><h4 id="2-6-object"><a href="#2-6-object" class="headerlink" title="2.6.object()"></a>2.6.object()</h4><ol><li><p>定义:一组数据或者功能的集合</p></li><li><p>声明：var o = {}</p></li><li><p>属性与方法</p><ul><li>constructor 保存用于创建当前对象的函数</li><li>hasOwnProperty(propertyName) 检测给定属性值在当前对象实例中是否存在</li><li>isPrototypeOf(object) 检测传入的对象是否是另一个对象的原型</li><li>prototypeIsEnumerable(propertyName) 检测给定属性是否能用for-in语句枚举</li><li>toLocaleString() 返回对象的字符串表示，该字符串与执行环境的地区对应</li><li>toString() 返回的对象的字符串的表示</li><li>valueOf() 返回对象的字符串、数值或者布尔值表示；通常与toString()的值相同</li><li>Object.seal() 功能将对象密封起来，<strong>返回密封后的对象</strong>，阻止添加新属性并将所有现有属性标记为不可配置（不可增加删除）。属性值可以改变。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal">MDN</a></li><li>Object.freeze() 方法可以<strong>冻结</strong>一个对象。不能对属性进行添加，修改，删除，此外，冻结一个对象后该对象的原型也不能被修改。 它仅 对对象进行 浅 冻结，意味着只有 对象中的 直接 属性被冻结 像案例中的 address，address 中的属性没有被冻结，仍然可以被修改。 <code>freeze()</code> 返回和传入的参数相同的对象。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">MDN</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	name: <span class="string">&quot;Lydia Hallie&quot;</span>,</span><br><span class="line">	address: &#123;</span><br><span class="line">		street: <span class="string">&quot;100 Main St&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(person);</span><br><span class="line">person.address.street = <span class="string">&quot;101 Main St&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>es6新增方法</p><ol><li><code>Object.is()</code>比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>Object.assign(target,source1,source2..)</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>1.如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><p>2.如果该参数不是对象，则会先转成对象，然后返回。</p><p>3.只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。即浅拷贝。</p><p>4.用途：为对象添加属性和方法；合并多个对象；克隆对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  someMethod(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li><p>Object.getOwnPropertyDescriptors()</p><ul><li><p>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p></li><li><p>引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p></li><li><p><code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p></li></ul></li><li><p>__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</p><ul><li><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。<ul><li>正常操作他的时候，使用用<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</li></ul></li><li><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。<code>Object.setPrototypeOf(object, prototype)</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><ul><li><code>Object.getPrototypeOf()</code>读取一个对象的原型对象</li></ul></li><li><p>Object.keys()，Object.values()，Object.entries()</p><ul><li><code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</li><li><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</li><li><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对<strong>数组</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="2-7-Symbol"><a href="#2-7-Symbol" class="headerlink" title="2.7.Symbol"></a>2.7.Symbol</h4><ol><li>作用：保证每个属性的名字都是独一无二的</li><li>它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</li><li><code>Symbol</code>函数可以接受一个字符串作为参数</li><li>每个Symbol的值都是独一无二的，也就是说，不管是否有参数，参数是否相等 ，他们的值永远是<strong>不等的</strong></li><li>Symbol 值不能与其他类型的值进行运算，会报错。</li><li>Symbol 值可以显式转为字符串、布尔值，数值不能转换。</li><li>ES9：Symbol.prototype.description可以返回他的描述<code>const sym = Symbol(&#39;foo&#39;);sym.description // &quot;foo&quot;</code></li><li>Symbol 值作为对象属性名时，不能用点运算符。</li><li>使用Symbol值定义属性时，Symbol 值必须放在方括号之中</li><li>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</li><li><code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><ol start="12"><li><code>Symbol.for(参数：要重用的名)</code>方法重新使用同一个Symbol的值，if参数不存在，会新建一个7</li><li>Symbol.keyFor()<code>方法返回一个已登记的 Symbol 类型值的</code>key，也就是可以再次使用的值</li></ol><h4 id="2-8数组"><a href="#2-8数组" class="headerlink" title="2.8数组"></a>2.8数组</h4><p>数组是一个包含了多个值的对象。数组对象可以存储在变量中，并且能用和其他任何类型的值完全相同的方式处理，区别在于我们可以单独访问列表中的每个值，并使用列表执行一些有用和高效的操作，如循环 - 它对数组中的每个元素都执行相同的操作。</p><ol><li>，数组中的每个项目都是一个字符串，但请记住，您可以将任何类型的元素存储在数组中 - 字符串，数字，对象，另一个变量，甚至另一个数组。 您也可以混合和匹配项目类型 - 它们并不都是数字，字符串等。尝试下面这些：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sequence = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>];</span><br><span class="line"><span class="keyword">let</span> random = [<span class="string">&#x27;tree&#x27;</span>, <span class="number">795</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]];</span><br></pre></td></tr></table></figure><ol start="2"><li><p>数组提供的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myData = <span class="string">&#x27;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>slice()方法，是提取字符串的某个部分,返回的是被提取的某个部分。slice(start,end),对于数组对象来说，表示以start起,end结束的一段元素,</p></li><li><p>当只有start一个参数时,表示以start下标开始至结尾的元素,</p><ul><li>若start为负,则表示从尾部开始,</li><li>若start为0,则表示克隆一个数组（<strong>浅拷贝</strong>）</li></ul></li><li><p>splice()方法用于插入,删除或替换数组的元素,返回的是新的数组</p><ul><li>splice(start,deleteCount,[item1],[item2]),表示从start位置开始删除deleteCount个元素,并且可以在这个位置插入n个元素。</li></ul></li><li><p>当start,deleteCount均为0时,表示从前面开始插入元素,</p><ul><li>当只有start一个参数时,如果start为正，就是删除从start开始删除至最后一个元素,</li><li>如果start为负，就是从数组尾部开始删除元素</li></ul></li></ul></li></ol><ul><li><p>split(‘,’) 将数组中的每一项，按某个符号分割为字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myArray &#x3D; myData.split(&#39;,&#39;);</span><br><span class="line">result:[&quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">- maArray.length,数组长度。maArray[0]  检索数组下标为0的值</span><br><span class="line">   - join(&#39;,&#39;)   将数组根据分隔符，转化为字符串</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>let myNewString = myArray.join(‘,’);<br>result:”Manchester,London,Liverpool,Birmingham,Leeds,Carlisle”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   - 要在数组末尾添加或删除一个项目，我们可以使用 [&#96;push()&#96;](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Array&#x2F;push) 和 [&#96;pop()&#96;](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Array&#x2F;pop)。</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;js</span><br><span class="line">&#x2F;&#x2F;当方法调用完成时，将返回数组的新长度。 如果要将新数组长度存储在变量中</span><br><span class="line">   myArray.push(&#39;Cardiff&#39;);</span><br><span class="line">   result:[&quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;, &quot;push方法&quot;]</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;从数组中删除最后一个元素的话直接使用 pop() 就可以，将返回已删除的项目</span><br><span class="line">   myArray.pop();</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift"><code>unshift()</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift"><code>shift()</code></a> 从功能上与 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a> 完全相同，只是它们分别作用于数组的开始，而不是结尾。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将项目添加到第一个，返回数组的新长度</span></span><br><span class="line">myArray.unshift(<span class="string">&#x27;Edinburgh&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除其中的第一个 ，返回的也是删除项</span></span><br><span class="line"><span class="keyword">let</span> removedItem = myArray.shift();</span><br></pre></td></tr></table></figure><ul><li><p>扩展运算符：是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">     </span><br></pre></td></tr></table></figure><p>console.log(…[1, 2, 3])<br>// 1 2 3</p><p>console.log(1, …[2, 3, 4], 5)<br>// 1 2 3 4 5</p><p>[…document.querySelectorAll(‘div’)]<br>// [</p><div>,<div>,<div>]<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"> 该运算符主要用于函数调用。</span><br><span class="line">   </span><br><span class="line"> &#96;&#96;&#96;javascript</span><br><span class="line"> function push(array, ...items) &#123;</span><br><span class="line">   array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>function add(x, y) {<br>return x + y;<br>}</p><p>const numbers = [4, 38];<br>add(…numbers) // 42</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line">   apply函数的取代</span><br><span class="line">     </span><br><span class="line">   &#96;&#96;&#96;javascript</span><br><span class="line">&#x2F;&#x2F; ES5 的写法</span><br><span class="line">   Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ES6 的写法</span><br><span class="line">   Math.max(...[14, 3, 77])</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 等同于</span><br><span class="line">   Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure><p>赋值数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p><strong>合并数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">   <span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">   <span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">   <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ES6 的合并数组</span></span><br><span class="line">   [...arr1, ...arr2, ...arr3]</span><br><span class="line">   <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure><p><strong>与解构赋值结合</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">   rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</span></span><br><span class="line">   <span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><strong>字符串</strong></p><p>扩展运算符还可以将字符串转为真正的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><p><strong>实现了 Iterator 接口的对象</strong></p><p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">     length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// TypeError: Cannot spread non-iterable object.</span></span><br><span class="line">   <span class="keyword">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</p><p><strong>Map 和 Set 结构，Generator 函数</strong></p><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line"> ]);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> [...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></div></div></div></li><li><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"> length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>Array.of</code>方法用于将一组值，转换为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p><p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line">   <span class="built_in">Array</span>.of(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line">   <span class="built_in">Array</span>.of(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line">   <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p><ul><li>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="built_in">this</span>.length)</span><br></pre></td></tr></table></figure><p>它接受三个参数。</p><ul><li><p>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</p></li><li><p>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</p></li><li><p>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</p><p>这三个参数都应该是数值，如果不是，会自动转为数值。</p><ul><li>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后<strong>返回该成员</strong>。如果没有符合条件的成员，则返回<code>undefined</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">   &#125;) <span class="comment">// 10</span></span><br><span class="line">   <span class="comment">// value当前的值</span></span><br><span class="line">   <span class="comment">// index当前的位置</span></span><br><span class="line">   <span class="comment">// arr原数组 </span></span><br></pre></td></tr></table></figure><ul><li>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].find(f, person);</span><br></pre></td></tr></table></figure></blockquote><ul><li><ul><li>fill方法使用给定值，填充一个数组</li></ul><p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p><ul><li><p>对于前端项目开发过程中偶尔会出现层叠数据结构的数组，我们需要将多层级数组转换为一级数组（即：提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。</p></li><li><pre><code class="text">语法：let newArray = arr.flat(depth)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **depth （可选参数）指定要提取嵌套数组的结构深度，默认值为 1。**</span><br><span class="line"></span><br><span class="line">## 面向对象</span><br><span class="line"></span><br><span class="line">### 1.定义</span><br><span class="line"></span><br><span class="line">1. OOP 的基本思想是：在程序里，我们通过使用对象去构建现实世界的模型，并对象把原本很难（或不可）能被使用的功能，简单化并提供出来，以供访问。</span><br><span class="line">2. 对象可以包含相关的数据和代码，这些数据和代码用于表示 你所建造的模型是什么样子，以及拥有什么样的行为或功能。对象包（object package，或者叫命名空间 namespace）存储（官方用语：**封装**）着对象的数据（常常还包括函数），使数据的组织和访问变得更容易了；对象也常用作 数据存储体（data stores），用于在网络上运输数据，十分便捷。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20200625111920033](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200625111920033.png)</span><br><span class="line"></span><br><span class="line">### 2.特性：</span><br><span class="line"></span><br><span class="line">1. 封装性</span><br><span class="line">2. 多元化</span><br><span class="line">3. 继承性</span><br><span class="line"></span><br><span class="line">### 3.创建方式</span><br><span class="line"></span><br><span class="line">1. 创建一个对象</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name : [&#39;Bob&#39;, &#39;Smith&#39;],</span><br><span class="line">  age : 32,</span><br><span class="line">  gender : &#39;male&#39;,</span><br><span class="line">  interests : [&#39;music&#39;, &#39;skiing&#39;],</span><br><span class="line">  bio : function() &#123;</span><br><span class="line">    alert(this.name[0] + &#39; &#39; + this.name[1] + &#39; is &#39; + this.age + &#39; years old. He likes &#39; + this.interests[0] + &#39; and &#39; + this.interests[1] + &#39;.&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting: function() &#123;</span><br><span class="line">    alert(&#39;Hi! I\&#39;m &#39; + this.name[0] + &#39;.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><ol start="2"><li>JavaScript 用一种称为<strong>构建函数</strong>的特殊函数来定义对象和它们的特征。<strong>构建函数</strong>提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = &#123;</span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: first,</span><br><span class="line">    <span class="string">&#x27;last&#x27;</span>: last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.gender = gender;</span><br><span class="line">  <span class="built_in">this</span>.interests = interests;</span><br><span class="line">  <span class="built_in">this</span>.bio = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name.first + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.name.last + <span class="string">&#x27; is &#x27;</span> + <span class="built_in">this</span>.age + <span class="string">&#x27; years old. He likes &#x27;</span> + <span class="built_in">this</span>.interests[<span class="number">0</span>] + <span class="string">&#x27; and &#x27;</span> + <span class="built_in">this</span>.interests[<span class="number">1</span>] + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="built_in">this</span>.name.first + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;male&#x27;</span>, [<span class="string">&#x27;music&#x27;</span>, <span class="string">&#x27;skiing&#x27;</span>]);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>首先, 您能使用<code>Object()</code>构造函数来创建一个新对象。 是的， 一般对象都有构造函数，它创建了一个空的对象。</p><ol><li><p>尝试在您浏览器中的Javascript控制台中输入以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li><li><p>这样就在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1</span><br></pre></td></tr></table></figure><p>变量中存储了一个空对象。然后, 可以根据需要, 使用点或括号表示法向此对象添加属性和方法；试试这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">&#x27;Chris&#x27;</span>;</span><br><span class="line">person1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">38</span>;</span><br><span class="line">person1.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以将对象文本传递给Object() 构造函数作为参数， 以便用属性/方法填充它。请尝试以下操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">  name : <span class="string">&#x27;Chris&#x27;</span>,</span><br><span class="line">  age : <span class="number">38</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>JavaScript有个内嵌的方法create(), 它允许您基于现有对象创建新的对象。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1);</span><br><span class="line">person2.name</span><br><span class="line">person2.greeting()</span><br></pre></td></tr></table></figure><h3 id="4-对象的表示方式"><a href="#4-对象的表示方式" class="headerlink" title="4.对象的表示方式"></a>4.对象的表示方式</h3><ol><li>点表示法：使用了点表示法(dot notation)来访问对象的属性和方法。对象的名字表现为一个命名空间(namespace)，它必须写在第一位——当你想访问对象内部的属性或方法时，然后是一个点(.)，紧接着是你想要访问的项目，标识可以是简单属性的名字(name)，或者是数组属性的一个子元素，又或者是对象的方法调用。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.age</span><br><span class="line">person.interests[<span class="number">1</span>]</span><br><span class="line">person.bio()</span><br></pre></td></tr></table></figure><ol start="2"><li>括号表示法：这看起来很像访问一个数组的元素，从根本上来说是一回事儿，你使用了关联了值的名字，而不是索引去选择元素。难怪对象有时被称之为关联数组(associative array)了——对象做了字符串到值的映射，而数组做的是数字到值的映射。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person.age</span><br><span class="line">person.name.first</span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line">person[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">person[<span class="string">&#x27;name&#x27;</span>][<span class="string">&#x27;first&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="5-设置新建对象成员"><a href="#5-设置新建对象成员" class="headerlink" title="5.设置新建对象成员"></a>5.设置新建对象成员</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person.age = <span class="number">45</span></span><br><span class="line">person[<span class="string">&#x27;name&#x27;</span>][<span class="string">&#x27;last&#x27;</span>] = <span class="string">&#x27;Cratchit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置成员并不意味着你只能更新已经存在的属性的值，你完全可以创建新的成员，如下：</span></span><br><span class="line">person[<span class="string">&#x27;eyes&#x27;</span>] = <span class="string">&#x27;hazel&#x27;</span></span><br><span class="line">person.farewell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">&quot;Bye everybody!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><h3 id="6-this的含义"><a href="#6-this的含义" class="headerlink" title="6.this的含义"></a>6.<code>this</code>的含义</h3><p>1.指向：关键字”this”指向了当前代码运行时的对象( 原文：the current object the code is being written inside )——这里即指person对象</p><p>2.”this”是非常有用的——它保证了当代码的上下文(context)改变时变量的值的正确性（比如：不同的person对象拥有不同的name这个属性，很明显greeting这个方法需要使用的是它们自己的name）。</p><h3 id="7-constructor属性"><a href="#7-constructor属性" class="headerlink" title="7.constructor属性"></a>7.constructor属性</h3><p>每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。</p><ol><li>可以在 <code>constructor</code> 属性的末尾添加一对圆括号（括号中包含所需的参数），从而用这个构造器创建另一个对象实例。毕竟构造器是一个函数，故可以通过圆括号调用；只需在前面添加 <code>new</code> 关键字，便能将此函数作为构造器使用。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person3 = <span class="keyword">new</span> person1.constructor(<span class="string">&#x27;Karen&#x27;</span>, <span class="string">&#x27;Stephenson&#x27;</span>, <span class="number">26</span>, <span class="string">&#x27;female&#x27;</span>, [<span class="string">&#x27;playing drums&#x27;</span>, <span class="string">&#x27;mountain climbing&#x27;</span>]);</span><br></pre></td></tr></table></figure><ol start="2"><li>获得某个对象实例的构造器的名字</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceName.constructor.name</span><br></pre></td></tr></table></figure><ol start="3"><li>修改构造器的原型</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性与方法定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tammi&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;neutral&#x27;</span>, [<span class="string">&#x27;music&#x27;</span>, <span class="string">&#x27;skiing&#x27;</span>, <span class="string">&#x27;kickboxing&#x27;</span>]);</span><br><span class="line">Person.prototype.farewell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name.first + <span class="string">&#x27; has left the building. Bye for now!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 <code>farewell()</code> 方法<em>仍然</em>可用于 <code>person1</code> 对象实例——旧有对象实例的可用功能被自动更新了。这证明了先前描述的原型链模型。</p><ul><li>这种继承模型下，上游对象的方法不会复制到下游的对象实例中；</li><li>下游对象本身虽然没有定义这些方法，但浏览器会通过上溯原型链、从上游对象中找到它们。</li></ul><blockquote><p>一般在构造器（函数体）中定义属性，在prototype属性上定义方法。使得代码更具有可读性。</p></blockquote><h3 id="8-原型的继承"><a href="#8-原型的继承" class="headerlink" title="8.原型的继承"></a>8.原型的继承</h3><ol><li>定义：继承的对象函数并不是通过复制而来，而是通过原型链继承。</li><li>继承：使用<code>call(this,参数1,参数2,...)</code>函数。改变<code>this</code>指向，以重新指定您调用的函数里所有“<code>this</code>”指向的对象。</li></ol><blockquote><p>如果继承的构造函数,不从传入的参数中获取其属性值，则不需要在<code>call()</code>中为其指定其他参数,只需指明<code>this</code>。</p></blockquote><ol start="3"><li>每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性。</li><li><code>prototype</code>本身就是定义在<code>Function</code>对象下的属性</li><li>当我们输入类似<code>var person1=new Person(...)</code>来构造对象时，JavaScript实际上参考的是<code>Person.prototype</code>指向的对象来生成<code>person1</code>。</li><li>Person===Person.prototype.constructor</li></ol><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ol><li>JSON 是用于将结构化数据表示为JavaScript对象的标准格式，通常用于在网站上表示和传输数据。</li><li>认识：是一种按照JavaScript对象语法的数据格式；是基于 JavaScript 语法，但它独立于JavaScript。</li><li>JSON可以作为一个对象或者字符串存在，使用对象用于解读 JSON 中的数据，使用字符串用于通过网络传输 JSON 数据</li><li>JSON还是一种数组，因为数组对象也是一种合法的 JSON 对象。</li><li>一个 JSON 对象可以被储存在它自己的文件中，这基本上就是一个文本文件，扩展名为 <code>.json</code></li><li>JSON结构： JSON 数据——&gt;字符串，数字，数组，布尔还有其它的字面值对象。这允许您构造出一个对象树。</li></ol><blockquote><ul><li>JSON 是一种纯数据格式，它只包含属性，没有方法。</li><li>JSON 要求有两头的 { } 来使其合法。最安全的写法是有两边的括号，而不是一边。</li><li>在 JSON 中，只有字符串才能用作属性。</li><li>甚至一个错位的逗号或分号就可以导致 JSON 文件出错</li></ul></blockquote><ol start="7"><li>请求加载<code>JSON</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestURL = <span class="string">&#x27;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> request = XMLHttpRequest();</span><br><span class="line"><span class="comment">//请求</span></span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, requestURL);</span><br><span class="line"><span class="comment">//responseType 为 JSON，让服务器将知道我们想要返回一个 JSON 对象，然后发送请求</span></span><br><span class="line">request.responseType = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line">request.send();</span><br><span class="line"><span class="comment">//响应来自服务器返回的数据</span></span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> superHeroes = request.response;</span><br><span class="line">  <span class="keyword">var</span> superHeroes = <span class="built_in">JSON</span>.parse(superHeroesText);</span><br><span class="line">  populateHeader(superHeroes);</span><br><span class="line">  showHeroes(superHeroes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>对象和文本间的转换</li></ol><ul><li><code>parse()</code>: 以文本字符串形式接受JSON对象作为参数，并返回相应的对象。。</li><li><code>stringify()</code>: 接收一个对象作为参数，返回一个对应的JSON字符串。</li></ul><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h3><ol><li><p>何为异步：通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的<strong>结果</strong>，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕.</p></li><li><p>定义：在程序解析运行的时候，在做一件事的同时，还能做别的事，比如，你排队买饭的时候可以刷微博等等。同步是需要等待的，存在堵塞的情况。</p></li><li><p>何时需要异步</p></li></ol><ul><li>在可能发生等待的情况</li><li>等待过程中不能像alert一样阻塞程序运行</li><li>因此，所有的”等待的情况”都需要异步</li></ul><ol start="4"><li>前端使用异步的场景</li></ol><ul><li>定时任务：<code>setTimeout</code>,<code>setInverval</code></li><li>网络请求：<code>ajax</code>请求，动态<img>加载</li><li>事件绑定</li></ul><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><ol><li>定义：在执行代码的时候，一个单线程一次只能干一件事情。</li><li>JavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（<strong>main thread</strong>）。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task A --&gt; Task B --&gt; Task C</span><br></pre></td></tr></table></figure><pre><code>    &lt;script&gt;
        console.log(100)
            // 异步：在可能发生等待的情况
        setTimeout(function() &#123;
            console.log(200)
        &#125;)
    // alert(200) //同步有堵塞
    console.log(300)</code></pre><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200530195614893.png" alt="image-20200530195614893"></p><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><h4 id="callbacks回调函数"><a href="#callbacks回调函数" class="headerlink" title="callbacks回调函数"></a>callbacks回调函数</h4><p>当我们把回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去——回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAsset</span>(<span class="params">url, type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.responseType = type;</span><br><span class="line"></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayImage</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadAsset(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>, displayImage);</span><br></pre></td></tr></table></figure><blockquote><p>执行过程：创建 <code>displayImage()</code> 函数，简单的把blob传递给它，生成objectURL，然后再生成一个image元素，把objectURL作为image的源地址，最后显示这张图片。 然后，我们创建 <code>loadAsset()</code>函数，把URL，type，和回调函数同时都作为参数</p></blockquote><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promises 是新派的异步代码，现代的web APIs经常用到。 <code>fetch()</code> API就是一个很好的例子, 它基本上就是一个现代版的，更高效的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;products.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  products = json;</span><br><span class="line">  initialize();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Fetch problem: &#x27;</span> + err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a><strong>过程解析</strong></h5><ul><li>两个 <code>then()</code> 块。两者都包含一个回调函数，如果前一个操作成功，该函数将运行，并且每个回调都接收前一个成功操作的结果作为输入，因此您可以继续对它执行其他操作。每个 <code>.then()</code>块返回另一个promise，这意味着可以将多个<code>.then()</code>块链接到另一个块上，这样就可以依次执行多个异步操作。</li><li>如果其中任何一个<code>then()</code>块失败，则在末尾运行<code>catch()</code>块——与同步<code>try...catch</code>类似，<code>catch()</code>提供了一个错误对象，可用来报告发生的错误类型。但是请注意，同步<code>try...catch</code>不能与promise一起工作，尽管它可以与<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await">async/await</a>一起工作。</li></ul><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol><li>创建promise时，它既不是成功也不是失败状态。这个状态叫作<strong>pending</strong>（待定）。</li><li>当promise返回时，称为 resolved（已解决）.<ol><li>一个成功<strong>resolved</strong>的promise称为<strong>fullfilled</strong>（<strong>实现</strong>）。它返回一个值，可以通过将<code>.then()</code>块链接到promise链的末尾来访问该值。<code>.then()</code>块中的执行程序函数将包含promise的返回值。</li><li>一个不成功<strong>resolved</strong>的promise被称为<strong>rejected</strong>（<strong>拒绝</strong>）了。它返回一个原因（<strong>reason</strong>），一条错误消息，说明为什么拒绝promise。可以通过将<code>.catch()</code>块链接到promise链的末尾来访问此原因。</li></ol></li></ol><h5 id="then"><a href="#then" class="headerlink" title="then"></a>then</h5><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数,</p><ul><li>参数一：<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，</li><li>参数二：第二个参数（可选）是<code>rejected</code>状态的回调函数。</li><li>返回值：<code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</li></ul><h5 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h5><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的<strong>回调函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;/posts.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;/post/1.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p></blockquote><p>Promise 内部的错误不会影响到 Promise 外部的代码。浏览器不会检测到。不过Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="all"><a href="#all" class="headerlink" title="all"></a>all</h5><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all()</a>静态方法完成此操作。这将一个promises数组作为输入参数，并返回一个新的Promise对象，只有当数组中的所有promise都满足时才会满足</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([a, b, c]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果它们都实现，那么链接的.then()块的执行器函数将被传递一个包含所有这些结果作为参数的数组。如果传递给Promise.all()的任何一个promise被拒绝，整个块将拒绝。</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个返回promise的函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchAndDecode</span>(<span class="params">url, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;blob&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.blob();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.text();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将返回的promises存储在变量中</span></span><br><span class="line"><span class="keyword">let</span> coffee = fetchAndDecode(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tea = fetchAndDecode(<span class="string">&#x27;tea.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> description = fetchAndDecode(<span class="string">&#x27;description.txt&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise.all()代码块</span></span><br><span class="line"><span class="built_in">Promise</span>.all([coffee, tea, description]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(values);</span><br><span class="line">    <span class="keyword">let</span> objectURL1 = URL.createObjectURL(values[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> objectURL2 = URL.createObjectURL(values[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> descText = values[<span class="number">2</span>];</span><br><span class="line">	<span class="comment">// Display the images in &lt;img&gt; elements</span></span><br><span class="line">    <span class="keyword">let</span> image1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> image2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    image1.src = objectURL1;</span><br><span class="line">    image2.src = objectURL2;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image1);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image2);</span><br><span class="line">    <span class="comment">// Display the text in a paragraph</span></span><br><span class="line">    <span class="keyword">let</span> para = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    para.textContent = descText;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(para);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p></blockquote><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><ul><li><code>finally</code>方法的回调函数不接受任何参数</li><li><code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li><li><code>finally</code>本质上是<code>then</code>方法的特例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例子：服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure><p>在最近的现代浏览器中，<code>.finally()</code> 方法可用，它可以链接到常规promise链的末尾，允许您减少代码重复并更优雅地执行操作。上面的代码现在可以写成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">myPromise</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  doSomething(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  returnError(e);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  runFinalCode();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="race"><a href="#race" class="headerlink" title="race"></a>race</h5><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">&#x27;/resource-that-may-take-a-while&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;request timeout&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><h5 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h5><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  fetch(<span class="string">&#x27;/api-1&#x27;</span>),</span><br><span class="line">  fetch(<span class="string">&#x27;/api-2&#x27;</span>),</span><br><span class="line">  fetch(<span class="string">&#x27;/api-3&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line">removeLoadingIndicator();</span><br></pre></td></tr></table></figure><blockquote><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p></blockquote><ul><li>该方法返回的新的 Promise 实例</li><li>一旦结束，状态总是<code>fulfilled</code></li><li>状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><ul><li>判断所有异步操作是否都结束</li></ul><h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.resolve</code>方法的参数分成四种情况</p><ul><li><p>参数是一个 Promise 实例</p><ul><li>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</li></ul></li><li><p>参数是一个thenable对象</p><ul><li><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p></li></ul></li><li><p><strong>参数不是具有<code>then</code>方法的对象，或根本就不是对象</strong></p><ul><li><p>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>不带有任何参数</strong></p><ul><li><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</li><li>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</li></ul></li></ul><h5 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h5><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><h5 id="构建自定义promise"><a href="#构建自定义promise" class="headerlink" title="构建自定义promise"></a>构建自定义promise</h5><p>可以使用<code>Promise()</code> 构造函数构建自己的promise。您希望这样做的主要情况是，当您获得基于非基于promise的旧式异步API的代码时，您希望实现这一点。当您需要使用现有的旧项目代码，库或框架以及基于现代promise的代码时，这会派上用场。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用promise包装一个setTimeout()调用 - 这会在两秒后运行一个函数</span></span><br><span class="line"><span class="keyword">let</span> timeoutPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  resolve()和reject()是您调用以实现或拒绝新创建的promise的函数。</span></span><br></pre></td></tr></table></figure><p>调用此promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timeoutPromise</span><br><span class="line">.then(<span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">   alert(message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>拒绝一个自定义promise</p><p>我们可以创建一个<code>reject()</code> 方法拒绝promise - 就像<code>resolve()</code>一样，这需要一个值，但在这种情况下，它是拒绝的原因，即将传递给<code>.catch()</code>的错误块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">message, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (message === <span class="string">&#x27;&#x27;</span> || <span class="keyword">typeof</span> message !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      reject(<span class="string">&#x27;Message is empty or not a string&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval &lt; <span class="number">0</span> || <span class="keyword">typeof</span> interval !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      reject(<span class="string">&#x27;Interval is negative or not a number&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(message);</span><br><span class="line">      &#125;, interval);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">timeoutPromise(<span class="string">&#x27;Hello there!&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line">.then(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">   alert(message);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h4><p>像promise这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。</p><h4 id="Promise与callback对比"><a href="#Promise与callback对比" class="headerlink" title="Promise与callback对比"></a>Promise与callback对比</h4><p>promises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。</p><p>而，<code>Promise</code>是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p><ul><li>您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为<a target="_blank" rel="noopener" href="http://callbackhell.com/">回调地狱</a>)。</li><li><code>Promise</code>总是严格按照它们放置在事件队列中的顺序调用。</li><li>错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。</li></ul><h3 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h3><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h4><ol><li><p>定义：在指定的时间后执行一段代码.</p></li><li><p>参数：<code>let myGreeting = setTimeout(val1, val2, val3);</code></p><ul><li>val1 要运行的函数，或者函数引用。</li><li>val2 表示在执行代码之前等待的时间间隔（以毫秒为单位，1000ms = 1s）的数字。如果指定值为0，函数会在主线程序完成后，立即运行。</li><li>val3 更多的参数：在指定函数运行时，希望传递给函数的值.</li></ul></li><li><p>val1 函数的命名，可以是匿名函数，也可以是具名函数（可以引用，响应）。</p></li><li><p>返回值：返回一个<strong>标志符</strong>变量用来引用这个间隔，可以稍后用来取消这个超时任务。</p></li><li><p>清除超时：调用<code>clearTimeout()</code>，将<code>setTimeout()</code>调用的<strong>标识符</strong>作为参数传递给它，从而在超时运行之前取消。或要取消上面的超时</p></li></ol><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h4><ol><li>定义：以固定的时间间隔，重复运行一段代码.</li><li>返回值：返回一个确定的值，稍后你可以用它来取消间隔任务。</li><li>清除: 将返回值作为参数传递给<code>clearInterval</code>()</li><li>参数同setTimeout一样。</li></ol><h4 id="setTimeout-和-setInterval-注意点"><a href="#setTimeout-和-setInterval-注意点" class="headerlink" title="setTimeout() 和 setInterval() 注意点"></a>setTimeout() 和 setInterval() 注意点</h4><ol><li>递归的setTimeout也可以用它来重复运行相同的代码。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用setInterval()</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>递归setTimeout()和setInterval()有何不同</li></ol><ul><li>递归 setTimeout() 保证执行之间的延迟相同</li><li>使用 <code>setInterval()</code> 的示例有些不同。 我们选择的<strong>间隔包括执行我们想要运行的代码所花费的时间</strong>。假设为100毫秒，代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒</li><li>当递归使用 <code>setTimeout()</code> 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。</li></ul><ol start="3"><li><p>立即超时</p><p>使用0用作setTimeout()的回调函数会立刻执行，但是在主线程代码运行之后执行。</p></li></ol><h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame()</a></h4><ol><li>定义：setInterval()的现代版本;在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在适当的帧率下运行，而不管它在什么环境中运行.</li><li>它是针对<code>setInterval()</code> 遇到的问题创建的，比如 <code>setInterval()</code>并不是针对设备优化的帧率运行，有时会丢帧。还有即使该选项卡不是活动的选项卡或动画滚出页面等问题</li><li>函数参数：该方法将重新加载页面之前要调用的回调函数作为参数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><ol start="4"><li>应用：定义一个函数，在其中更新动画 (例如，移动精灵，更新乐谱，刷新数据等)，然后调用它来开始这个过程。在函数的末尾，以 <code>requestAnimationFrame()</code> 传递的函数作为参数进行调用，这指示浏览器在下一次显示重新绘制时再次调用该函数。然后这个操作连续运行， 因为<code>requestAnimationFrame()</code> 是递归调用的。</li><li>时间戳：传递给 <code>requestAnimationFrame()</code> 函数的实际回调也可以被赋予一个参数（一个时间戳值），表示自 <code>requestAnimationFrame()</code> 开始运行以来的时间。这是很有用的，因为它允许您在特定的时间以恒定的速度运行，而不管您的设备有多快或多慢。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!startTime) &#123;</span><br><span class="line">         startTime = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        rotateCount = (timestamp - startTime) / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// If rotateCount gets over 359, set it to &#x27;remainder of dividing by 360&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(rotateCount &gt; <span class="number">359</span>) &#123;</span><br><span class="line">          rotateCount %= <span class="number">360</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set the rotation of the div to be equal to rotateCount degrees</span></span><br><span class="line">        spinner.style.transform = <span class="string">&#x27;rotate(&#x27;</span> + rotateCount + <span class="string">&#x27;deg)&#x27;</span>;</span><br><span class="line">        <span class="comment">// Call the next frame in the animation</span></span><br><span class="line">        rAF = requestAnimationFrame(draw);</span><br><span class="line">      &#125;</span><br><span class="line">      draw();</span><br></pre></td></tr></table></figure><h3 id="async-await的基本要素"><a href="#async-await的基本要素" class="headerlink" title="async/await的基本要素"></a>async/await的基本要素</h3><ol><li>认识：它是promises的语法糖，使得异步代码更易于编写和后续阅读。它们使异步代码看起来更像是旧式同步代码。</li><li>async关键词：使用<code>async</code>关键字，您可以将它放在函数声明之前，将其转换为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async function</a>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br><span class="line"><span class="comment">// 调用该函数会返回一个promise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异步函数表达式</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> () =&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 要实际使用promise实现时返回的值，因为它返回了一个promise，我们可以使用.then()块</span></span><br><span class="line">hello().then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure><ol start="3"><li><p>await关键词：与async关键词联合使用，放在任何基于异步声明的函数之前</p><p>作用：暂停代码在该行上执行，直到promise完成，然后返回结果值。与此同时，其他正在等待执行机会的代码就有可能如愿执行了。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> greeting = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hello().then(alert);</span><br></pre></td></tr></table></figure><ol start="4"><li>示例：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch()</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于<code>async</code>关键字将函数转换为promise，因此您可以重构代码以使用<code>promises</code>和<code>await</code>的混合方法，将函数的后半部分放入新块中以使其更灵活：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> response.blob();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch().then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>执行过程：在方法调用前添加的await关键字，然后把结果赋给变量。 await关键字使JavaScript运行时暂停此行上的代码，允许其他代码在此期间执行，直到异步函数调用返回其结果。一旦完成，您的代码将继续从下一行开始执行</li></ol><h2 id="JS中的可枚举属性"><a href="#JS中的可枚举属性" class="headerlink" title="JS中的可枚举属性"></a>JS中的可枚举属性</h2><p>概念：</p><p>可枚举性（enumerable）用来控制所描述的属性，是否将被包括在for…in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。</p><ul><li>for..in循环</li><li>Object.keys方法</li><li>JSON.stringify方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line">o.c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;d&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">4</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">o.d</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> o ) <span class="built_in">console</span>.log( o[key] ); </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Object</span>.keys(o)  <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>至于<code>for...in</code>循环和<code>Object.keys</code>方法的区别，在于前者包括对象继承<code>的</code>属性，而后者只包括对象<code>本身的</code>属性</li><li>如果需要获取对象自身的所有属性，不管enumerable的值，可以使用<code>Object.getOwnPropertyNames</code>方法</li><li>自定义js对象属性默认的enumerable为true，除非用Object.defineProperty函数更改属性特性的值</li><li>js封装的基本类型对象的属性的enumberable为false，如Object，Number，Array等，具体比如一个js数组的length属性就是不可枚举的</li></ol></blockquote><h1 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h1><h2 id="什么是API"><a href="#什么是API" class="headerlink" title="什么是API"></a>什么是API</h2><p>应用程序接口（API）是基于编程语言构建的结构，使开发人员更容易地创建复杂的功能。它们抽象了复杂的代码，并提供一些简单的接口规则直接使用。</p><h2 id="常见的浏览器API"><a href="#常见的浏览器API" class="headerlink" title="常见的浏览器API"></a>常见的浏览器API</h2><ul><li>操作文档的API内置于浏览器中。最明显的例子是DOM（文档对象模型）API，它允许您操作HTML和CSS — 创建、移除以及修改HTML，动态地将新样式应用到您的页面，等等。</li><li><strong>从服务器获取数据的API</strong> 用于更新网页的一小部分是相当好用的。这个看似很小的细节能对网站的性能和行为产生巨大的影响 — 如果您只是更新一个股票列表或者一些可用的新故事而不需要从服务器重新加载整个页面将使网站或应用程序感觉更加敏感和“活泼”。使这成为可能的API包括<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a>。您也可能会遇到描述这种技术的术语<strong>Ajax</strong>。</li><li><strong>用于绘制和操作图形的API</strong>目前已被浏览器广泛支持 — 最流行的是允许您以编程方式更新包含在HTML <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas">``</a> 元素中的像素数据以创建2D和3D场景的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a>。</li><li><strong>音频和视频API</strong>例如<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API">Web Audio API</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/MDN/Doc_status/API/WebRTC">WebRTC</a>允许您使用多媒体来做一些非常有趣的事情</li><li><strong>设备API</strong></li><li><strong>客户端存储API</strong>在Web浏览器中的使用变得越来越普遍 - 如果您想创建一个应用程序来保存页面加载之间的状态，甚至让设备在处于脱机状态时可用，那么在客户端存储数据将会是非常有用的。例如使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a>的简单的键 - 值存储以及使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a>的更复杂的表格数据存储。</li></ul><h2 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h2><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200701164451220.png" alt="image-20200701164451220"></p><h4 id="ECMAScript-JavaScript的核心"><a href="#ECMAScript-JavaScript的核心" class="headerlink" title="ECMAScript - JavaScript的核心"></a>ECMAScript - JavaScript的核心</h4><p>定义了javascript的语法规范</p><p>JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关</p><h4 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM - 浏览器对象模型"></a>BOM - 浏览器对象模型</h4><p>一套操作浏览器功能的API</p><p>通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等</p><h4 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM - 文档对象模型"></a>DOM - 文档对象模型</h4><p>一套操作页面元素的API</p><p>DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作</p><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象</p><h3 id="BOM的顶级对象window"><a href="#BOM的顶级对象window" class="headerlink" title="BOM的顶级对象window"></a>BOM的顶级对象window</h3><p>window是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window<br>注意：window下一个特殊的属性 window.name</p><p>当window这个对象名被占用了，可以使用<code>Top</code></p><h3 id="系统的对话框"><a href="#系统的对话框" class="headerlink" title="系统的对话框"></a>系统的对话框</h3><ul><li>alert() //提示框</li><li>prompt() //输入对话框</li><li>confirm() //对话框返回参数，确定是true，取消是false</li></ul><h3 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h3><ul><li>onload</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当页面加载完成执行</span></span><br><span class="line">  <span class="comment">// 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onunload —- 在谷歌里面不支持</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当用户退出页面时执行</span></span><br><span class="line">  <span class="comment">//用户关闭页面时候弹出的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setTimeout-和clearTimeout"><a href="#setTimeout-和clearTimeout" class="headerlink" title="setTimeout()和clearTimeout()"></a>setTimeout()和clearTimeout()</h4><p>在指定的毫秒数到达之后执行指定的函数，只执行一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个定时器，1000毫秒后执行，返回定时器的标识，即返回的值timerId是定时器的id值</span></span><br><span class="line"><span class="keyword">var</span> timerId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);<span class="comment">//1秒执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器的执行，需要把定时器的id值传给取消定时器</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br></pre></td></tr></table></figure><h4 id="setInterval-和clearInterval"><a href="#setInterval-和clearInterval" class="headerlink" title="setInterval()和clearInterval()"></a>setInterval()和clearInterval()</h4><p>定时调用的函数，可以按照给定的时间(单位毫秒)周期调用函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个定时器，每隔1秒调用一次</span></span><br><span class="line"><span class="keyword">var</span> timerId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(date.toLocaleTimeString());</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器的执行</span></span><br><span class="line"><span class="built_in">clearInterval</span>(timerId);</span><br></pre></td></tr></table></figure><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location 对象存储了当前文档位置（URL）相关的信息，简单地说就是网页地址字符串。使用 window 对象的 location 属性可以访问。</p><p>location 对象定义了 8 个属性，其中 7 个属性可以获取当前 URL 的各部分信息，另一个属性（href）包含了完整的 URL 信息</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>统一资源定位符 (Uniform Resource Locator, URL)</p><p>URL的组成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scheme:&#x2F;&#x2F;host:port&#x2F;path?query#fragment</span><br><span class="line">scheme:通信协议</span><br><span class="line">	常用的http,ftp,maito等</span><br><span class="line">	</span><br><span class="line">host:主机</span><br><span class="line">	服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。</span><br><span class="line">port:端口号</span><br><span class="line">	整数，可选，省略时使用方案的默认端口，如http的默认端口为80。</span><br><span class="line">path:路径</span><br><span class="line">	由零或多个&#39;&#x2F;&#39;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。</span><br><span class="line">query:查询</span><br><span class="line">	可选，用于给动态网页传递参数，可有多个参数，用&#39;&amp;&#39;符号隔开，每个参数的名和值用&#39;&#x3D;&#39;符号隔开。例如：name&#x3D;zs</span><br><span class="line">fragment:信息片断</span><br><span class="line">	字符串，锚点.</span><br></pre></td></tr></table></figure><h4 id="location成员"><a href="#location成员" class="headerlink" title="location成员"></a>location成员</h4><p>成员</p><ul><li>assign()：与href一样，但是他是一个方法</li><li>reload()：重新加载—刷新</li><li>replace()：与assign功能一致，但是不存在历史记录</li><li>hash：得到是<code>#</code>之后的内容</li><li>host：主机名及端口号</li><li>hostname：主机名</li><li>port：端口号</li><li>pathname：文件的相对路径</li><li>protocol：协议</li><li>search：搜索的内容</li><li><strong><em>href</em></strong>：设置跳转的页面地址(属性)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http:<span class="comment">//www.xmg.com:8080/index.html?id=666&amp;psd=123#xxx   </span></span><br><span class="line"></span><br><span class="line">- location.hash  <span class="comment">//哈希值 其实就是锚点     ==&gt; #xxx</span></span><br><span class="line">- location.host  <span class="comment">//服务器 服务器名+端口号  =&gt; www.xmg.com:8080</span></span><br><span class="line">- location.hostname <span class="comment">//服务器名            =&gt;  www.xmg.com</span></span><br><span class="line">- location.pathname <span class="comment">//路径名             =&gt; index.html</span></span><br><span class="line">- location.port <span class="comment">//端口                   =&gt; 8080</span></span><br><span class="line">- location.protocol <span class="comment">//协议               =&gt; http </span></span><br><span class="line">- location.search <span class="comment">//参数                 =&gt; ?id=666&amp;psd=123</span></span><br></pre></td></tr></table></figure><p>解析URL中的query，并返回对象的形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQuery</span>(<span class="params">queryStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> query = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (queryStr.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = queryStr.indexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    queryStr = queryStr.substr(index + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> array = queryStr.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> tmpArr = array[i].split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (tmpArr.length === <span class="number">2</span>) &#123;</span><br><span class="line">        query[tmpArr[<span class="number">0</span>]] = tmpArr[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getQuery(location.search));</span><br><span class="line"><span class="built_in">console</span>.log(getQuery(location.href));</span><br></pre></td></tr></table></figure><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><ul><li>back()</li><li>forward()</li><li>go() //go(-1)后退，go(1)前进</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后退：</span></span><br><span class="line">history.back();</span><br><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//前进：</span></span><br><span class="line">history.forward();</span><br><span class="line">history.go(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><ul><li>navigator.userAgent</li></ul><p>通过userAgent可以判断用户浏览器的类型</p><ul><li>navigator.platform</li></ul><p>通过platform可以判断浏览器所在的系统平台类型.</p><h3 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(screen.width);<span class="comment">//屏幕的宽度 </span></span><br><span class="line"><span class="built_in">console</span>.log(screen.height);<span class="comment">//屏幕的高度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.availWidth);<span class="comment">//浏览器可占用的宽度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.availHeight);<span class="comment">//浏览器可占用的高度</span></span><br><span class="line">offset系列 (重要)</span><br></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="DOM的概念"><a href="#DOM的概念" class="headerlink" title="DOM的概念"></a>DOM的概念</h3><p>文档对象模型（Document Object Model，简称DOM），是<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/W3C">W3C</a>组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。Document Object Model的历史可以追溯至1990年代后期微软与<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/Netscape">Netscape</a>的“浏览器大战”，双方为了在<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/JavaScript">JavaScript</a>与<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/JScript">JScript</a>一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/VBScript">VBScript</a>、<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/ActiveX">ActiveX</a>、以及微软自家的<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/DHTML">DHTML</a>格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。</p><p>DOM又称为文档树模型</p><p>![1497154623955](F:/视频教程/HTML/webapi/ziyuan/02-JavaScript-WEB-API-第1天/01教学资料/02-Web API/media/1497154623955.png)</p><ul><li>文档(document)：一个网页可以称为文档</li><li>节点(node)：网页中的所有内容都是节点（标签、属性、文本、注释等）</li><li>元素(Element)：网页中的标签</li><li>属性(attribute)：标签的属性</li></ul><h3 id="DOM经常进行的操作"><a href="#DOM经常进行的操作" class="headerlink" title="DOM经常进行的操作"></a>DOM经常进行的操作</h3><ul><li>获取元素</li><li>动态创建元素</li><li>对元素进行操作(设置其属性或调用其方法)</li><li>事件(什么时机做相应的操作)</li></ul><h3 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h3><ol><li>根据id获取元素</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);</span><br><span class="line"><span class="comment">// 获取到的数据类型 HTMLDivElement，对象都是有类型的</span></span><br><span class="line"><span class="comment">// 第一个方法: getElementById()</span></span><br><span class="line"><span class="comment">// 作用 : 根据 id值  , 获取元素</span></span><br><span class="line"><span class="comment">// 参数 : 字符串 id值</span></span><br><span class="line"><span class="comment">// 返回值 :  一个对象</span></span><br><span class="line"><span class="comment">// 注意点 : element </span></span><br><span class="line"><span class="comment">// 方法 : 1个</span></span><br><span class="line"><span class="comment">// document.getElementById();</span></span><br></pre></td></tr></table></figure><p><strong>获取到的数据类型有：</strong></p><p>HTMLDivElement &lt;– HTMLElement &lt;– Element &lt;– Node &lt;– EventTarget</p><p><strong>关于<code>console.log</code>和<code>console.dir</code>的区别</strong></p><ul><li><code>console.log</code>打印一个元素的时候，是以标签的形式进行展示的</li><li><code>console.dir</code>打印一个元素的时候，是以对象的形式进行展示的</li></ul><ol start="2"><li>根据标签名获取元素</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> div = divs[i];</span><br><span class="line">  <span class="built_in">console</span>.log(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个方法: getElementsByTagName()</span></span><br><span class="line"><span class="comment">// 作用 : 根据 标签名 , 获取元素</span></span><br><span class="line"><span class="comment">// 参数 : 字符串 标签名 </span></span><br><span class="line"><span class="comment">// 返回值 : 数组 (一般使用的话 都是遍历) </span></span><br><span class="line"><span class="comment">// 注意点 : elements </span></span><br><span class="line"><span class="comment">// 方法 :  2个</span></span><br><span class="line"><span class="comment">// document.getElementsByTagName() </span></span><br><span class="line"><span class="comment">// element.getElementsByTagName()</span></span><br></pre></td></tr></table></figure><ol start="3"><li>根据name获取元素</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputs = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;hobby&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; inputs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> input = inputs[i];</span><br><span class="line">  <span class="built_in">console</span>.log(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>根据类名获取元素</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mains = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mains.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> main = mains[i];</span><br><span class="line">  <span class="built_in">console</span>.log(main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>根据选择器获取元素</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#text&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boxes = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; boxes.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> box = boxes[i];</span><br><span class="line">  <span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>总结</p><p>​ getElementsByTagName()<br>​ getElementsByName()<br>​ getElementsByClassName() 这三种方式获取到的是数组，使用的时候，需要按下标</p></li></ul><p>​ getElementById() 获取单个元素或节点<br>​ querySelector() 返回符合条件的第一个<br>​ querySelectorAll() 返回符合条件的全部</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件：触发-响应机制</p><p>Event接口表示在DOM中发生的任何事件，一些是用户生成的（例如鼠标或键盘事件），而其他由API生成。</p><h3 id="1-事件三要素"><a href="#1-事件三要素" class="headerlink" title="1.事件三要素"></a>1.事件三要素</h3><ul><li>事件源: 触发(被)事件的元素</li><li>事件类型: 事件的触发方式(例如鼠标点击或键盘点击)</li><li>事件处理程序: 事件触发后要执行的代码(函数形式)</li></ul><h3 id="2-事件的三个阶段"><a href="#2-事件的三个阶段" class="headerlink" title="2.事件的三个阶段"></a>2.事件的三个阶段</h3><ol><li><p>捕获阶段 : 从外向里</p></li><li><p>当前目标阶段：最开始选择的那个</p></li><li><p>冒泡阶段 ：从里向外</p><p>事件对象（e）.eventPhase属性可以查看事件触发时所处的阶段如果这个属性值是：</p><ul><li><p>1———-&gt; 捕获阶段</p></li><li><p>2———–&gt; 目标阶段</p></li><li><p>3———–&gt; 冒泡</p></li></ul><p>一般默认是冒泡，很少使用捕获</p></li></ol><h3 id="3-事件的基本使用"><a href="#3-事件的基本使用" class="headerlink" title="3.事件的基本使用"></a>3.事件的基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;代码会在box被点击后执行&#x27;</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-获取事件对象"><a href="#4-获取事件对象" class="headerlink" title="4.获取事件对象"></a>4.获取事件对象</h3><p><strong>现代浏览器获取 : (掌握)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给一个形参即可</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//event就是事件对象，里面包含了事件触发时的一些信息。</span></span><br><span class="line">    <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>低版本浏览器 (ie678): (了解)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//IE678通过window.event获取事件对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>兼容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//只要用到了事件对象，就要记得处理浏览器兼容性</span></span><br><span class="line">    event = event || <span class="built_in">window</span>.event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-事件对象的常用属性"><a href="#5-事件对象的常用属性" class="headerlink" title="5.事件对象的常用属性"></a>5.事件对象的常用属性</h3><blockquote><p>事件对象中有很多很多的属性，但是很多属性并不常用。我们经常用到的是鼠标位置信息 和键盘码 相关的信息。</p></blockquote><ol><li><strong>鼠标位置信息的相关属性</strong><ul><li>clientX与clientY： 相对于浏览器可视区左上角的位置 （常用）光标相对于可视区左上角的水平位置和垂直位置。</li><li>pageX与pageY：相对于网页内容左上角的位置光标相对于网页（文档document）左上角的水平位置与垂直位置</li><li>screenX与screenY：相对于屏幕左上角的位置光标相对于屏幕左上角的水平位置与垂直位置。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取事件对象</span></span><br><span class="line">    <span class="comment">//clientX  clientY  :获取的是鼠标在可视区的位置</span></span><br><span class="line">    <span class="comment">//pageX    pageY    :获取的是鼠标在整个页面中的位置： 包括scrollTop</span></span><br><span class="line">    <span class="comment">//screenX scrennY   ：获取在屏幕中的位置</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.clientX, e.clientY);</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageX, e.pageY);</span><br><span class="line">    <span class="built_in">console</span>.log(e.screenX, e.screenY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>记录了键盘码的属性</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事件学习:</span><br><span class="line">onkeydown : 键盘按下</span><br><span class="line">onkeyup : 键盘抬起</span><br><span class="line">适用于<span class="built_in">document</span>和input等等</span><br><span class="line">event.keyCode:键盘按下的那个键的键盘码</span><br></pre></td></tr></table></figure><h3 id="6-注册事件的方式"><a href="#6-注册事件的方式" class="headerlink" title="6.注册事件的方式"></a>6.注册事件的方式</h3><p>1.on + 事件名称</p><blockquote><p>onclick、onmouseover这种on+事件名称的方式注册事件几乎所有的浏览器都支持。</p></blockquote><p><strong>注册事件：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box.onclick = function()&#123;</span><br><span class="line">    //事件处理程序    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移除事件：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.onclick = null; </span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><p>同一个元素同一类型的事件，只能注册一个，如果注册了多个，会出现覆盖问题</p><p>2.<strong>addEventListener</strong></p><blockquote><p>现代浏览器支持的注册事件的新方式，这种方式注册的事件不会出现覆盖问题。存在兼容性问题</p></blockquote><p><strong>addEventListener的语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数：事件的类型：click mouseover</span></span><br><span class="line"><span class="comment">//第二个参数：函数，监听者，每次点击，这个函数就执行。</span></span><br><span class="line">element.addEventListener(type, func);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">111</span>); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>removeEventListen的语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数：参数类型</span></span><br><span class="line"><span class="comment">//第二个参数：要移除的那个函数</span></span><br><span class="line">element.removeEventListener(type, func);</span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,fn);</span><br><span class="line"><span class="comment">// 注意 : 如果想让注册的事件能移除，不能用匿名函数。</span></span><br></pre></td></tr></table></figure><p>低版本浏览器兼容问题</p><blockquote><p>IE678不支持addEventListener与removeEventListen两个方法，但是支持attachEvent与detachEvent</p></blockquote><p>attachEvent的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type:事件类型   需要加上on   onclick  onmouseenter</span></span><br><span class="line"><span class="comment">//func:需要执行的那个事件</span></span><br><span class="line">attachEvent(type, func)</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码:</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>detachEvent的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;type:事件类型   需要加上on   onclick  onmouseenter</span><br><span class="line">&#x2F;&#x2F;func:需要执行的那个事件</span><br><span class="line">detachEvent(type, func)</span><br><span class="line">兼容性封装（了解）</span><br><span class="line">&#x2F;&#x2F;添加事件</span><br><span class="line">function addEvent(element, type, fn)&#123;</span><br><span class="line">    &#x2F;&#x2F;能力检测</span><br><span class="line">    if(element.addEventListener)&#123;</span><br><span class="line">        element.addEventListener(type, fn, false);</span><br><span class="line">    &#125;else if(element.attachEvent)&#123;</span><br><span class="line">        element.attachEvent(&quot;on&quot;+type, fn);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果都不行，那就用on方式</span><br><span class="line">        element[&quot;on&quot;+type] &#x3D; fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除事件</span><br><span class="line">function removeEvent(element, type, fn) &#123;</span><br><span class="line">    if(element.removeEventListener)&#123;</span><br><span class="line">        element.removeEventListener(type, fn, false);</span><br><span class="line">    &#125;else if(element.detachEvent)&#123;</span><br><span class="line">        element.detachEvent(&quot;on&quot;+type, fn);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        element[&quot;on&quot;+type] &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-事件流"><a href="#7-事件流" class="headerlink" title="7.事件流"></a>7.事件流</h3><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><blockquote><p>当一个元素的事件被触发时,同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为冒泡</p><p>说白了就是：当我们触发了子元素的某个事件后，父元素对应的事件也会触发。</p><p>注意这里传递的仅仅是事件 并不传递所绑定的事件函数。所以如果父级没有绑定事件函数，就算传递了事件 也不会有什么表现 但事件确实传递了。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div2&quot;</span>);</span><br><span class="line">   div2.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>);&#125;;</span><br><span class="line">   div1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">2</span>);&#125;;<span class="comment">//父亲</span></span><br><span class="line"><span class="comment">//html代码</span></span><br><span class="line"> &lt;div id=<span class="string">&quot;div1&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=<span class="string">&quot;div2&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>代码很简单，就是两个父子关系的div,然后分别加了点击事件，当我们在div2里面点击的时候，会发现弹出了一次1，接着又弹出了2，这说明点击的时候，不仅div2的事件被触发了，它的父级的点击事件也触发了，这种现象就叫做冒泡。点击了div1,自己父级的点击事件也会被触发。</p><p><strong>取消冒泡有两种方式</strong>：</p><ul><li><p>标准的W3C 方式：e.stopPropagation();这里的stopPropagation是标准的事件对象的一个方法，调用即可</p></li><li><p>非标准的IE方式:ev.cancelBubble=true; 这里的cancelBubble是 IE事件对象的属性，设为true就可以了</p></li></ul><p>封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果提供了事件对象，则这是一个非IE浏览器</span></span><br><span class="line">   <span class="keyword">if</span> ( e &amp;&amp; e.stopPropagation )</span><br><span class="line">      <span class="comment">//因此它支持W3C的stopPropagation()方法</span></span><br><span class="line">      e.stopPropagation();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="comment">//否则，我们需要使用IE的方式来取消事件冒泡</span></span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件委托（代理）"><a href="#事件委托（代理）" class="headerlink" title="事件委托（代理）"></a>事件委托（代理）</h4><ul><li>代码简洁</li><li>减少浏览器的内存占用</li><li>说明：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。</li><li>原理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给<strong>最外面的div加点击事件</strong>，那么里面的ul，li，a做点击事件的时候，都会<strong>冒泡到最外层的div上</strong>，所以都会<strong>触发</strong>，这就是事件委托，委托它们父级代为执行事件。</li><li>作用：为子节点实现相同的功能，这样有利减少浏览器的内存占用</li><li>普通方法实现点击li 弹出123 例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;111&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    var oUl &#x3D; document.getElementById(&quot;ul1&quot;);</span><br><span class="line">    var aLi &#x3D; oUl.getElementsByTagName(&#39;li&#39;);</span><br><span class="line">    for(var i&#x3D;0;i&lt;aLi.length;i++)&#123;</span><br><span class="line">        aLi[i].onclick &#x3D; function()&#123;</span><br><span class="line">            alert(123);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的方法，减少dom操作</p></blockquote><ul><li>用事件委托的方式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ul1&quot;</span>);</span><br><span class="line">   oUl.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，<strong>那么问题就来了</strong>，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：</p><p>Event对象提供了一个属性叫<strong>target</strong>，可以返回事件的目标节点，我们成为<strong>事件源</strong>，也就是说，target就可以表示为当前的事件操作的dom，但是<strong>不是真正操作dom</strong>，当然，这个是有兼容性的，标准浏览器用<strong>ev.target</strong>，IE浏览器用<strong>event.srcElement</strong>，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用<strong>nodeName</strong>来获取具体是什么标签名，这个<strong>返回的是一个大写的，我们需要转成小写再做比较</strong>（习惯问题）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ul1&quot;</span>);</span><br><span class="line">　　oUl.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">　　　　<span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">　　　　<span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line">　 　　　　　　 alert(<span class="number">123</span>);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> Add = <span class="built_in">document</span>.getElementById(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> Remove = <span class="built_in">document</span>.getElementById(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> Move = <span class="built_in">document</span>.getElementById(<span class="string">&quot;move&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> Select = <span class="built_in">document</span>.getElementById(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            Add.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;添加&#x27;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            Remove.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;删除&#x27;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            Move.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;移动&#x27;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            Select.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;选择&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>使用事件代理，只要操作一次dom就能完成所有的效果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> oBox = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">            oBox.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">                <span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">                <span class="keyword">if</span>(target.nodeName.toLocaleLowerCase() == <span class="string">&#x27;input&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">switch</span>(target.id)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span> :</span><br><span class="line">                            alert(<span class="string">&#x27;添加&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;remove&#x27;</span> :</span><br><span class="line">                            alert(<span class="string">&#x27;删除&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;move&#x27;</span> :</span><br><span class="line">                            alert(<span class="string">&#x27;移动&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;select&#x27;</span> :</span><br><span class="line">                            alert(<span class="string">&#x27;选择&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul><li><strong>onkeydown</strong> : 当用户 按下键盘上按键 时会触发<code>onkeydown</code>事件.</li><li><strong>onkeyup</strong> : 在当前元素上 释放键盘按键 时会触发<code>onkeyup事件.</code></li><li>onkeypress : 键盘按下时触发</li></ul><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul><li>onclick:单击事件</li><li>ondblclick：双击事件</li><li>onmouseover：鼠标经过事件</li><li>onmouseout：鼠标离开事件</li><li>onmousemove：鼠标移动事</li><li>onfocus：获得焦点事件</li><li>onblur：失去焦点事件</li><li>onmousedown:鼠标按下事件</li><li>onmouseup:鼠标弹起事件</li></ul><h3 id="拖拽事件"><a href="#拖拽事件" class="headerlink" title="拖拽事件"></a>拖拽事件</h3><p>在HTML5的规范中，我们可以通过为元素增加draggable=”true”来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启的。</p><h4 id="1-拖拽元素"><a href="#1-拖拽元素" class="headerlink" title="1.拖拽元素"></a>1.拖拽元素</h4><p>​ 页面中设置了draggable=”true”属性的元素</p><h4 id="2-目标元素"><a href="#2-目标元素" class="headerlink" title="2.目标元素"></a>2.目标元素</h4><p>​ 页面中任何一个元素都可以成为目标元素</p><h4 id="3-事件监听"><a href="#3-事件监听" class="headerlink" title="3.事件监听"></a>3.事件监听</h4><p><strong>拖拽元素</strong></p><p>​ ondrag 应用于拖拽元素，整个拖拽过程都会调用</p><p>​ ondragstart 应用于拖拽元素，当拖拽开始时调用</p><p>​ ondragleave 应用于拖拽元素，当鼠标离开拖拽元素时调用</p><p>​ ondragend 应用于拖拽元素，当拖拽结束时调用</p><p><strong>目标元素</strong></p><p>​ ondragenter 应用于目标元素，当拖拽元素进入时调用</p><p>​ ondragover 应用于目标元素，当停留在目标元素上时调用</p><p>​ ondrop 应用于目标元素，当在目标元素上松开鼠标时调用</p><p>​ ondragleave 应用于目标元素，当鼠标离开目标元素时调用</p><h4 id="放到何处-ondragover"><a href="#放到何处-ondragover" class="headerlink" title="放到何处 - ondragover"></a>放到何处 - ondragover</h4><p>​ ondragover 事件规定在何处放置被拖动的数据。</p><p>​ 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</p><p>​ 这要通过调用 ondragover 事件的 <strong>event</strong>.preventDefault() 方法</p><h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><h3 id="1-非表单元素的属性"><a href="#1-非表单元素的属性" class="headerlink" title="1.非表单元素的属性"></a>1.非表单元素的属性</h3><blockquote><p>通过DOM设置普通标签属性，两边都会变化。常见的属性有：src、title、href、className、id等</p></blockquote><ul><li>innerHTML和innerText</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">box.innerHTML = <span class="string">&#x27;我是文本&lt;p&gt;我会生成为标签&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(box.innerHTML);</span><br><span class="line">box.innerText = <span class="string">&#x27;我是文本&lt;p&gt;我不会生成为标签&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(box.innerText);</span><br></pre></td></tr></table></figure><ul><li>HTML转义符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;		&quot;</span><br><span class="line">‘		&amp;apos;</span><br><span class="line">&amp;		&amp;</span><br><span class="line">&lt;		&lt;    &#x2F;&#x2F;less than  小于</span><br><span class="line">&gt;		&gt;   &#x2F;&#x2F; greater than  大于</span><br><span class="line">空格	   &amp;nbsp;</span><br><span class="line">©		&amp;copy;</span><br></pre></td></tr></table></figure><h3 id="2-表单元素属性"><a href="#2-表单元素属性" class="headerlink" title="2.表单元素属性"></a>2.表单元素属性</h3><blockquote><p>常见的表单属性有：disabled、type、value、checked、selected</p></blockquote><p>对于disabled、checked、selected三个属性来说，比较特殊。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">disabled : 禁用</span><br><span class="line">- <span class="literal">true</span> : 禁用</span><br><span class="line">- <span class="literal">false</span> : 不禁用</span><br><span class="line">checked : 多选框和单选框选中</span><br><span class="line">- <span class="literal">true</span> : 选中</span><br><span class="line">- <span class="literal">false</span> : 不选中</span><br><span class="line">selected : 菜单下拉框选中</span><br><span class="line">- <span class="literal">true</span> : 选中</span><br><span class="line">- <span class="literal">false</span> : 不选中</span><br><span class="line">在DOM对象中，他们的赋值.只要有值,很多都可以起到效果,但是为了统一规范, 我们使用 <span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-标签的自定义属性"><a href="#3-标签的自定义属性" class="headerlink" title="3.标签的自定义属性"></a>3.标签的自定义属性</h3><p>在html页面中，定义一个自定义属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">aa</span>=<span class="string">&quot;bb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 给div标签中 添加不存在的未知属性aa, 这就是自定义属性</span><br></pre></td></tr></table></figure><p><code>attribute</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置标签的属性</span></span><br><span class="line">box.setAttribute(name, value);</span><br><span class="line"><span class="comment">//获取标签的属性</span></span><br><span class="line">box.getAttribute(name);</span><br><span class="line"><span class="comment">//移除标签的属性</span></span><br><span class="line">box.removeAttribute(name);</span><br></pre></td></tr></table></figure><ul><li>与element.属性的区别: 上述三个方法用于获取任意的行内属性。</li><li>自定义属性，不能通过Dom对象的获取元素的方法，进行有关操作。</li><li>总结</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1. 直接给标签里添加固有的属性 title 等 标签+对象里都有显示</span></span><br><span class="line"> <span class="comment">// 2. 给标签添加自定义属性  =&gt; 标签上显示  +  对象点属性名里找不到</span></span><br><span class="line"> <span class="comment">// 3. 给对象添加自定义属性  =&gt; 标签里不显示  + 对象点属性名里可以找到                    【掌握】</span></span><br><span class="line"> <span class="comment">//    自定义:  box.aa = bb;  只能给对象里添加,, 标签内是没有的</span></span><br><span class="line"> <span class="comment">//    获取使用 : box.aa</span></span><br><span class="line"> <span class="comment">// 3. 自定义 : setAttribute 设置, 添加给标签内了获取使用 getAttribute       【掌握】</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;box&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        box.setAttribute(<span class="string">&#x27;title&#x27;</span>, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">        box.setAttribute(<span class="string">&#x27;aa&#x27;</span>, <span class="string">&quot;bb&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(box.title)  <span class="comment">// test</span></span><br><span class="line">        <span class="built_in">console</span>.log(box.aa)  <span class="comment">// undefined</span></span><br><span class="line">        box.ff = <span class="string">&#x27;Eval&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(box.ff) <span class="comment">//Eval</span></span><br></pre></td></tr></table></figure><h3 id="4-标签的内容属性innerText-和-innerHTML"><a href="#4-标签的内容属性innerText-和-innerHTML" class="headerlink" title="4.标签的内容属性innerText 和 innerHTML"></a>4.标签的内容属性innerText 和 innerHTML</h3><blockquote><p>共同点 : 都是用来获取和设置标签的内容的</p><p>区别 : innerHTML可以用于获取和设置标签的所有内容，包括标签和文本内容</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//innerHTML:内部的HTML</span></span><br><span class="line"><span class="comment">//  获取标签内容的时候，不管标签还是文本，都能获取到</span></span><br><span class="line"><span class="comment">//  innerHTML设置内容的时候，覆盖原来内容，标签也能生效，浏览器能解析这个标签。</span></span><br></pre></td></tr></table></figure><blockquote><p>innerText可以用于获取和设置标签的文本内容，会丢弃掉标签</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//innerText:内部 文本</span></span><br><span class="line"><span class="comment">//  获取标签内容的时候，只会获取文本，标签扔掉了</span></span><br><span class="line"><span class="comment">//  设置标签内容的时候，覆盖原来内容，对标签进行转义（目的：把标签直接当文本来用）</span></span><br></pre></td></tr></table></figure><p>二者的区别：</p><ul><li>innerHTML能够识别标签，标签能够生效</li><li>innerText只识别文本，标签会被转义。</li></ul><blockquote><p>浏览器兼容性：指网页在各种浏览器上的显示效果不一致。或者是一些属性和方法在低版本的浏览器中不支持。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. innerText是IE提出来的属性，因此低版本的火狐浏览器不支持这个属性。</span><br><span class="line"></span><br><span class="line">2. 火狐有一个textContent属性，效果跟innerText一样，谷歌支持但是IE678不支持这个属性</span><br></pre></td></tr></table></figure><p>书写innerText的兼容性代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> element.innerText === <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> element.innerText;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element.textContent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在浏览器中如果某个属性不支持该浏览器，那么这个属性的类型是undefined.</p></blockquote><h3 id="5-类名操作"><a href="#5-类名操作" class="headerlink" title="5.类名操作"></a>5.类名操作</h3><p>1、Node.classList.add(‘class’) 添加class</p><p>2、Node.classList.remove(‘class’) 移除class</p><p>3、Node.classList.toggle(‘class’) 切换class，有则移除，无则添加</p><p>4、Node.classList.contains(‘class’) 检测/判断是否存在class</p><p>Node指一个有效的DOM节点，是一个通称。</p><h3 id="6-H5自定义属性"><a href="#6-H5自定义属性" class="headerlink" title="6.H5自定义属性"></a>6.H5自定义属性</h3><p>在HTML5中我们可以自定义属性，其格式如下：<code>data-*=&quot;&quot;</code></p><ul><li><p>例如：data-info=”我是自定义属性”</p></li><li><p>通过Node.dataset[‘info’] 我们便可以获取到自定义的属性值。</p></li><li><p>Node.dataset是以类对象形式存在的</p></li><li><p>当我们如下格式设置时，则需要以驼峰格式才能正确获取</p><p>data-my-name=”itcast”，获取Node.dataset[‘myName’]</p></li></ul><h2 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h2><blockquote><p>标签不仅可以通过class属性操作样式 (嵌套样式)，还可以通过style属性操作样式 (行内样式)。</p><p>同样的DOM对象可以通过className操作样式 (嵌套样式)，也可以通过style属性操作样 (行内样式)。</p><p>css : 嵌套样式 =&gt; js : 类名 div.className = ‘red’;</p><p>css : 行内样式 =&gt; js : style对象 div.style.color = ‘red’;</p></blockquote><h3 id="body的样式操作"><a href="#body的样式操作" class="headerlink" title="body的样式操作"></a>body的样式操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">document</span>.body :body比较常用, 并且在页面中是唯一的, 因此可以使用<span class="built_in">document</span>.body直接获取   </span><br><span class="line"><span class="comment">// 可以通过qs获取,也可直接获取</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">document</span>.documentElement :  可以获取html元素</span><br><span class="line"><span class="number">3.</span> <span class="built_in">document</span>.head : 可以直接获取head元素</span><br><span class="line"><span class="number">4.</span> <span class="built_in">document</span>.title : 可以直接获取title的文本</span><br></pre></td></tr></table></figure><h3 id="关于cssText"><a href="#关于cssText" class="headerlink" title="关于cssText"></a>关于cssText</h3><blockquote><p>使用cssText可以设置style的属性值</p><p>可以省略</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width:100px;height:100px&quot;&gt;哈哈哈&lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D;  document.querySelector(&#39;div&#39;);</span><br><span class="line">div.style.cssText &#x3D; &#39;background:red;color:yellow&#39;;</span><br></pre></td></tr></table></figure><ul><li>优点：可以一次性设置多个值</li><li>缺点：会覆盖其他值 不利于阅读</li></ul><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="1-节点属性"><a href="#1-节点属性" class="headerlink" title="1.节点属性"></a>1.节点属性</h3><ol><li><p>节点：页面中的所有内容（标签、文本text、属性、注释comment）</p></li><li><p>节点的属性:</p></li></ol><ul><li>nodeType:节点的类型：1–标签 2—属性 3—文本 8—注释</li><li>nodeName：节点的名字：</li><li>nodeValue：节点的值：</li><li>childNodes：获取所有的子节点</li></ul><h3 id="2-节点查找"><a href="#2-节点查找" class="headerlink" title="2.节点查找"></a>2.节点查找</h3><ol><li>孩子节点</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//childNodes:获取所有的孩子节点（包括了元素节点和其他很多类型的节点，基本不常用）</span></span><br><span class="line">★ children --- 获取所有的子元素（用途很广泛），兼容性：IE678会把注释节点算上。 </span><br><span class="line"><span class="comment">// 第几个元素</span></span><br><span class="line">children[n] 第n个元素 </span><br><span class="line"></span><br><span class="line"><span class="comment">//firstChild //第一个子节点  (基本不常用)</span></span><br><span class="line">★ firstElementChild  --- 第一个子元素 有兼容性问题（IE678） </span><br><span class="line"></span><br><span class="line"><span class="comment">//lastChild //最后一个节点  (基本不常用)</span></span><br><span class="line">★ lastElementChild --- 最后一个子元素 有兼容性问题（IE678） </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>兄弟节点</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. nextSibling:下一个兄弟节点  (基本不常用)</span></span><br><span class="line">★ <span class="number">2.</span> nextElementSibling:下一个兄弟元素（IE678不兼容）</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. previousSibling//上一个兄弟节点  (基本不常用)</span></span><br><span class="line">★ <span class="number">4.</span> previousElementSibling <span class="comment">//上一个兄弟元素 有兼容性问题 可以封装一个兼容性方法 </span></span><br></pre></td></tr></table></figure><ol start="3"><li>父亲节点</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">★ <span class="number">1.</span> parentNode:父节点  <span class="comment">//没有兼容性问题</span></span><br></pre></td></tr></table></figure><h3 id="3-添加节点"><a href="#3-添加节点" class="headerlink" title="3.添加节点"></a>3.添加节点</h3><h4 id="appendChild-在子元素的最后添加一个新元素"><a href="#appendChild-在子元素的最后添加一个新元素" class="headerlink" title="appendChild 在子元素的最后添加一个新元素"></a>appendChild 在子元素的最后添加一个新元素</h4><p><strong>语法</strong>：parent.appendChild(newChild)</p><p><code>父元素.appendChild(子元素);</code><br><strong>parent</strong> : 调用者，父节点来调用</p><p><strong>newChild</strong> : 需要添加的那个孩子。</p><p><strong>作用</strong> ：把newChild添加到parent的孩子的 最后面。 (就相当于生孩子一样,最后的孩子,都是最小的最靠后的)</p><blockquote><p>注意 :: 如果添加的是页面中本来就存在的元素，是一个剪切的效果，原来的就不在了。</p></blockquote><h4 id="insertBefore-放在某个元素之前"><a href="#insertBefore-放在某个元素之前" class="headerlink" title="insertBefore : 放在某个元素之前"></a>insertBefore : 放在某个元素之前</h4><p><strong>语法</strong>：parent.insertBefore(newChild, refChild);</p><p><strong>parent</strong>:必须要父节点来调用</p><p><strong>newChild</strong>：需要添加的那个节点</p><p><strong>refChild</strong>:添加到哪一个节点的前面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1. 拼接到最后  (常用)</span></span><br><span class="line">div.appendChild(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加到s1之前 s2 s3之前  (常用)</span></span><br><span class="line">div.insertBefore(p,s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加到最后一个</span></span><br><span class="line">div.insertBefore(p,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 拓展 :非要添加在s2之后??</span></span><br><span class="line">div.insertBefore(p,s2.nextElementSibling);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 添加到父元素最前  (常用)</span></span><br><span class="line">div.insertBefore(p,div.children[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="4-克隆节点-重点"><a href="#4-克隆节点-重点" class="headerlink" title="4.克隆节点 (重点)"></a>4.克隆节点 (重点)</h3><p><strong>语法</strong>：var newNode = 节点.cloneNode(deep)</p><p><strong>功能</strong>：在内存中克隆一份节点</p><p><strong>参数</strong>：false / true</p><ul><li><p>false：默认值：是浅复制，只会复制标签，节点本身，不会复制节点的孩子。</p></li><li><p>true: 深度复制，会复制标签，还会复制标签的所有内容 常用</p></li></ul><blockquote><ol><li>克隆出来的节点跟原来的节点没有关系了，修改了也不会相互影响。</li><li>如果克隆的节点带了id，我们需要给id重新设置一个值，不让id冲突</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newNode = div.cloneNode(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// false : 浅复制  只复制该元素</span></span><br><span class="line"><span class="comment">// true : 深复制   不仅复制该元素 还复制其子元素</span></span><br><span class="line"><span class="built_in">console</span>.log(newNode);</span><br></pre></td></tr></table></figure><h3 id="5-创建节点"><a href="#5-创建节点" class="headerlink" title="5.创建节点"></a>5.创建节点</h3><h4 id="document-write"><a href="#document-write" class="headerlink" title="document.write()"></a>document.write()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;新设置的内容&lt;p&gt;标签也可以生成&lt;/p&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// 基本不用</span></span><br></pre></td></tr></table></figure><p>缺陷：如果在页面加载完毕后，创建的元素会覆盖之前所有内容，需要在页面加载完毕之前创建。</p><p>原理：页面从上往下加载的时候，会开启一个文档流，当页面加载完，文档流就会关闭。</p><p>document.write的本意就是在文档流上写入内容。如果页面没加载完成，文档流还是开着的，document.write直接在这个文档流上写东西</p><p>如果页面加载完成了，还是用document.write写东西，会重新开启一个新的文档流，往新的文档流上写东西，旧的文档流就被新的文档流覆盖了。</p><blockquote><p><code>百度新闻代码块，嵌入广告新闻块</code></p></blockquote><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><blockquote><p>innerHTML创建节点的时候有一个特点，如果原来有内容的话，使用innerHTML会把原先的内容给干掉。</p><p>慎用：很容易出现效率问题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">box.innerHTML = <span class="string">&#x27;新内容&lt;p&gt;新标签&lt;/p&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h4><ul><li>语法：<code>var div = document.createElement(&#39;div&#39;);</code></li><li>作用：在内存里面创建了一个节点</li><li>返回：一个元素</li></ul><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><ul><li>innerHTML方法由于会对字符串进行解析，需要避免在循环内多次使用。</li><li>可以借助字符串或数组的方式进行替换，再设置给innerHTML</li><li>优化后与document.createElement性能相近</li></ul><h3 id="其他节点操作"><a href="#其他节点操作" class="headerlink" title="其他节点操作"></a>其他节点操作</h3><ul><li>插入节点：<code>document.body.appendChild(div);</code> 插入到父节点中</li><li>删除节点：<code>parent.removeChild(child);</code> 由父盒子调用，删除里面的一个子元素。</li><li>替换节点：<code>parentNode.replaceChild(newChild, oldChild);</code><ul><li><code>newChild</code>用来替换 <code>oldChild</code>的新节点，如果<code>newChild</code>已经存在于DOM树中，则它会被从原始位置删除。</li></ul></li></ul><h2 id="三大家族"><a href="#三大家族" class="headerlink" title="三大家族"></a>三大家族</h2><h3 id="offset家族"><a href="#offset家族" class="headerlink" title="offset家族"></a>offset家族</h3><blockquote><p>offset系列用于用于获取元素自身的大小和位置 ，在网页特效中有广泛应用</p><p>offset家族主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop</p></blockquote><p><strong>offsetHeight与offsetWidth</strong></p><ol><li>获取的是元素真实的高度和宽度</li><li>获取到的是数值类型，方便计算</li><li>offsetHeight与offsetWidth是只读属性，不能设置。</li><li>内容大小+border+padding</li></ol><p><strong>offsetTop与offsetLeft</strong></p><ol><li>获取的是元素到距离自身最近的（带有定位的）父元素的 顶部或者左侧 的距离</li><li>获取到的是数值类型</li><li>只读</li></ol><p><strong>style.height与style.width</strong></p><ol><li>style.height是字符串（而且带单位），而且他只能获取行内样式 ； offsetHeight是数值（数字无单位）</li><li>demo.style.height可以设置行内样式，offsetHeight是只读属性</li></ol><p><strong>offsetParent</strong></p><ol><li>获取到当前元素外面的定位父盒子 HTMLElement.offsetParent 是一个只读属性</li><li>返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。</li><li>如果没有定位的元素，则 offsetParent 为最近的 table, table cell 或根元素</li><li>当元素的 style.display 设置为 “none” 时，offsetParent 返回 null。</li></ol><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200702194328105.png" alt="image-20200702194328105"></p><h3 id="scroll家族"><a href="#scroll家族" class="headerlink" title="scroll家族"></a>scroll家族</h3><blockquote><p>scroll家族是用来获取盒子内容的大小和位置</p><p>scroll 家族主要有 : scrollWidth、scrollHeight、scrollLeft、scrollTop</p></blockquote><p><strong>scrollWidth与scrollHeight</strong></p><ul><li><p>scrollWidth与scrollHeight是盒子内容的真实的宽度和高度。与和盒子大小无关，仅仅与盒子的内容有关系。 (padding + 内容)</p></li><li><p>如果内容不超过盒子,盒子高度就是 scrollHeight ,(宽度同理)</p></li><li><p>如果内容超过盒子, 内容高度 就是scrollHieght</p></li></ul><p><strong>scrollTop 被浏览器卷去的高度</strong></p><ol><li>scrollTop用于获取内容垂直滚动的像素数。如果没有滚动条，那么scrollTop值是0</li><li>给内容超过盒子, 盒子设置 overflow:scroll 就可出现滚动条</li></ol><p><strong>scrollLeft</strong></p><ol><li>scrollLeft用于获取内容水平滚动的像素数</li><li>演示可以使用内容只是纯字母的</li><li>浏览器切忌这种出现水平滚动条,用户体验极差,避免</li></ol><p><strong>onscroll 事件</strong></p><p>对于有滚动条的盒子, 可以使用onscroll注册滚动事件,,每滚动一像素,就会触发该事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = doucment.getElementById(“div”);</span><br><span class="line">div.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(div.scrollLeft);</span><br><span class="line">    <span class="built_in">console</span>.log(div.scrollTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景 : 获取页面被卷去的高度和宽度</strong></p><p>通常来说，scroll家族用的最多的地方就是用来获取页面被卷去的高度，非常的常用</p><ul><li><p>对于老式的浏览器，需要获取html或者body的scrollTop</p></li><li><p>对于现在浏览器，使用window.pageYOffset进行获取</p></li></ul><p>页面被卷去的高度和宽度的兼容性封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给整个页面注册滚动事件</span></span><br><span class="line"><span class="built_in">document</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop || <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">var</span> scrollLeft = <span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200702200442330.png" alt="image-20200702200442330"></p><h3 id="client家族"><a href="#client家族" class="headerlink" title="client家族"></a>client家族</h3><blockquote><p>client家族用于获取盒子可视区的大小</p><p>client家族有clientWidth、clientHeight、clientLeft、clientTop</p></blockquote><p>clientWidth、clientHeight 可视区宽高</p><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200702200525000.png" alt="image-20200702200525000"></p><p><strong>场景 : client系列一般用来获取页面的可视区宽高</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为求的是窗口大小所以用window</span></span><br><span class="line"><span class="built_in">window</span>.onresize =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> W = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">    <span class="built_in">console</span>.log(W);</span><br><span class="line">    <span class="keyword">var</span> H = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    <span class="built_in">console</span>.log(H);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>offset家族 : 真实宽高和位置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> width : 内容 + border + padding;</span><br><span class="line"><span class="number">2.</span> offsetWidth : 真实宽度</span><br><span class="line"><span class="number">3.</span> offsetHeight :真实高度</span><br><span class="line"><span class="number">4.</span> offsetLeft : 真实左侧距离</span><br><span class="line"><span class="number">5.</span> offsetTop : 真实顶部距离</span><br><span class="line">使用 : </span><br><span class="line">   <span class="number">1.</span> 获取 offset系列</span><br><span class="line">   <span class="number">2.</span> 设置 style系列</span><br></pre></td></tr></table></figure><p><strong>scroll家族 : 内容大小</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> scrollTop : 被页面卷去的高度</span><br><span class="line"><span class="number">2.</span> div.onscroll : 给div注册滚动事件 (前提是有滚动条)</span><br><span class="line"><span class="number">3.</span> <span class="built_in">window</span>.onscroll : 给整个页面注册滚动事件</span><br><span class="line"><span class="number">4.</span> 获取 被页面卷去的高度</span><br><span class="line">  top:<span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">  left:<span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="number">0</span></span><br><span class="line"><span class="number">5.</span> 重点掌握 : pageYOffset </span><br></pre></td></tr></table></figure><p><strong>client 家族 可视区域大小</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">window</span>.onresize   onresize事件会在窗口被调整大小的时候发生。</span><br><span class="line"><span class="number">2.</span> 可视区域大小 : <span class="built_in">window</span>.innerWidth</span><br></pre></td></tr></table></figure><h2 id="音频API"><a href="#音频API" class="headerlink" title="音频API"></a>音频API</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WEB音频API测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;即将播放音频！&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//创建音乐播放的上下文实例,适配手机和PC</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> audioContext = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext||<span class="built_in">window</span>.webkitAudioContext)();</span></span><br><span class="line"><span class="javascript">            <span class="comment">//为即将到来的音频文件创建一个缓冲区</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> source = audioContext.createBufferSource();</span></span><br><span class="line"><span class="javascript">            <span class="comment">//创建Ajax请求对象，用于向服务器请求音频资源</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 使用非异步请求方式，来请求音频资源</span></span></span><br><span class="line"><span class="javascript">            request.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;./TheMountain.mp3&#x27;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 设置服务器即将返回的类型，便于浏览器解码</span></span></span><br><span class="line"><span class="javascript">            request.responseType = <span class="string">&#x27;arraybuffer&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//一旦请求内容完整返回就开始解码</span></span></span><br><span class="line"><span class="javascript">                audioContext.decodeAudioData(request.response,<span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>)</span>&#123;</span></span><br><span class="line">                    source.buffer = buffer;</span><br><span class="line"><span class="javascript">                    <span class="comment">//连接音频资源，正式播放</span></span></span><br><span class="line">                    source.connect(audioContext.destination);</span><br><span class="line"><span class="javascript">                    <span class="comment">//设置为循环播放模式</span></span></span><br><span class="line"><span class="javascript">                    source.loop = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 等待零秒后播放</span></span></span><br><span class="line">                    source.start(0);</span><br><span class="line"><span class="javascript">                &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&#x27;Audio Error!&#x27;</span>,e);</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">// 开启ajax请求</span></span></span><br><span class="line">            request.send();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">//window.onload = function()&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//  play();</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//&#125;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;play()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;播放&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="地理定位API"><a href="#地理定位API" class="headerlink" title="地理定位API"></a>地理定位API</h2><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="1-变量的解构赋值"><a href="#1-变量的解构赋值" class="headerlink" title="1.变量的解构赋值"></a>1.变量的解构赋值</h3><ol><li>定义：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><ol start="2"><li>默认值：解构赋值允许指定默认值,当一个数组成员严格等于<code>undefined</code>，默认值才会生效。同时默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// 默认值变量之间的引用</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><h3 id="2-对象的结构赋值"><a href="#2-对象的结构赋值" class="headerlink" title="2.对象的结构赋值"></a>2.对象的结构赋值</h3><ol><li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ol start="2"><li>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line">log(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>与数组一样，解构也可以用于嵌套结构的对象。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>对象的解构赋值可以取到继承的属性。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>对象的解构也可以指定默认值。</li></ol><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h3 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3.字符串的解构赋值"></a>3.字符串的解构赋值</h3><ol><li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-数值和布尔值的解构赋值"><a href="#4-数值和布尔值的解构赋值" class="headerlink" title="4.数值和布尔值的解构赋值"></a>4.数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p></blockquote><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="comment">// 使用默认值，在解构赋值错误的时候，有效救场</span></span><br></pre></td></tr></table></figure><h3 id="6-解构赋值圆括号问题"><a href="#6-解构赋值圆括号问题" class="headerlink" title="6.解构赋值圆括号问题"></a>6.解构赋值圆括号问题</h3><ol><li><p>不能使用圆括号的情况</p><ul><li>变量声明语句</li><li>函数参数</li><li>赋值语句的模式</li></ul></li><li><p>可以使用圆括号的情况</p><ul><li>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><blockquote><p>第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p></blockquote></li></ol><h2 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ol><li>定义：set是一种新的数据结构，成员的值是唯一的，没有重复的值。（本身是构造函数）</li><li><code>add()</code>方法向set结构添加成员，同样也不能添加重复的值。</li><li><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</li><li>两个对象总是不相等的</li><li>可以用来数组去重<code>Array.from(new Set(array));</code></li></ol><h4 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h4><ol><li><p>属性</p><ul><li>Set.prototype.constructor：构造函数，默认就是Set函数</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数</li></ul></li><li><p>方法</p><ul><li>add(value)：添加某个值，返回 Set 结构本身。</li><li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li><li>clear()：清除所有成员，没有返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><code>Array.from</code>方法可以将 Set 结构转为数组。</li></ul></li></ol><h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><ol><li><code>keys()</code>，<code>values()</code>，<code>entries()</code>Set 结构没有键名，只有键值，所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>forEach()</code></li><li>扩展运算符(…)</li><li>map,filter方法</li><li>可以实现并集（Union）、交集（Intersect）和差集（Difference）。</li></ol><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="含义及用法"><a href="#含义及用法" class="headerlink" title="含义及用法"></a>含义及用法</h4><ol><li>定义：Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>它属于”键值对“的数据结构，而且属于构造函数</li><li>Map函数的参数：数组、具有Iterator接口、参数成员是一个双元素的数组的数据结构。（Set，Map都可以）</li></ol><h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><ol><li><code>size</code>属性返回 Map 结构的成员总数。</li><li><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后<strong>返回整个 Map 结构</strong>。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。可采用链式写法</li><li><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li><li><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li><li><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li><li><code>clear</code>方法清除所有成员，没有返回值。</li></ol><h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><ol><li><p>Map 的遍历顺序就是<strong>插入顺序</strong>。它的结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li>keys() 返回键名</li><li>values() 返回键值</li><li>entries() 返回所有成员</li><li>forEach() 遍历所有成员</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forEach方法还可以接受第二个参数，用来绑定this。forEach方法的回调函数的this，就指向reporter。</span></span><br><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  report: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure></li></ol><h4 id="与其他数据结构的转化"><a href="#与其他数据结构的转化" class="headerlink" title="与其他数据结构的转化"></a>与其他数据结构的转化</h4><ol><li>Map结构转换为数组，扩展运算符（<code>...</code>）</li><li>数组转化为Map：将数组作为参数传入Map函数</li><li>Map结构转化为对象：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>对象转化为Map：使用<code>Object.entries()</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure><ol start="5"><li>Map转化为JSON,Map 转为 JSON 要区分两种情况。<ul><li>一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</li><li>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</li></ul></li><li>JSON 转为 Map，<ol><li>正常情况下，所有键名都是字符串。</li><li>特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</li></ol></li></ol><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul><li>定义：Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</li><li>作用：在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</li><li>语法：<code>var proxy = new Proxy(target, handler);</code><ul><li><code>target</code>参数表示所要拦截的目标对象</li><li><code>handler</code>参数也是一个对象，用来定制拦截行为,一个拦截函数。</li></ul></li><li>方法：<ul><li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li><li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ul></li></ul><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。</li><li>装饰器是一种函数，写成<code>@ + 函数名</code>。它可以放在类和类方法的定义前面。</li></ul><h4 id="类的装饰器"><a href="#类的装饰器" class="headerlink" title="类的装饰器"></a>类的装饰器</h4><ul><li>装饰器是一个对类进行处理的函数，装饰器函数的第一个参数，就是所要装饰的目标类。</li><li>装饰器的行为：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><ul><li>装饰器本质就是编译时执行的函数</li><li>如果想添加实例属性，可以通过目标类的prototype对象操作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyTestableClass();</span><br><span class="line">obj.isTestable <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><p>实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法的装饰"><a href="#方法的装饰" class="headerlink" title="方法的装饰"></a>方法的装饰</h4><ul><li>装饰器不仅可以装饰类，还可以装饰类的属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>装饰器函数可以接受三个参数。<ul><li>第一个参数是类的原型对象</li><li>第二个参数是所要装饰的属性名</li><li>第三个参数是该属性的描述对象。</li></ul></li><li>装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改属性描述对象的enumerable属性，使得该属性不可遍历。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @nonenumerable</span><br><span class="line">  <span class="keyword">get</span> <span class="title">kidCount</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.children.length; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>装饰器有注释的作用。</li><li>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;evaluated&#x27;</span>, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;executed&#x27;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    @dec(<span class="number">1</span>)</span><br><span class="line">    @dec(<span class="number">2</span>)</span><br><span class="line">    method()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure><h4 id="为什么装饰器不能用于函数"><a href="#为什么装饰器不能用于函数" class="headerlink" title="为什么装饰器不能用于函数"></a>为什么装饰器不能用于函数</h4><p>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升，而类不存在提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly = <span class="built_in">require</span>(<span class="string">&quot;some-decorator&quot;</span>);</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也有问题，因为实际执行是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly;</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readOnly = <span class="built_in">require</span>(<span class="string">&quot;some-decorator&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果一定要装饰函数，可以采用高阶函数的形式直接执行。</p><h4 id="core-decorators-js"><a href="#core-decorators-js" class="headerlink" title="core-decorators.js"></a>core-decorators.js</h4><p><a target="_blank" rel="noopener" href="https://github.com/jayphelps/core-decorators.js">core-decorators.js</a>是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器</p><ul><li>@autobind装饰器使得方法中的this对象，绑定原始对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; autobind &#125; <span class="keyword">from</span> <span class="string">&#x27;core-decorators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @autobind</span><br><span class="line">  getPerson() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> getPerson = person.getPerson;</span><br><span class="line"></span><br><span class="line">getPerson() === person;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>@readonly装饰器使得属性或方法不可写。</li><li>@override装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</li><li><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除。</li></ul><h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h4><p>在装饰器的基础上，可以实现<code>Mixin</code>模式。所谓<code>Mixin</code>模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。</p><p><code>mixins.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上面这个装饰器，为类“混入”各种方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">&#x27;./mixins&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo() <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="comment">//通过mixins这个装饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：上面的方法会改写<code>MyClass</code>类的<code>prototype</code>对象</p></blockquote><h2 id="Iterator（遍历器）"><a href="#Iterator（遍历器）" class="headerlink" title="Iterator（遍历器）"></a>Iterator（遍历器）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li><p>前言：JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p></li><li><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作</p></li><li><p>作用：</p><ul><li>一是为各种数据结构，提供统一的、简便的访问接口；</li><li>二是使得数据结构的成员能够按某种次序排列；</li><li>三是ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。</li></ul></li><li><p>Iterator 的遍历过程</p><ol><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li></ol><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟</span></span><br><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。</p></li></ol><h3 id="默认Iterator接口"><a href="#默认Iterator接口" class="headerlink" title="默认Iterator接口"></a>默认Iterator接口</h3><p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）</p><ul><li><code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: <span class="number">1</span>,</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>原生具备 Iterator 接口的数据结构如下。<ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul></li><li>对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，<code>Symbol.iterator</code>方法直接引用数组的 Iterator 接口。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = [][<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)] <span class="comment">// 可以执行了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似数组的对象</span></span><br><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</li></ul><h3 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h3><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p><ol><li>解构赋值：对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</li><li><strong>扩展运算符</strong>：扩展运算符（…）也会调用默认的 Iterator 接口。 也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</li><li><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口</li><li>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。<ul><li>for…of</li><li>Array.from() //可以将可遍历的数据结构，转化为数组</li><li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li><li>Promise.all()</li><li>Promise.race()</li></ul></li></ol><h3 id="字符串的Iterator接口"><a href="#字符串的Iterator接口" class="headerlink" title="字符串的Iterator接口"></a>字符串的Iterator接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line"><span class="comment">// &quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: &quot;h&quot;, done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: &quot;i&quot;, done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h3 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h3><p>遍历器对象除了具有<code>next</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。如果你自己写遍历器对象生成函数，那么<code>next</code>方法是必须部署的，<code>return</code>方法和<code>throw</code>方法是否部署是可选的。</p><ul><li><code>return</code>方法的使用场合是：<ul><li>如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return</code>方法。</li><li>如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return</code>方法。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面代码中，情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；情况二会在执行return方法关闭文件之后，再抛出错误。</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>return</code>方法必须返回一个对象，这是 Generator 规格决定的。</p></blockquote><ul><li><code>throw</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。</li></ul><h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p><ul><li><p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、Generator 对象，以及字符串。</p></li><li><p><code>for...in</code>和<code>for...of</code>的区别：</p><ul><li><code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。 for…of可以获取键值</li><li>通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法</li><li><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回<strong>具有数字索引的属性</strong></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p></blockquote><ul><li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.classList.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p><ul><li>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;: &#x27;</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另一个方法是使用 Generator 函数将对象重新包装一下。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, <span class="string">&#x27;-&gt;&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>理解</strong>：语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p><p><strong>过程</strong>：执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p><strong>特征：</strong>一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。</p><p><strong>运行Generator函数</strong>：<strong>首先</strong>，在函数名前加一对圆括号调用；调用后函数并不执行，返回的结果不是运行结果，而是一个指向内部转态的指针对象，即遍历器对象。<strong>下一步</strong>，必须调用遍历器对象的**<code>next</code>方法**，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next()</span><br></pre></td></tr></table></figure><h4 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h4><p>由于 Generator 函数返回的遍历器对象，<strong>只有调用<code>next</code>方法才会遍历下一个内部状态</strong>，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p><ul><li>运行逻辑：<ul><li>遇yield暂停执行之后操作，将yield之后表达式的值，作为返回值value</li><li>当再次调用next方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li><li><code>if</code>没有再遇到yield表达式，就一直运行到函数结束，直到遇到return语句</li><li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li></ul></li><li><code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。例如使用forEach遍历yield，forEach内部只是一个普通的函数。</li><li>yield表达式如果用在另一个表达式之中，必须<strong>放在圆括号里面</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>, <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="与Iterator接口的关系"><a href="#与Iterator接口的关系" class="headerlink" title="与Iterator接口的关系"></a>与Iterator接口的关系</h4><p>Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h4><ul><li><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，<strong>该参数就会被当作上一个<code>yield</code>表达式的返回值。</strong></li><li>next()方法正是通过在不同的阶段传递不同的参数，而调整函数的行为。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 第一个next,不需要传参，他的作用是启动遍历器</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line"><span class="comment">// 没有传递参数，默认yield返回值是undefined，即下一个yield中的y为undefined</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;  </span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line"><span class="comment">// 这里第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。</p></blockquote><h4 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h4><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...numbers()] <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = numbers();</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h4><ul><li>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.throw(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><blockquote><p>遍历器对象<code>i</code>连续抛出两个错误。第一个错误被 Generator 函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于 Generator 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的<code>catch</code>语句捕获。</p></blockquote><ul><li><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</li><li>不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。后者只能被函数体外的<code>catch</code>语句捕获。</li><li>如果 Generator 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</li><li><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法</li><li><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法。</li></ul><h4 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h4><p>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.next()        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><ul><li>如果<code>return</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</li></ul><h4 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h4><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p><ul><li><code>next()</code>是将<code>yield</code>表达式替换成一个值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = g(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.next(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，第二个<code>next(1)</code>方法就相当于将<code>yield</code>表达式替换成一个值<code>1</code>。如果<code>next</code>方法没有参数，就相当于替换成<code>undefined</code>。</p></blockquote><ul><li><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));</span></span><br></pre></td></tr></table></figure><ul><li><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.return(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure><h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h4><p><strong>问题</strong>：当在一个Generator函数内部，调用另外一个Generator函数，需要在前者的函数体内部，自己手动完成遍历。</p><p><strong>解决</strong>：<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> inner();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// outer1返回一个遍历器对象</span></span><br><span class="line"><span class="keyword">var</span> gen = outer1()</span><br><span class="line">gen.next().value <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.next().value <span class="comment">// 返回一个遍历器对象</span></span><br><span class="line">gen.next().value <span class="comment">// &quot;close&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span>* inner()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// outer2返回该遍历器对象的内部值。</span></span><br><span class="line"><span class="keyword">var</span> gen = outer2()</span><br><span class="line">gen.next().value <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.next().value <span class="comment">// &quot;hello!&quot;</span></span><br><span class="line">gen.next().value <span class="comment">// &quot;close&quot;</span></span><br></pre></td></tr></table></figure><p><strong>语法角度分析</strong>：如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。</p><p><strong>理解：</strong><code>yield*</code>的作用，类似于递归函数，重复自调用，对遍历器内的值，挨个输出，直到结束。也等同于在Geneartor函数内部部署了一个<code>for...of</code>循环，可以用它替换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>yield</code>与<code>yield*</code>的区别</strong>：</p><ul><li>任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</li><li>yield表达式返回的是整个数据结构。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">read.next().value <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">read.next().value <span class="comment">// &quot;h&quot;</span></span><br></pre></td></tr></table></figure><p><strong>yield作用</strong>：</p><ul><li>如果被代理的 Generator 函数有<code>return</code>语句，那么就可以向代理它的 Generator 函数返回数据。供Geneartor使用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genFuncWithReturn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;The result&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">logReturned</span>(<span class="params">genObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* genObj;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...logReturned(genFuncWithReturn())]</span><br><span class="line"><span class="comment">// The result</span></span><br><span class="line"><span class="comment">// 值为 [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><ul><li><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。(扩展运算符…也可以达到平铺的效果)</li><li>例子：遍历完全二叉树</li></ul><h4 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h4><p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整的</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Generator函数的this"><a href="#Generator函数的this" class="headerlink" title="Generator函数的this"></a>Generator函数的this</h4><p>问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line">obj.next();</span><br><span class="line">obj.a <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> f() <span class="comment">// TypeError: f is not a constructor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li>Generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。</li><li>Generator 函数也不能跟<code>new</code>命令一起用，会报错。</li></ol></blockquote><p>解决方案：将Generator函数的原型（g.prototype）通过<code>call()</code>绑定，可以对它执行<code>new</code>命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.a <span class="comment">// 1</span></span><br><span class="line">f.b <span class="comment">// 2</span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="Generator函数的异步应用"><a href="#Generator函数的异步应用" class="headerlink" title="Generator函数的异步应用"></a>Generator函数的异步应用</h2><h3 id="1-传统方法"><a href="#1-传统方法" class="headerlink" title="1.传统方法"></a>1.传统方法</h3><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promise 对象</li></ul><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><h4 id="异步-1"><a href="#异步-1" class="headerlink" title="异步"></a>异步</h4><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是”重新调用”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件进行处理，是这样写的。</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;/etc/passwd&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h4><p>使用回调函数，执行多重嵌套的操作，就会形成回调地狱，未解决这种问题，引入了Promise这种新的写法，允许将回调函数的嵌套，改成链式调用。</p><p>Promise 提供<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p><h4 id="Generator函数-1"><a href="#Generator函数-1" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。</p><p><strong>异步任务的封装</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便</p></blockquote><h4 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h4><p>Thunk函数是自动执行Generator函数的一种方法。</p><p>含义：编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p><p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，<strong>而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure><blockquote><p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。</p></blockquote><h4 id="Thunkify模块"><a href="#Thunkify模块" class="headerlink" title="Thunkify模块"></a>Thunkify模块</h4><p>生产环境的转换器，建议使用 Thunkify 模块。</p><p>安装 ：<code>npm install thunkify</code></p><p>使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);   <span class="comment">//只允许回调函数执行一次</span></span><br><span class="line">read(<span class="string">&#x27;package.json&#x27;</span>)(<span class="function"><span class="keyword">function</span>(<span class="params">err, str</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Generator函数的流程管理"><a href="#Generator函数的流程管理" class="headerlink" title="Generator函数的流程管理"></a>Generator函数的流程管理</h4><p>Generator在执行异步的操作时，yield命令用于将程序的执行权移出Generator函数，使用Thunk函数，在回调函数里面将执行权交还给Generator函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFileThunk(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFileThunk(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gen = fn();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><h4 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h4><p>co 模块可以让你不用编写 Generator 函数的执行器。</p><p>安装：<code>npm install co</code></p><p>co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line">co(gen);    </span><br><span class="line"><span class="comment">// 返回Promise对象，用then添加回调函数</span></span><br><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Generator 函数执行完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>co支持并发的异步操作，允许某些操作同时进行。等到它们全部完成，才进行下一步。</p><ul><li>要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">  ];</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure><h4 id="基于-Promise-对象的自动执行"><a href="#基于-Promise-对象的自动执行" class="headerlink" title="基于 Promise 对象的自动执行"></a>基于 Promise 对象的自动执行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自动执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><h2 id="Class的基本语法"><a href="#Class的基本语法" class="headerlink" title="Class的基本语法"></a>Class的基本语法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>传统定义类的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pointfun</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pointfun.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Pointfun(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>ES6引入<code>class</code>，它可以看作是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><p>使用class对上面的类改写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="built_in">this</span>.x&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>类的数据类型就是函数，类本身就指向构造函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> Point   <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="comment">// Point.prototype.constructor的值就是Point这个类。</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><p>类的所有方法都定义在类的<code>prototype</code>属性上。</p><ul><li>在构造函数中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pointfun.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在class类中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为class的Point是一个构造函数，由此可见上面的代码成立。</p></blockquote></li><li><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>在ES6中class中定义的方法，是不可枚举的，而ES5的构造函数可以。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;toString&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h4><p><strong>定义</strong>：<code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p><ul><li><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</li><li>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，普通函数不用<code>new</code>也可以执行。</li></ul><h4 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h4><ul><li>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。</li><li>与 ES5 一样，类的所有实例共享一个原型对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.__proto__ === p2.__proto__</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>可以通过实例的<code>__proto__</code>属性为“类”添加方法。不建议在生产中使用该属性</li></ul><h4 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h4><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;   <span class="comment">// 对prop存值</span></span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop   <span class="comment">// 对prop的取值</span></span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。返回自定义的形式。</p></blockquote><ul><li>存值函数和取值函数是设置在属性的 Descriptor 对象上的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">html</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">html</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, <span class="string">&quot;html&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;get&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;set&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h4><p>类的属性名，可以采用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">&#x27;getArea&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h4><ul><li>与函数一样，类也可以使用表达式的形式定义</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>Me</code>，但是<code>Me</code>只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用<code>MyClass</code>引用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line">inst.getClassName() <span class="comment">// Me</span></span><br><span class="line">Me.name <span class="comment">// ReferenceError: Me is not defined</span></span><br></pre></td></tr></table></figure><ul><li>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li>采用 Class 表达式，可以写出立即执行的 Class。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><strong>严格模式</strong>:类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式</p><p><strong>不存在提升</strong>：类不存在变量提升（hoist），这一点与 ES5 完全不同。</p><p><strong>name 属性</strong>：本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line">Point.name <span class="comment">// &quot;Point&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Generator 方法</strong>：某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="built_in">this</span>.args) &#123;</span><br><span class="line">      <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Foo(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p><strong>this 的指向</strong>：</p><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><ul><li>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="built_in">this</span>.printName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另一种方法就是使用箭头函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.getThis = <span class="function">() =&gt;</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> Obj();</span><br><span class="line">myObj.getThis() === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li>定义：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><ul><li>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。即指向Foo,而不是foo</li><li>父类的静态方法，可以被子类继承。</li><li>静态方法也是可以从<code>super</code>对象上调用的。</li></ul><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p><p>定义方法：</p><ol><li>定义在class类的外面</li><li>新的提案方法，就是在实例属性的前面，加上<code>static</code>关键字。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h3><p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="built_in">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>好处:所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p></blockquote><h3 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h3><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p><p>实现方法：</p><ol><li>一种做法是在命名上加以区别</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    <span class="built_in">this</span>._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  _bar(baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(<span class="built_in">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。（写在class里面）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">&#x27;snaf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    <span class="built_in">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> myClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(myClass.prototype)</span><br><span class="line"><span class="comment">// [ &#x27;constructor&#x27;, &#x27;foo&#x27;, Symbol(bar) ]</span></span><br></pre></td></tr></table></figure><h3 id="私有属性提案"><a href="#私有属性提案" class="headerlink" title="私有属性提案"></a>私有属性提案</h3><p>目前，有一个<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-private-methods">提案</a>，为<code>class</code>加了私有属性。方法是在属性名之前，使用<code>#</code>表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  #count = 0;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    return this.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> IncreasingCounter();</span><br><span class="line">counter.#count // 报错</span><br><span class="line">counter.#count = 42 // 报错</span><br></pre></td></tr></table></figure><ul><li>这种写法不仅可以写私有属性，还可以用来写私有方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  #a;</span><br><span class="line">  #b;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    this.#a = a;</span><br><span class="line">    this.#b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  #sum() &#123;</span><br><span class="line">    return #a + #b;</span><br><span class="line">  &#125;</span><br><span class="line">  printSum() &#123;</span><br><span class="line">    console.log(this.#sum());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>私有属性也可以设置 getter 和 setter 方法。</li><li>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。<code>static #totallyRandomNumber = 4;</code></li></ul><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>这个属性可以用来确定构造函数是怎么调用的。</p><p>Class 内部调用<code>new.target</code>，返回当前 Class。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="built_in">this</span>.length = length;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><p>子类继承父类时，<code>new.target</code>会返回子类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, width);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><blockquote><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p></blockquote><h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>继承的实现：Class可以通过<code>extends</code>关键字实现继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承注意的几点：</p><ol><li><p>在继承的过程中，子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例会报错。</p></li><li><p>ES5与ES6的继承机制不同。</p><ul><li>ES5：先创造子类的实例对象this，然后将父类的方法，添加到this上面（Parent.apply(this)）。</li><li>ES6：先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</li></ul></li><li><p>不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p></li><li><p>在子类的构造函数中，<strong>只有</strong>调用<code>super</code>之后，<strong>才</strong>可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p></li><li><p>子类的实例对象同时也是父类的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(<span class="number">25</span>, <span class="number">8</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">cp <span class="keyword">instanceof</span> ColorPoint <span class="comment">// true</span></span><br><span class="line">父类</span><br><span class="line">cp <span class="keyword">instanceof</span> Point <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li>父类的静态方法，也会被子类继承。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> hello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.hello()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><ol start="7"><li>判断一个类是否继承了另一个类的方法<code>Object.getPrototypeOf(ColorPoint) === Point</code>true</li></ol><h3 id="super关键词"><a href="#super关键词" class="headerlink" title="super关键词"></a>super关键词</h3><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><ul><li><p>第一种情况：<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p><ul><li><code>super</code>只能用在子类的构造函数中</li><li><code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例</li><li><code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</li><li>在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name); <span class="comment">// 指向当前正在实行的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A   执行A类时，指向A类</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B   实行super()时，指向B类</span></span><br></pre></td></tr></table></figure></li><li><p>第二种情况：super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><ul><li>在普通方法中：<code>super</code>指向 父类<code>.prototype</code>，所以<code>super.方法或属性</code>相当于<code>父类.prototype.方法或属性</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的</p><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到<code>A.prototype.x = 2;</code></p></blockquote><ul><li><ul><li>在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>在子类中如果想通过<code>super</code>对某个属性赋值，这时的super就是子类的this。赋值的属性会变成子类实例的属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">super</span>.x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.x); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">// super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</span></span><br></pre></td></tr></table></figure><ul><li>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</li><li>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</li></ul></li><li><p>由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;MyObject: &quot;</span> + <span class="built_in">super</span>.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.toString(); <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure><h3 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 prototype 属性和__proto__属性</h3><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ol><li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li><li>子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</li></ol><blockquote><p>理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；</p><p>作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>extends</code>关键字后面可以跟多种类型的值。</p><ul><li>子类继承<code>Object</code>类。</li></ul></li><li><p>实例<code>__proto__</code>属性</p><ul><li>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</li><li>通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ <span class="comment">// false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h3><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul><p>ES6以前是不允许原生构造函数的继承，由于继承机制的不同，Class可以继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>可见<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。</p></blockquote><h3 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h3><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  a: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  b: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b&#125;; <span class="comment">// &#123;a: &#x27;a&#x27;, b: &#x27;b&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="JS高阶"><a href="#JS高阶" class="headerlink" title="JS高阶"></a>JS高阶</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li>了解正则表达式基本语法</li><li>能够使用JavaScript的正则对象</li></ul><h3 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h3><h4 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h4><p>正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。<br>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><h4 id="正则表达式的作用"><a href="#正则表达式的作用" class="headerlink" title="正则表达式的作用"></a>正则表达式的作用</h4><ol><li>给定的字符串是否符合正则表达式的过滤逻辑(匹配)</li><li>可以通过正则表达式，从字符串中获取我们想要的特定部分(提取)</li><li>强大的字符串替换能力(替换)</li></ol><h4 id="正则表达式的特点"><a href="#正则表达式的特点" class="headerlink" title="正则表达式的特点"></a>正则表达式的特点</h4><ol><li>灵活性、逻辑性和功能性非常的强</li><li>可以迅速地用极简单的方式达到字符串的复杂控制</li><li>对于刚接触的人来说，比较晦涩难懂</li></ol><h3 id="正则表达式的测试"><a href="#正则表达式的测试" class="headerlink" title="正则表达式的测试"></a>正则表达式的测试</h3><ul><li><a target="_blank" rel="noopener" href="https://c.runoob.com/front-end/854">在线测试正则</a></li><li>工具中使用正则表达式<ul><li>sublime/vscode/word</li><li>演示替换所有的数字</li></ul></li></ul><h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><ul><li>普通字符</li><li>特殊字符(元字符)：正则表达式中有特殊意义的字符</li></ul><p>示例演示：</p><ul><li><code>\d</code> 匹配数字</li><li><code>ab\d</code> 匹配 ab1、ab2</li></ul><h3 id="元字符串"><a href="#元字符串" class="headerlink" title="元字符串"></a>元字符串</h3><p>通过测试工具演示下面元字符的使用</p><h4 id="常用元字符串"><a href="#常用元字符串" class="headerlink" title="常用元字符串"></a>常用元字符串</h4><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线</td></tr><tr><td>\W</td><td>匹配任意不是字母，数字，下划线</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>.</td><td>匹配除换行符以外的任意单个字符</td></tr><tr><td>^</td><td>表示匹配行首的文本(以谁开始)</td></tr><tr><td>$</td><td>表示匹配行尾的文本(以谁结束)</td></tr></tbody></table><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table><thead><tr><th>限定符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思</span><br><span class="line">[^]  匹配除中括号以内的内容</span><br><span class="line">\ 转义符</span><br><span class="line">| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱</span><br><span class="line">() 从两个直接量中选择一个，分组</span><br><span class="line">   eg：gr(a|e)y匹配gray和grey</span><br><span class="line">[\u4e00-\u9fa5]  匹配汉字</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>验证手机号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">11</span>&#125;$</span><br></pre></td></tr></table></figure><p>验证邮编：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">6</span>&#125;$</span><br></pre></td></tr></table></figure><p>验证日期 2012-5-01</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;$</span><br></pre></td></tr></table></figure><p>验证邮箱 <a href="mailto:&#120;&#120;&#x78;&#64;&#x69;&#x74;&#99;&#x61;&#115;&#116;&#x2e;&#x63;&#110;">&#120;&#120;&#x78;&#64;&#x69;&#x74;&#99;&#x61;&#115;&#116;&#x2e;&#x63;&#110;</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\w+@\w+\.\w+$</span><br></pre></td></tr></table></figure><p>验证IP地址 192.168.1.10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;\(.\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)&#123;<span class="number">3</span>&#125;$</span><br></pre></td></tr></table></figure><h2 id="JavaScript-中使用正则表达式"><a href="#JavaScript-中使用正则表达式" class="headerlink" title="JavaScript 中使用正则表达式"></a>JavaScript 中使用正则表达式</h2><h3 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h3><p>方式1：构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> Regex(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> Regex(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;gi&#x27;</span>);</span><br></pre></td></tr></table></figure><p>方式2：字面量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/i</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/gi</span>;</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写</td></tr><tr><td>g</td><td>全局匹配</td></tr><tr><td>gi</td><td>全局匹配+忽略大小写</td></tr></tbody></table><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配日期</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2015-10-10&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(dateStr));</span><br></pre></td></tr></table></figure><p>###匹配正则表达式<br>// console.log(/./.test(“除了回车换行以为的任意字符”));//true<br>// console.log(/.*/.test(“0个到多个”));//true<br>// console.log(/.+/.test(“1个到多个”));//true<br>// console.log(/.?/.test(“哈哈”));//true<br>// console.log(/[0-9]/.test(“9527”));//true<br>// console.log(/[a-z]/.test(“what”));//true<br>// console.log(/[A-Z]/.test(“Are”));//true<br>// console.log(/[a-zA-Z]/.test(“干啥子”));//false<br>// console.log(/[0-9a-zA-Z]/.test(“9ebg”));//true<br>// console.log(/b|(ara)/.test(“abra”));//true<br>// console.log(/[a-z]{2,3}/.test(“arfsf”));//true</p><pre><code>    console.log(/\d/.test(&quot;998&quot;));//true
    console.log(/\d*/.test(&quot;998&quot;));//true
    console.log(/\d+/.test(&quot;998&quot;));//true
    console.log(/\d&#123;0,&#125;/.test(&quot;998&quot;));//true
    console.log(/\d&#123;2,3&#125;/.test(&quot;998&quot;));//true
    console.log(/\D/.test(&quot;eat&quot;));//true
    console.log(/\s/.test(&quot;  &quot;));//true
    console.log(/\S/.test(&quot;嘎嘎&quot;));//true
    console.log(/\w/.test(&quot;_&quot;));//true
    console.log(/\W/.test(&quot;_&quot;));//true</code></pre><p>###正则表达式案例<br>1.验证密码强弱<br>2.验证邮箱：[0-9a-zA-Z_.-]+[@][0-9a-zA-Z._-]+([.][a-zA-Z]+){1,2}<br>3.验证中文名字[\u4e00-\u9fa5]</p><h3 id="正则提取"><a href="#正则提取" class="headerlink" title="正则提取"></a>正则提取</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 提取工资</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;张三：1000，李四：5000，王五：8000。&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取email地址</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\w+@\w+\.\w+(\.\w+)?/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 分组提取  </span></span><br><span class="line"><span class="comment">// 3. 提取日期中的年部分  2015-5-10</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2016-1-5&#x27;</span>;</span><br><span class="line"><span class="comment">// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(dateStr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提取邮件中的每一部分</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w+)@(\w+)\.(\w+)(\.\w+)?/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 替换所有空白</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;   123AD  asadf   asadfasf  adf &quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/\s/g</span>,<span class="string">&quot;xx&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换所有,|，</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc,efg,123，abc,123，a&quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/,|，/g</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure><h3 id="案例：表单验证"><a href="#案例：表单验证" class="headerlink" title="案例：表单验证"></a>案例：表单验证</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QQ号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtQQ&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtEMail&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">手机：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtPhone&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">生日：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtBirthday&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文本框</span></span><br><span class="line"><span class="keyword">var</span> txtQQ = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtQQ&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> txtEMail = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtEMail&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> txtPhone = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtPhone&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> txtBirthday = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtBirthday&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> txtName = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtName&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">txtQQ.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前文本框对应的span</span></span><br><span class="line">  <span class="keyword">var</span> span = <span class="built_in">this</span>.nextElementSibling;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;5,12&#125;$/</span>;</span><br><span class="line">  <span class="comment">//判断验证是否成功</span></span><br><span class="line">  <span class="keyword">if</span>(!reg.test(<span class="built_in">this</span>.value) )&#123;</span><br><span class="line">    <span class="comment">//验证不成功</span></span><br><span class="line">    span.innerText = <span class="string">&quot;请输入正确的QQ号&quot;</span>;</span><br><span class="line">    span.style.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//验证成功</span></span><br><span class="line">    span.innerText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    span.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//txtEMail</span></span><br><span class="line">txtEMail.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前文本框对应的span</span></span><br><span class="line">  <span class="keyword">var</span> span = <span class="built_in">this</span>.nextElementSibling;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/^\w+@\w+\.\w+(\.\w+)?$/</span>;</span><br><span class="line">  <span class="comment">//判断验证是否成功</span></span><br><span class="line">  <span class="keyword">if</span>(!reg.test(<span class="built_in">this</span>.value) )&#123;</span><br><span class="line">    <span class="comment">//验证不成功</span></span><br><span class="line">    span.innerText = <span class="string">&quot;请输入正确的EMail地址&quot;</span>;</span><br><span class="line">    span.style.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//验证成功</span></span><br><span class="line">    span.innerText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    span.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>表单验证部分，封装成函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regBirthday = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span>;</span><br><span class="line">addCheck(txtBirthday, regBirthday, <span class="string">&quot;请输入正确的出生日期&quot;</span>);</span><br><span class="line"><span class="comment">//给文本框添加验证</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCheck</span>(<span class="params">element, reg, tip</span>) </span>&#123;</span><br><span class="line">  element.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前文本框对应的span</span></span><br><span class="line">    <span class="keyword">var</span> span = <span class="built_in">this</span>.nextElementSibling;</span><br><span class="line">    <span class="comment">//判断验证是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(!reg.test(<span class="built_in">this</span>.value) )&#123;</span><br><span class="line">      <span class="comment">//验证不成功</span></span><br><span class="line">      span.innerText = tip;</span><br><span class="line">      span.style.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//验证成功</span></span><br><span class="line">      span.innerText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      span.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给元素增加自定义验证属性对表单进行验证：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;frm&quot;</span>&gt;</span></span><br><span class="line">  QQ号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtQQ&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;qq&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtEMail&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  手机：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtPhone&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;phone&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  生日：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtBirthday&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;date&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtName&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;cn&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的验证规则</span></span><br><span class="line"><span class="keyword">var</span> rules = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;qq&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^\d&#123;5,12&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的QQ&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;email&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^\w+@\w+\.\w+(\.\w+)?$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的邮箱地址&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;phone&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^\d&#123;11&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的手机号码&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的出生日期&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^[\u4e00-\u9fa5]&#123;2,4&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的姓名&quot;</span></span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">addCheck(<span class="string">&#x27;frm&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//给文本框添加验证</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCheck</span>(<span class="params">formId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">      len = <span class="number">0</span>,</span><br><span class="line">      frm =<span class="built_in">document</span>.getElementById(formId);</span><br><span class="line">  len = frm.children.length;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = frm.children[i];</span><br><span class="line">    <span class="comment">// 表单元素中有name属性的元素添加验证</span></span><br><span class="line">    <span class="keyword">if</span> (element.name) &#123;</span><br><span class="line">      element.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 使用dataset获取data-自定义属性的值</span></span><br><span class="line">        <span class="keyword">var</span> ruleName = <span class="built_in">this</span>.dataset.rule;</span><br><span class="line">        <span class="keyword">var</span> rule =getRuleByRuleName(rules, ruleName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> span = <span class="built_in">this</span>.nextElementSibling;</span><br><span class="line">        <span class="comment">//判断验证是否成功</span></span><br><span class="line">        <span class="keyword">if</span>(!rule.reg.test(<span class="built_in">this</span>.value) )&#123;</span><br><span class="line">          <span class="comment">//验证不成功</span></span><br><span class="line">          span.innerText = rule.tip;</span><br><span class="line">          span.style.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//验证成功</span></span><br><span class="line">          span.innerText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">          span.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则的名称获取规则对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRuleByRuleName</span>(<span class="params">rules, ruleName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">      len = rules.length;</span><br><span class="line">  <span class="keyword">var</span> rule = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rules[i].name == ruleName) &#123;</span><br><span class="line">      rule = rules[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a href="#" class="headerlink"></a></h2></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">----------文本结束<i class="fa fa-hand-o-right"></i>感谢您的阅读--------</div></div></div><div class="reward-container"><div>坚持原创，感谢您的支持！</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/wechat.jpg" alt="John Doe 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/zhifubao.jpg" alt="John Doe 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/javascript/" rel="tag"><i class="fa fa-tag"></i> javascript</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/09/10/8.node/" rel="prev" title="前端必学之nodeJs"><i class="fa fa-chevron-left"></i> 前端必学之nodeJs</a></div><div class="post-nav-item"><a href="/2020/09/20/science/" rel="next" title="小科技">小科技 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#javascript%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">javascript基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JS%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">JS概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%A3%E6%9E%90%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C"><span class="nav-number">1.1.2.</span> <span class="nav-text">2.解析执行与编译执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%84%9A%E6%9C%AC%E8%B0%83%E7%94%A8%E7%AD%96%E7%95%A5"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.脚本调用策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#async"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">async</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">defer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E8%B0%83%E7%94%A8%E7%AD%96%E7%95%A5%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">脚本调用策略小结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-js%E7%BB%84%E6%88%90"><span class="nav-number">1.1.4.</span> <span class="nav-text">4.js组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">5.变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">1.命名规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">2.定义变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.数据类型划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.值类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-undefined"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.1.undefined</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-null"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.null</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-boolean"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.3.boolean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">2.4.字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%94%A8%E5%BC%95%E5%8F%B7%E6%97%B6%EF%BC%8C%E5%8F%AF%E5%8D%95%E5%8F%AF%E5%8F%8C%EF%BC%8C%E5%94%AF%E7%8B%AC%E4%B8%8D%E5%8F%AF%E4%B8%80%E5%8D%95%E4%B8%80%E5%8F%8C%E3%80%82%E5%8F%AF%E7%94%A8-length%E7%9C%8B%E6%9C%89%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E3%80%82"><span class="nav-number">1.2.2.4.1.</span> <span class="nav-text">定义方式：用引号时，可单可双，唯独不可一单一双。可用.length看有几个字符。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E8%AF%91%EF%BC%9A%E6%97%A0%E6%B3%95%E8%BE%93%E5%87%BA%E7%9A%84%E5%AD%97%E7%AC%A6%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%BD%AC%E8%AF%91%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9A-%E2%80%98%E2%80%99-%E2%80%98-%E7%AD%89%E3%80%82"><span class="nav-number">1.2.2.4.2.</span> <span class="nav-text">转译：无法输出的字符，使用转译字符输出，例如：&#x2F; ‘’ ‘ &#x2F;&#x2F;等。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%BF%E7%94%A8%E2%80%9C-%E2%80%9D%E5%AD%97%E7%AC%A6%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%AD%97%E7%AC%A6%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.2.4.3.</span> <span class="nav-text">字符串的连接，使用“+”字符连接，可以是字符变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%EF%BC%9AtoString"><span class="nav-number">1.2.2.4.4.</span> <span class="nav-text">转换：toString()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.4.5.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES6%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.4.6.</span> <span class="nav-text">ES6提供的新方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.2.4.7.</span> <span class="nav-text">字符串的遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSON-stringify-%E7%9A%84%E6%94%B9%E9%80%A0"><span class="nav-number">1.2.2.4.8.</span> <span class="nav-text">JSON.stringify() 的改造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.2.4.9.</span> <span class="nav-text">模板字符串</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-Number"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">2.5.Number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-object"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">2.6.object()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-Symbol"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">2.7.Symbol</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">2.8数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">4.对象的表示方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%AE%BE%E7%BD%AE%E6%96%B0%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98"><span class="nav-number">1.2.4.</span> <span class="nav-text">5.设置新建对象成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-this%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.2.5.</span> <span class="nav-text">6.this的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-constructor%E5%B1%9E%E6%80%A7"><span class="nav-number">1.2.6.</span> <span class="nav-text">7.constructor属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.7.</span> <span class="nav-text">8.原型的继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON"><span class="nav-number">1.3.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5"><span class="nav-number">1.4.</span> <span class="nav-text">异步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E6%99%AF"><span class="nav-number">1.4.1.</span> <span class="nav-text">前景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">单线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#callbacks%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">callbacks回调函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">过程解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">总结：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#then"><span class="nav-number">1.4.3.2.3.</span> <span class="nav-text">then</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#catch"><span class="nav-number">1.4.3.2.4.</span> <span class="nav-text">catch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#all"><span class="nav-number">1.4.3.2.5.</span> <span class="nav-text">all</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#finally"><span class="nav-number">1.4.3.2.6.</span> <span class="nav-text">finally</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#race"><span class="nav-number">1.4.3.2.7.</span> <span class="nav-text">race</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#allSettled"><span class="nav-number">1.4.3.2.8.</span> <span class="nav-text">allSettled</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#resolve"><span class="nav-number">1.4.3.2.9.</span> <span class="nav-text">resolve</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reject"><span class="nav-number">1.4.3.2.10.</span> <span class="nav-text">reject</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89promise"><span class="nav-number">1.4.3.2.11.</span> <span class="nav-text">构建自定义promise</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">事件队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise%E4%B8%8Ecallback%E5%AF%B9%E6%AF%94"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">Promise与callback对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94"><span class="nav-number">1.4.4.</span> <span class="nav-text">时间间隔</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setTimeout"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">setTimeout()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setInterval"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">setInterval()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setTimeout-%E5%92%8C-setInterval-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">setTimeout() 和 setInterval() 注意点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#requestAnimationFrame"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">requestAnimationFrame()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-await%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="nav-number">1.4.5.</span> <span class="nav-text">async&#x2F;await的基本要素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS%E4%B8%AD%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">JS中的可枚举属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Web-API"><span class="nav-number">2.</span> <span class="nav-text">Web API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAPI"><span class="nav-number">2.1.</span> <span class="nav-text">什么是API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8API"><span class="nav-number">2.2.</span> <span class="nav-text">常见的浏览器API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">2.3.</span> <span class="nav-text">JavaScript的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ECMAScript-JavaScript%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="nav-number">2.3.0.1.</span> <span class="nav-text">ECMAScript - JavaScript的核心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BOM-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.0.2.</span> <span class="nav-text">BOM - 浏览器对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.0.3.</span> <span class="nav-text">DOM - 文档对象模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BOM"><span class="nav-number">2.4.</span> <span class="nav-text">BOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BOM%E7%9A%84%E9%A1%B6%E7%BA%A7%E5%AF%B9%E8%B1%A1window"><span class="nav-number">2.4.1.</span> <span class="nav-text">BOM的顶级对象window</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">2.4.2.</span> <span class="nav-text">系统的对话框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.4.3.</span> <span class="nav-text">页面加载事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">2.4.4.</span> <span class="nav-text">定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setTimeout-%E5%92%8CclearTimeout"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">setTimeout()和clearTimeout()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setInterval-%E5%92%8CclearInterval"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">setInterval()和clearInterval()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#location%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.5.</span> <span class="nav-text">location对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URL"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">URL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#location%E6%88%90%E5%91%98"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">location成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#history%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.6.</span> <span class="nav-text">history对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#navigator%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.7.</span> <span class="nav-text">navigator对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#screen-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.8.</span> <span class="nav-text">screen 对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM"><span class="nav-number">2.5.</span> <span class="nav-text">DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.5.1.</span> <span class="nav-text">DOM的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM%E7%BB%8F%E5%B8%B8%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.2.</span> <span class="nav-text">DOM经常进行的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="nav-number">2.5.3.</span> <span class="nav-text">获取页面元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.6.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%8B%E4%BB%B6%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">2.6.1.</span> <span class="nav-text">1.事件三要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.事件的三个阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">2.6.3.</span> <span class="nav-text">3.事件的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.6.4.</span> <span class="nav-text">4.获取事件对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">2.6.5.</span> <span class="nav-text">5.事件对象的常用属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.6.6.</span> <span class="nav-text">6.注册事件的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="nav-number">2.6.7.</span> <span class="nav-text">7.事件流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="nav-number">2.6.7.1.</span> <span class="nav-text">事件冒泡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BB%A3%E7%90%86%EF%BC%89"><span class="nav-number">2.6.7.2.</span> <span class="nav-text">事件委托（代理）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.6.8.</span> <span class="nav-text">键盘事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.6.9.</span> <span class="nav-text">鼠标事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.6.10.</span> <span class="nav-text">拖拽事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8B%96%E6%8B%BD%E5%85%83%E7%B4%A0"><span class="nav-number">2.6.10.1.</span> <span class="nav-text">1.拖拽元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0"><span class="nav-number">2.6.10.2.</span> <span class="nav-text">2.目标元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="nav-number">2.6.10.3.</span> <span class="nav-text">3.事件监听</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BE%E5%88%B0%E4%BD%95%E5%A4%84-ondragover"><span class="nav-number">2.6.10.4.</span> <span class="nav-text">放到何处 - ondragover</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.</span> <span class="nav-text">属性操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%9D%9E%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">2.7.1.</span> <span class="nav-text">1.非表单元素的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="nav-number">2.7.2.</span> <span class="nav-text">2.表单元素属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%A0%87%E7%AD%BE%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="nav-number">2.7.3.</span> <span class="nav-text">3.标签的自定义属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%86%85%E5%AE%B9%E5%B1%9E%E6%80%A7innerText-%E5%92%8C-innerHTML"><span class="nav-number">2.7.4.</span> <span class="nav-text">4.标签的内容属性innerText 和 innerHTML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%B1%BB%E5%90%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.5.</span> <span class="nav-text">5.类名操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-H5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="nav-number">2.7.6.</span> <span class="nav-text">6.H5自定义属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.</span> <span class="nav-text">样式操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#body%E7%9A%84%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.1.</span> <span class="nav-text">body的样式操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EcssText"><span class="nav-number">2.8.2.</span> <span class="nav-text">关于cssText</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">2.9.</span> <span class="nav-text">节点操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="nav-number">2.9.1.</span> <span class="nav-text">1.节点属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%8A%82%E7%82%B9%E6%9F%A5%E6%89%BE"><span class="nav-number">2.9.2.</span> <span class="nav-text">2.节点查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="nav-number">2.9.3.</span> <span class="nav-text">3.添加节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#appendChild-%E5%9C%A8%E5%AD%90%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%90%8E%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E5%85%83%E7%B4%A0"><span class="nav-number">2.9.3.1.</span> <span class="nav-text">appendChild 在子元素的最后添加一个新元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insertBefore-%E6%94%BE%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B9%8B%E5%89%8D"><span class="nav-number">2.9.3.2.</span> <span class="nav-text">insertBefore : 放在某个元素之前</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%85%8B%E9%9A%86%E8%8A%82%E7%82%B9-%E9%87%8D%E7%82%B9"><span class="nav-number">2.9.4.</span> <span class="nav-text">4.克隆节点 (重点)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9"><span class="nav-number">2.9.5.</span> <span class="nav-text">5.创建节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#document-write"><span class="nav-number">2.9.5.1.</span> <span class="nav-text">document.write()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innerHTML"><span class="nav-number">2.9.5.2.</span> <span class="nav-text">innerHTML</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-createElement"><span class="nav-number">2.9.5.3.</span> <span class="nav-text">document.createElement()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">2.9.5.4.</span> <span class="nav-text">性能问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">2.9.6.</span> <span class="nav-text">其他节点操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8F"><span class="nav-number">2.10.</span> <span class="nav-text">三大家族</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#offset%E5%AE%B6%E6%97%8F"><span class="nav-number">2.10.1.</span> <span class="nav-text">offset家族</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scroll%E5%AE%B6%E6%97%8F"><span class="nav-number">2.10.2.</span> <span class="nav-text">scroll家族</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client%E5%AE%B6%E6%97%8F"><span class="nav-number">2.10.3.</span> <span class="nav-text">client家族</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.10.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9F%B3%E9%A2%91API"><span class="nav-number">2.11.</span> <span class="nav-text">音频API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8DAPI"><span class="nav-number">2.12.</span> <span class="nav-text">地理定位API</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6"><span class="nav-number">3.</span> <span class="nav-text">ES6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">3.1.</span> <span class="nav-text">解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.变量的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.对象的结构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.字符串的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%95%B0%E5%80%BC%E5%92%8C%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">3.1.4.</span> <span class="nav-text">4.数值和布尔值的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">3.1.5.</span> <span class="nav-text">5.函数参数的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%9C%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.6.</span> <span class="nav-text">6.解构赋值圆括号问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">Set和Map数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">3.2.1.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">Set实例的属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">遍历操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">3.2.2.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AB%E4%B9%89%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">含义及用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">遍历方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">与其他数据结构的转化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy"><span class="nav-number">3.2.3.</span> <span class="nav-text">Proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">1.概述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">3.3.0.1.</span> <span class="nav-text">类的装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%A3%85%E9%A5%B0"><span class="nav-number">3.3.0.2.</span> <span class="nav-text">方法的装饰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.0.3.</span> <span class="nav-text">为什么装饰器不能用于函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#core-decorators-js"><span class="nav-number">3.3.0.4.</span> <span class="nav-text">core-decorators.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mixin"><span class="nav-number">3.3.0.5.</span> <span class="nav-text">Mixin</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator%EF%BC%88%E9%81%8D%E5%8E%86%E5%99%A8%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">Iterator（遍历器）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">3.4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4Iterator%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.4.2.</span> <span class="nav-text">默认Iterator接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-Iterator-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9C%BA%E5%90%88"><span class="nav-number">3.4.3.</span> <span class="nav-text">调用 Iterator 接口的场合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84Iterator%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.4.4.</span> <span class="nav-text">字符串的Iterator接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%99%A8%E5%AF%B9%E8%B1%A1%E7%9A%84-return-%EF%BC%8Cthrow"><span class="nav-number">3.4.5.</span> <span class="nav-text">遍历器对象的 return()，throw()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E2%80%A6of-%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.4.6.</span> <span class="nav-text">for…of 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%BC%BC%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.4.7.</span> <span class="nav-text">类似数组的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.4.8.</span> <span class="nav-text">对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generator%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">Generator函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.5.0.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#yield%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.5.0.2.</span> <span class="nav-text">yield表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8EIterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.5.0.3.</span> <span class="nav-text">与Iterator接口的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#next%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">3.5.0.4.</span> <span class="nav-text">next方法的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for%E2%80%A6of%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.5.0.5.</span> <span class="nav-text">for…of循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator-prototype-throw"><span class="nav-number">3.5.0.6.</span> <span class="nav-text">Generator.prototype.throw()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator-prototype-return"><span class="nav-number">3.5.0.7.</span> <span class="nav-text">Generator.prototype.return()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#next-%E3%80%81throw-%E3%80%81return-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">3.5.0.8.</span> <span class="nav-text">next()、throw()、return() 的共同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.5.0.9.</span> <span class="nav-text">yield* 表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84-Generator-%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.0.10.</span> <span class="nav-text">作为对象属性的 Generator 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator%E5%87%BD%E6%95%B0%E7%9A%84this"><span class="nav-number">3.5.0.11.</span> <span class="nav-text">Generator函数的this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generator%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8"><span class="nav-number">3.6.</span> <span class="nav-text">Generator函数的异步应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.1.</span> <span class="nav-text">1.传统方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.6.2.</span> <span class="nav-text">2.基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5-1"><span class="nav-number">3.6.2.1.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.2.2.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-1"><span class="nav-number">3.6.2.3.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator%E5%87%BD%E6%95%B0-1"><span class="nav-number">3.6.2.4.</span> <span class="nav-text">Generator函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thunk%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.2.5.</span> <span class="nav-text">Thunk函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thunkify%E6%A8%A1%E5%9D%97"><span class="nav-number">3.6.2.6.</span> <span class="nav-text">Thunkify模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator%E5%87%BD%E6%95%B0%E7%9A%84%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">3.6.2.7.</span> <span class="nav-text">Generator函数的流程管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#co%E6%A8%A1%E5%9D%97"><span class="nav-number">3.6.2.8.</span> <span class="nav-text">co模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Promise-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C"><span class="nav-number">3.6.2.9.</span> <span class="nav-text">基于 Promise 对象的自动执行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">3.7.</span> <span class="nav-text">Class的基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">3.7.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constructor%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">constructor方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.7.1.2.</span> <span class="nav-text">类的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88getter%EF%BC%89%E5%92%8C%E5%AD%98%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88setter%EF%BC%89"><span class="nav-number">3.7.1.3.</span> <span class="nav-text">取值函数（getter）和存值函数（setter）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.7.1.4.</span> <span class="nav-text">属性表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.7.1.5.</span> <span class="nav-text">Class 表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">3.7.1.6.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.2.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="nav-number">3.7.3.</span> <span class="nav-text">静态属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%86%99%E6%B3%95"><span class="nav-number">3.7.4.</span> <span class="nav-text">实例属性的新写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-number">3.7.5.</span> <span class="nav-text">私有方法和私有属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E6%8F%90%E6%A1%88"><span class="nav-number">3.7.6.</span> <span class="nav-text">私有属性提案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-target"><span class="nav-number">3.7.7.</span> <span class="nav-text">new.target</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">3.8.</span> <span class="nav-text">Class的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#super%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="nav-number">3.8.1.</span> <span class="nav-text">super关键词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8C-proto-%E5%B1%9E%E6%80%A7"><span class="nav-number">3.8.2.</span> <span class="nav-text">类的 prototype 属性和__proto__属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">3.8.3.</span> <span class="nav-text">原生构造函数的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mixin-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.8.4.</span> <span class="nav-text">Mixin 模式的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS%E9%AB%98%E9%98%B6"><span class="nav-number">4.</span> <span class="nav-text">JS高阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">正则表达式简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">什么是正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">正则表达式的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">正则表达式的特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">正则表达式的测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">4.1.3.</span> <span class="nav-text">正则表达式的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.1.4.</span> <span class="nav-text">元字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%85%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">常用元字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-number">4.1.4.2.</span> <span class="nav-text">限定符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">4.1.4.3.</span> <span class="nav-text">其它</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">4.1.5.</span> <span class="nav-text">案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">JavaScript 中使用正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.2.1.</span> <span class="nav-text">创建正则对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D"><span class="nav-number">4.2.2.</span> <span class="nav-text">正则匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E6%8F%90%E5%8F%96"><span class="nav-number">4.2.3.</span> <span class="nav-text">正则提取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2"><span class="nav-number">4.2.4.</span> <span class="nav-text">正则替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81"><span class="nav-number">4.2.5.</span> <span class="nav-text">案例：表单验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.3.</span> <span class="nav-text"></span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="John Doe" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3684345252,2646729991&fm=26&gp=0.jpg"><p class="site-author-name" itemprop="name">John Doe</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/1738736002" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1738736002" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="mailto:1738736002@qq.com" title="E-Mail → mailto:1738736002@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://weibo.com/u/5752159618/home?wvr=5" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5752159618&#x2F;home?wvr&#x3D;5" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://yoursite.com/" title="http:&#x2F;&#x2F;yoursite.com" rel="noopener" target="_blank">Title</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-history fa-" aria-hidden="true"></i> 近期文章</div><ul class="links-of-blogroll-list"><li class="recent_posts_li"><a href="/" target="_blank"></a></li><li class="recent_posts_li"><a href="/" target="_blank"></a></li><li class="recent_posts_li"><a href="/" target="_blank"></a></li><li class="recent_posts_li"><a href="/" target="_blank"></a></li><li class="recent_posts_li"><a href="/" target="_blank"></a></li></ul></div><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1383403530&auto=1&height=66"></iframe></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">John Doe</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">293k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">4:26</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'HhBmsqkNlfQB4gpLpmFYUDxv-gzGzoHsz',
      appKey     : '7j1MdMn5bsljKv5N792nVH5h',
      placeholder: "留言区",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>