<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>canvas</title>
    <url>/2020/09/10/5.canvas/</url>
    <content><![CDATA[<h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><blockquote>
<p>canvas 最早由Apple引入WebKit,用于Mac OS X 的 Dashboard,后来又在Safari和Google Chrome被实现。<br>基于 Gecko 1.8的浏览器,比如 Firefox 1.5, 同样支持这个元素。<br>&lt;canvas&gt; 元素是WhatWG Web applications 1.0规范的一部分,也包含于HTML 5中。  </p>
</blockquote>
<a id="more"></a>
<h3 id="体验Canvas"><a href="#体验Canvas" class="headerlink" title="体验Canvas"></a>体验Canvas</h3><h4 id="什么是Canvas？"><a href="#什么是Canvas？" class="headerlink" title="什么是Canvas？"></a>什么是Canvas？</h4><p>HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。<br>画布是一个矩形区域，您可以控制其每一像素。<br>canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p>
<h4 id="创建Canvas元素"><a href="#创建Canvas元素" class="headerlink" title="创建Canvas元素"></a>创建Canvas元素</h4><p>向 HTML5 页面添加 canvas 元素。</p>
<p>画布的大小在canvas中添加，不能单独设置<br>规定元素的 id、宽度和高度：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Canvas坐标系"><a href="#Canvas坐标系" class="headerlink" title="Canvas坐标系"></a>Canvas坐标系</h4><p><img src="images/location.jpg"></p>
<h4 id="通过JavaScript来绘制"><a href="#通过JavaScript来绘制" class="headerlink" title="通过JavaScript来绘制"></a>通过JavaScript来绘制</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*获取元素*/</span></span><br><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#myCanvas&#x27;</span>);</span><br><span class="line"><span class="comment">/*获取绘图工具*/</span></span><br><span class="line"><span class="keyword">var</span> context = myCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="comment">/*设置绘图的起始位置*/</span></span><br><span class="line">context.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">/*绘制路径*/</span></span><br><span class="line">context.lineTo(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line"><span class="comment">/*描边*/</span></span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure>

<h3 id="Canvas的基本使用"><a href="#Canvas的基本使用" class="headerlink" title="Canvas的基本使用"></a>Canvas的基本使用</h3><h4 id="模糊问题（1px，黑色）"><a href="#模糊问题（1px，黑色）" class="headerlink" title="模糊问题（1px，黑色）"></a>模糊问题（1px，黑色）</h4><ul>
<li>产生原因：对齐的点是线的中心位置，会把线分成两个0.5px,显示不饱和</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线条模糊问题</span></span><br><span class="line">		context.moveTo(<span class="number">100</span>, <span class="number">100.5</span>);</span><br><span class="line">		<span class="comment">//路径</span></span><br><span class="line">		context.lineTo(<span class="number">200</span>, <span class="number">100.5</span>);</span><br><span class="line"></span><br><span class="line">		context.moveTo(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">		context.lineTo(<span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<h4 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h4><p>需要理解些概念：  </p>
<ul>
<li>路径的概念</li>
<li>路径的绘制<ul>
<li>描边 stroke()  </li>
<li>填充 fill()<br><img src="images/path.jpg">  </li>
</ul>
</li>
<li>闭合路径<ul>
<li>手动闭合</li>
<li>程序闭合 closePath()   关闭lineTo的路径，达到自动闭合的目的，解决图形缺角问题。</li>
</ul>
</li>
<li><strong>填充规则(非零环绕填充)</strong>  ：判断某个区域是否被填充，从该区域引一条线，有那条与它相交的线，如果相交线是顺时针的就<code>+1</code>，逆时针就<code>-1</code>,结果为非零的就填充，是零则填充。<br><img src="images/zero.jpg"></li>
<li>开启全的路径 beginPath()   解决样式覆盖的问题（三条平行线桌不同的颜色）</li>
</ul>
<h4 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h4><ul>
<li>画笔的状态<ul>
<li>lineWidth 线宽，默认1px</li>
<li>lineCap 线末端类型：(butt默认)、round、square </li>
<li>lineJoin 相交线的拐点 miter(默认)、round、bevel</li>
<li>strokeStyle 线的颜色</li>
<li>fillStyle 填充颜色</li>
<li>setLineDash([5,3]) 设置虚线        5表示实线，3表示虚线。 </li>
<li>getLineDash() 获取虚线宽度集合  获取不重复的那段数组值，进行虚线渲染。</li>
<li>lineDashOffset 设置虚线偏移量（负值向前偏移，正值向后偏移）</li>
</ul>
</li>
</ul>
<h4 id="实例练习"><a href="#实例练习" class="headerlink" title="实例练习"></a>实例练习</h4><ul>
<li>渐变色绘制</li>
<li>镂空的房子</li>
<li>绘制坐标网格</li>
<li>绘制坐标系</li>
<li>绘制坐标点</li>
<li>绘制折线图</li>
</ul>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li><a href="http://www.w3school.com.cn/tags/html_ref_canvas.asp">w3school</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">Canvas_API</a></li>
</ul>
<h3 id="Canvas图形绘制"><a href="#Canvas图形绘制" class="headerlink" title="Canvas图形绘制"></a>Canvas图形绘制</h3><h4 id="矩形绘制"><a href="#矩形绘制" class="headerlink" title="矩形绘制"></a>矩形绘制</h4><ul>
<li>rect(x,y,w,h) 没有独立路径</li>
<li>strokeRect(x,y,w,h) 有独立路径，不影响别的绘制</li>
<li>fillRect(x,y,w,h) 有独立路径，不影响别的绘制</li>
<li>clearRect(x,y,w,h) 擦除矩形区域</li>
</ul>
<h4 id="矩形的线性渐变案例"><a href="#矩形的线性渐变案例" class="headerlink" title="矩形的线性渐变案例"></a>矩形的线性渐变案例</h4><p>创建一个线性渐变的方案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> can=<span class="built_in">document</span>.querySelector(<span class="string">&quot;#can&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> cxt=can.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"><span class="comment">//cxt.createLinearGradient(x0, y0, x1, y1) x0y0起始点，x1y1终点  还可确定长度和方向。</span></span><br><span class="line"><span class="comment">//渐变是有长度的</span></span><br><span class="line"><span class="keyword">var</span> jianbian=cxt.createLinearGradient(<span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">100</span>);</span><br><span class="line">	jianbian.addColorStop(<span class="number">0</span>, <span class="string">&#x27;pink&#x27;</span>);</span><br><span class="line">	jianbian.addColorStop(<span class="number">0.5</span>, <span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">	jianbian.addColorStop(<span class="number">1</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    cxt.fillStyle=jianbian;</span><br><span class="line">    cxt.fillRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h4 id="圆弧绘制"><a href="#圆弧绘制" class="headerlink" title="圆弧绘制"></a>圆弧绘制</h4><ul>
<li>弧度概念:是一种长度的描述单位，一个弧度相当于一个半径的长度。</li>
<li>一个圆有2*Math.PI个弧度。</li>
<li>arc()<ul>
<li>x 圆心横坐标</li>
<li>y 圆心纵坐标</li>
<li>r 半径</li>
<li>startAngle 开始角度  —–360deg的弧度2*Math.PI</li>
<li>endAngle 结束角度</li>
<li>anticlockwise 是否逆时针方向绘制（默认false表示顺时针；true表示逆时针）</li>
</ul>
</li>
</ul>
<h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h4><p>起点在左下角</p>
<ul>
<li>ctx.font = ‘微软雅黑’ 设置字体<ul>
<li>字体样式：<code>font-style=normal / italic  /  oblique</code></li>
<li>字体变体：<code>font-variant=normal / small-caps</code></li>
<li>字体的粗细：<code>font-weight=normal/bold/bolder/lighter/100-900</code></li>
<li>字号和行高<code>font-size/line-height=&#39;15px/30px&#39;</code></li>
<li>字体系列：<code>font-family=&#39;微软雅黑&#39;</code></li>
<li><a href="https://www.runoob.com/tags/canvas-font.html">more</a></li>
</ul>
</li>
<li>strokeText()</li>
<li>fillText(text,x,y,maxWidth)<ul>
<li>text 要绘制的文本</li>
<li>x,y 文本绘制的坐标（文本左下角）</li>
<li>maxWidth 设置文本最大宽度，可选参数</li>
</ul>
</li>
<li>ctx.textAlign文本水平对齐方式，相对绘制坐标来说的，基准起始坐标<ul>
<li>left</li>
<li>center</li>
<li>right</li>
<li>start   默认</li>
<li>end    </li>
</ul>
</li>
<li>ctx.direction属性css(rtl ltr) start和end于此相关<ul>
<li>如果是ltr,start和left表现一致</li>
<li>如果是rtl,start和right表现一致</li>
</ul>
</li>
<li>ctx.textBaseline 设置基线（垂直对齐方式  ）<ul>
<li>top 文本的基线处于文本的正上方，并且有一段距离</li>
<li>middle 文本的基线处于文本的正中间</li>
<li>bottom 文本的基线处于文本的证下方，并且有一段距离</li>
<li>hanging 文本的基线处于文本的正上方，并且和文本粘合</li>
<li>alphabetic 默认值，基线处于文本的下方，并且穿过文字</li>
<li>ideographic 和bottom相似，但是不一样</li>
</ul>
</li>
<li>measureText()    获取文本宽度obj.width</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tests = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;texts&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ctx = tests.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">ctx.rect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">90</span>);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.font = <span class="string">&#x27;italic normal bolder 10px/45px 微软雅黑&#x27;</span>;</span><br><span class="line">        ctx.textAlign=<span class="string">&#x27;left&#x27;</span>;</span><br><span class="line">        ctx.textBaseline = <span class="string">&quot;middle&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> s = <span class="string">&quot;我是绘制的文本内容&quot;</span>;</span><br><span class="line">        ctx.fillStyle=<span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">        ctx.shadowColor = <span class="string">&quot;yellow&quot;</span>; <span class="comment">//阴影颜色</span></span><br><span class="line">        ctx.shadowOffsetX = <span class="number">1</span>; <span class="comment">//阴影x轴位移。正值向右，负值向左。</span></span><br><span class="line">        ctx.shadowOffsetY = <span class="number">-1</span>; <span class="comment">//阴影y轴位移。正值向下，负值向上。</span></span><br><span class="line">        ctx.shadowBlur= <span class="number">1</span>; <span class="comment">//阴影模糊滤镜。数据越大，扩散程度越大</span></span><br><span class="line">        <span class="comment">// 透明度</span></span><br><span class="line">        ctx.globalAlpha = <span class="number">.5</span>;</span><br><span class="line">        ctx.fillText(s+ctx.measureText(s).width,<span class="number">30</span>,<span class="number">30</span>,<span class="number">200</span>); <span class="comment">// 我是绘制的文本内容90</span></span><br><span class="line">        <span class="comment">// s即为要测量文本</span></span><br><span class="line">        <span class="built_in">console</span>.log(ctx.measureText(s))</span><br></pre></td></tr></table></figure>





<h3 id="做动画"><a href="#做动画" class="headerlink" title="做动画"></a>做动画</h3><h4 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h4><ol>
<li>创建image对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> image=<span class="keyword">new</span> Image();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>绑定加载完成事件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">image.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//实现图片绘制</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置图片路径</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">image.src=<span class="string">&quot;路径&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="绘制图片三种方法"><a href="#绘制图片三种方法" class="headerlink" title="绘制图片三种方法"></a>绘制图片三种方法</h4><ul>
<li><p>drawImage()</p>
<ul>
<li><p>三个参数drawImage(img,x,y)</p>
<ul>
<li>img 图片对象、canvas对象、video对象</li>
<li>x,y 图片绘制的左上角</li>
</ul>
</li>
<li><p>五个参数drawImage(img,x,y,w,h)</p>
<ul>
<li>img 图片对象、canvas对象、video对象</li>
<li>x,y 图片绘制的左上角</li>
<li>w,h 图片绘制尺寸大小设置(图片缩放，不是截取)</li>
</ul>
</li>
<li><p>九个参数drawImage(img,x,y,w,h,x1,y1,w1,h1)</p>
<ul>
<li>img 图片对象、canvas对象、video对象</li>
<li>x,y图片上定位的坐标</li>
<li>w,h在图片上截取多大的区域</li>
<li>x1,y1绘制在画布上的坐标</li>
<li>w1,h1是图片的大小，不是裁剪  是缩放。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h4><ul>
<li>绘制精灵图</li>
<li>动起来</li>
<li>控制边界</li>
<li>键盘控制</li>
</ul>
<h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><ul>
<li>平移 移动画布的原点<ul>
<li>translate(x,y) 参数表示移动目标点的坐标</li>
</ul>
</li>
<li>缩放<ul>
<li>scale(x,y) 参数表示坐标宽高的缩放比例</li>
</ul>
</li>
<li>旋转<ul>
<li>rotate(angle) 参数表示坐标旋转角度</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议</title>
    <url>/2020/09/10/7.Http/</url>
    <content><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1web中的HTTP"><a href="#1-1web中的HTTP" class="headerlink" title="1.1web中的HTTP"></a>1.1web中的HTTP</h3><p>Web 使用一种名为 HTTP（HyperText Transfer Protocol， 超文本传输协议1） 的协议作为规范， 完成从客户端到服务器端等一系列运作流程。 </p>
<a id="more"></a>
<h3 id="1-2HTTP诞生"><a href="#1-2HTTP诞生" class="headerlink" title="1.2HTTP诞生"></a>1.2HTTP诞生</h3><p>1989 年 3 月 CERN（欧洲核子研究组织） 的蒂姆 • 伯纳斯 - 李（Tim BernersLee）博士提出了一种能让远隔两地的研究者们共享知识的设想，蒂姆 • 伯纳斯 - 李也成为万维网之父。</p>
<h3 id="1-3-网络技术TCP-IP"><a href="#1-3-网络技术TCP-IP" class="headerlink" title="1.3 网络技术TCP/IP"></a>1.3 网络技术TCP/IP</h3><p>TCP/IP 协议族里重要的一点就是分层。 TCP/IP 协议族按层次分别分为以下 4 层： 应用层、 传输层、 网络层和数据链路层。 </p>
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725210441053.png" alt="image-20200725210441053" style="zoom:100%;" />

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725210539920.png" alt="image-20200725210539920"></p>
<h3 id="1-4-与HTTP关系密切的协议：IP、TCP、DNS"><a href="#1-4-与HTTP关系密切的协议：IP、TCP、DNS" class="headerlink" title="1.4 与HTTP关系密切的协议：IP、TCP、DNS"></a>1.4 与HTTP关系密切的协议：IP、TCP、DNS</h3><ol>
<li>IP协议：它的作用是把各种数据包传送给对方。 而要保证确实传送到对方那里， 则需要满足各类条件。 其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address） 。 </li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725210818345.png" alt="image-20200725210818345"></p>
<ol start="2">
<li><p>TCP：按层次分， TCP 位于传输层， 提供可靠的字节流服务 。为了准确无误地将数据送达目标处， TCP 协议采用了三次握手（three-way handshaking） 策略。</p>
<p>三次握手：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725211033385.png" alt="image-20200725211033385"></p>
</li>
<li><p>DNS服务：DNS（Domain Name System） 服务是和 HTTP 协议一样位于应用层的协议。 它提供域名到 IP 地址之间的解析服务。 </p>
</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725211217465.png" alt="image-20200725211217465"></p>
<ol start="4">
<li>各种协议与HTTP协议之间的关系</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725211611098.png" alt="image-20200725211611098"></p>
<ol start="5">
<li><p>URI和URL</p>
<ul>
<li><p>URI（Uniform Resource Identifier ，统一资源标识符）、URL（Uniform Resource Locattor，统一资源定位符）</p>
</li>
<li><p>URI 用字符串标识某一互联网资源， 而 URL 表示资源的地点（互联网上所处的位置） 。 可见 URL 是 URI 的子集。</p>
</li>
</ul>
</li>
</ol>
<h2 id="二、简单的HTTP协议"><a href="#二、简单的HTTP协议" class="headerlink" title="二、简单的HTTP协议"></a>二、简单的HTTP协议</h2><h3 id="2-1-HTTP用于客户端和服务器之间的通信"><a href="#2-1-HTTP用于客户端和服务器之间的通信" class="headerlink" title="2.1 HTTP用于客户端和服务器之间的通信"></a>2.1 HTTP用于客户端和服务器之间的通信</h3><p>在两台计算机之间使用 HTTP 协议通信时， 在一条通信线路上必定有一端是客户端， 另一端则是服务器端。 </p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725212300514.png" alt="image-20200725212300514"></p>
<h3 id="2-2-HTTP是不保存状态的协议"><a href="#2-2-HTTP是不保存状态的协议" class="headerlink" title="2.2 HTTP是不保存状态的协议"></a>2.2 HTTP是不保存状态的协议</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725212537106.png" alt="image-20200725212537106"></p>
<blockquote>
<p>HTTP 协议自身不具备保存之前发送过的请求或响应的功能 </p>
<p>为了实现期望的保持状态功能， 于是引入了 Cookie 技术。 有了 Cookie 再用HTTP 协议通信， 就可以管理状态了。 </p>
</blockquote>
<h3 id="2-3-告知服务器意图的HTTP方法"><a href="#2-3-告知服务器意图的HTTP方法" class="headerlink" title="2.3 告知服务器意图的HTTP方法"></a>2.3 告知服务器意图的HTTP方法</h3><ol>
<li>GET:获取资源</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725213037517.png" alt="image-20200725213037517"></p>
<ol start="2">
<li>POST:传输实体主体</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725213152396.png" alt="image-20200725213152396"></p>
<ol start="3">
<li>PUT:传输文件</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725213255799.png" alt="image-20200725213255799"></p>
<ol start="4">
<li>HEAD：获得报文首部</li>
<li>DELETE:删除文件</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725213809764.png" alt="image-20200725213809764"></p>
<ol start="6">
<li>OPTIONS:询问支持的方法</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725214002106.png" alt="image-20200725214002106"></p>
<ol start="7">
<li><p>TRACE:追踪路径</p>
</li>
<li><p>CONNECT:要求用隧道协议连接代理</p>
</li>
<li><p>使用<code>cookie</code>的状态管理</p>
<p>HTTP 是无状态协议， 它不对之前发生过的请求和响应的状态进行管理。 也就是说， 无法根据之前的状态进行本次的请求处理。 </p>
<p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725214424095.png" alt="image-20200725214424095"></p>
<h2 id="三、HTTP报文内的HTTP信息"><a href="#三、HTTP报文内的HTTP信息" class="headerlink" title="三、HTTP报文内的HTTP信息"></a>三、HTTP报文内的HTTP信息</h2><h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><p>用于HTTP交互的信息被称为HTTP报文。请求端（客户端） 的HTTP 报文叫做请求报文， 响应端（服务器端） 的叫做响应报文。 </p>
<p><img src="https://img-blog.csdn.net/20180423213248663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plcGh5cjk5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="3-2-请求报文及响应报文的结构"><a href="#3-2-请求报文及响应报文的结构" class="headerlink" title="3.2 请求报文及响应报文的结构"></a>3.2 请求报文及响应报文的结构</h3><p><img src="https://img-blog.csdn.net/20180423213646866?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plcGh5cjk5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>图： 请求报文（上） 和响应报文（下） 的实例 </p>
<h2 id="四、返回结果的HTTP状态码"><a href="#四、返回结果的HTTP状态码" class="headerlink" title="四、返回结果的HTTP状态码"></a>四、返回结果的HTTP状态码</h2><p>4.1 状态码告知从服务器端返回的请求结果</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725215244431.png" alt="image-20200725215244431"></p>
<p>4.2 <strong>2XX 成功</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）<span class="number">200</span>：OK</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）<span class="number">202</span>：No Content</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）<span class="number">206</span>：Partial Content</span><br></pre></td></tr></table></figure>



<p>4.3 <strong>3XX重定向</strong></p>
<p>3XX表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">（1）301：Moved Permanently</span><br><span class="line"></span><br><span class="line">    永久性重定向。 该状态码表示请求的资源已被分配了新的 URI， 以后应使用资源现在所指的 URI。 </span><br><span class="line"></span><br><span class="line">（2）302：Found</span><br><span class="line"></span><br><span class="line">    临时性重定向。 该状态码表示请求的资源已被分配了新的 URI， 希望用户（本次） 能使用新的 URI 访问。</span><br><span class="line"></span><br><span class="line">（3）303：See Other</span><br><span class="line"></span><br><span class="line">（4）304：Not Modified</span><br><span class="line"></span><br><span class="line">    该状态码表示客户端发送附带条件的请求 2 时， 服务器端允许请求访问资源， 但未满足条件的情况。 304 状态码返回时， 不包含任何响应的主体部分。 304 虽然被划分在 3XX 类别中， 但是和重定向没有关系。</span><br><span class="line"></span><br><span class="line">（5）307：Temporary Redirect</span><br><span class="line"></span><br><span class="line">    临时重定向。 该状态码与 302 Found 有着相同的含义。  </span><br></pre></td></tr></table></figure>

<p>4.4 4XX 客户端错误</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">（1）400 Bad Request：请求报文中存在语法错误；</span><br><span class="line"></span><br><span class="line">（2）401 Unauthorized：该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证） 的认证信息。  </span><br><span class="line"></span><br><span class="line">（3）403 Forbidden：请求的资源被服务器拒绝；</span><br><span class="line"></span><br><span class="line">（4）404 Not Found：服务器上无法找到资源；</span><br></pre></td></tr></table></figure>



<p>4.5 5XX服务器错误</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">5XX的响应结果表明服务器本身发生错误</span><br><span class="line"></span><br><span class="line">（1）500 Internal Server Error：服务器端在执行请求时发生了错误。  </span><br><span class="line"></span><br><span class="line">（2）503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护， 现在无法处理请求。</span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://blog.csdn.net/zephyr999/java/article/details/80055420">1122</a></p>
<h2 id="五、与HTTP协作的Web服务器"><a href="#五、与HTTP协作的Web服务器" class="headerlink" title="五、与HTTP协作的Web服务器"></a>五、与HTTP协作的Web服务器</h2><p>5.1 用单台虚拟主机实现多个域名</p>
<p>5.2 通信数据转发程序 ： 代理、 网关、通道</p>
<ol>
<li><p>代理：代理是一种有转发功能的应用程序， 它扮演了位于服务器和客户端“中间人”的角色， 接收由客户端发送的请求并转发给服务器， 同时也接收服务器返回的响应并转发给客户端。</p>
</li>
<li><p>网关：网关是转发其他服务器通信数据的服务器， 接收从客户端发送来的请求时， 它就像自己拥有资源的源服务器一样对请求进行处理。 有时客户端可能都不会察觉， 自己的通信目标是一个网关。</p>
</li>
<li><p>隧道：隧道是在相隔甚远的客户端和服务器两者之间进行中转， 并保持双方通信连接的应用程序。</p>
</li>
</ol>
<h2 id="六、HTTP首部"><a href="#六、HTTP首部" class="headerlink" title="六、HTTP首部"></a>六、HTTP首部</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725215730189.png" alt="image-20200725215730189"></p>
<h3 id="1-http请求报文"><a href="#1-http请求报文" class="headerlink" title="1.http请求报文"></a>1.http请求报文</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200725215805629.png" alt="image-20200725215805629"></p>
<p>下面的示例是访问 <a href="http://hackr.jp/">http://hackr.jp</a> 时， 请求报文的首部信息</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727090641667.png" alt="image-20200727090641667"></p>
<h3 id="2-HTTP响应报文"><a href="#2-HTTP响应报文" class="headerlink" title="2.HTTP响应报文"></a>2.HTTP响应报文</h3><p>在响应中， HTTP 报文由 HTTP 版本、 状态码（数字和原因短语） 、HTTP 首部字段 3 部分构成。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727091310622.png" alt="image-20200727091310622"></p>
<h3 id="3-HTTP通用首部字段"><a href="#3-HTTP通用首部字段" class="headerlink" title="3.HTTP通用首部字段"></a>3.HTTP通用首部字段</h3><p><strong>通用首部</strong>字段是指， 请求报文和响应报文双方都会使用的首部。</p>
<ol>
<li>Cache-Control：通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727091630166.png" alt="image-20200727091630166"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cache-Control: private, max-age=<span class="number">0</span>, no-cache</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727092035433.png" alt="image-20200727092035433"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727092050222.png" alt="image-20200727092050222"></p>
<ol start="2">
<li>Connection：</li>
</ol>
<ul>
<li>控制不再转发给代理的首部字段</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727092349928.png" alt="image-20200727092349928"></p>
<blockquote>
<p>Connection: 不再转发的首部字段名</p>
</blockquote>
<ul>
<li>管理持久连接</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727092826383.png" alt="image-20200727092826383"></p>
<blockquote>
<p>响应端使用Connection: close关闭连接</p>
<p>HTTP/1.1 版本的默认连接都是持久连接。 为此， 客户端会在持久连接上连续发送请求。 当服务器端想明确断开连接时， 则指定Connection 首部字段的值为 Close。</p>
</blockquote>
<ol start="3">
<li>Date：表明创建 HTTP 报文的日期和时间。 </li>
<li>Pragma ：Pragma 是 HTTP/1.1 之前版本的历史遗留字段， 仅作为与 HTTP/1.0的向后兼容而定义 。</li>
<li>Trailer：首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。 </li>
<li>Transfer-Encoding ：首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。</li>
<li>Upgrade ：用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</li>
<li>Via：使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</li>
</ol>
<h2 id="七、HTTPS协议"><a href="#七、HTTPS协议" class="headerlink" title="七、HTTPS协议"></a>七、HTTPS协议</h2><blockquote>
<p>确保web安全的HTTPS</p>
</blockquote>
<h3 id="1-HTTP的缺点"><a href="#1-HTTP的缺点" class="headerlink" title="1.HTTP的缺点"></a>1.HTTP的缺点</h3><ul>
<li>通信使用明文（不加密），内容可能会被窃取；</li>
<li>不验证通信方的身份，因此有可能遭遇伪装；</li>
<li>无法证明报文的完整性，所以有可能以遭篡改</li>
</ul>
<p><strong>通信加密：</strong></p>
<ul>
<li>一种方式就是将通信加密。 HTTP 协议中没有加密机制， 但可以通过和 SSL（Secure Socket Layer， 安全套接层） 或TLS（Transport Layer Security， 安全层传输协议） 的组合使用，加密 HTTP 的通信内容。</li>
<li>用 SSL建立安全通信线路之后， 就可以在这条线路上进行 HTTP通信了。 与 SSL组合使用的 HTTP 被称为 HTTPS（HTTPSecure， 超文本传输安全协议） 或 HTTP over SSL。</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727093722864.png" alt="image-20200727093722864"></p>
<p><strong>内容加密：</strong></p>
<p>还有一种将参与通信的内容本身加密的方式。 由于 HTTP 协议中没有加密机制， 那么就对 HTTP 协议传输的内容本身加密。 即把HTTP 报文里所含的内容进行加密处理。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727093917511.png" alt="image-20200727093917511"></p>
<h3 id="2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="2.HTTP+ 加密 + 认证 + 完整性保护=HTTPS"></a>2.HTTP+ 加密 + 认证 + 完整性保护=HTTPS</h3><p>HTTPS 并非是应用层的一种新协议。 只是 HTTP 通信接口部分用SSL（Secure Socket Layer） 和TLS（Transport Layer Security） 协议代替而已。 </p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727094202374.png" alt="image-20200727094202374"></p>
<ol>
<li>使用两把密钥的公开密钥加密</li>
</ol>
<p>公开密钥加密使用一对非对称的密钥。 一把叫做私有密钥（private key） ， 另一把叫做公开密钥（public key） 。</p>
<ul>
<li>私有密钥不能让其他任何人知道， 而公开密钥则可以随意发布， 任何人都可以获得。</li>
<li>使用公开密钥加密方式， 发送密文的一方使用对方的公开密钥进行加密处理， 对方收到被加密的信息后， 再使用自己的私有密钥进行解密。</li>
<li>利用这种方式， 不需要发送用来解密的私有密钥， 也不必担心密钥被攻击者窃听而盗走。</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727094528425.png" alt="image-20200727094528425"></p>
<ol start="2">
<li>HTTPS 采用混合加密机制</li>
</ol>
<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。 若密钥能够实现安全交换， 那么有可能会考虑仅使用公开密钥加密来通信。 但是公开密钥加密与共享密钥加密相比， 其处理速度要慢。 </p>
<h2 id="八、确认访问用户身份的认证"><a href="#八、确认访问用户身份的认证" class="headerlink" title="八、确认访问用户身份的认证"></a>八、确认访问用户身份的认证</h2><p>HTTP使用的认证方式：</p>
<ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST（摘要认证）</li>
<li>SSL客户端认证</li>
<li>FormBase认证（基于表单的认证）</li>
</ul>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的使用</title>
    <url>/2020/09/10/hexo/</url>
    <content><![CDATA[<p>焦点事件开发接口你家乐福电脑管家丝黛芬妮攻克艰难库你看看鼓风机纳斯达克就能看，发你， 白癜风那个可难辅导班开始呢分开多功能不可能不开放都能看bn<br>规范读书报告发烧吧<br>sdfgnsfnshg<br>“&lt;”!–more–”&gt;”用来将多余部分省略<br>ngsdfsdfn</p>
<a id="more"></a>
<p>m<br>hs<br>nsn</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>html以及html5新增部分</title>
    <url>/2020/09/10/1html+html5/</url>
    <content><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h2><h3 id="1-1认识大前端"><a href="#1-1认识大前端" class="headerlink" title="1.1认识大前端"></a>1.1认识大前端</h3><ol>
<li><p>前端就是将效果图生成网页，利用html+css+js等技术</p>
</li>
<li><p>Pc端 移动端</p>
</li>
<li><p>注重用户的体验感</p>
<a id="more"></a>
<h3 id="1-2认识网页"><a href="#1-2认识网页" class="headerlink" title="1.2认识网页"></a>1.2认识网页</h3></li>
<li><p>网页由文字、图片、输入框、视频、音频、超链接等组成。</p>
</li>
<li><p>遵循web标准和W3c标准（BOM,DOM）</p>
</li>
<li><p>大体的构成</p>
<ul>
<li>html  结构标准    相当人的身体</li>
<li>css  表现标准  相当与给人化妆 变的更漂亮</li>
<li>js   行为标准  想当与人在唱歌，页面更灵动。</li>
</ul>
</li>
<li><p>浏览器是一个上网的客户端（软件）</p>
</li>
</ol>
<h3 id="1-3浏览器"><a href="#1-3浏览器" class="headerlink" title="1.3浏览器"></a>1.3浏览器</h3><ol>
<li>渲染引擎：他是浏览器的内核，他决定了浏览器如何显示网页的内容以及页面的格式信息。这也是浏览器兼容问题的根源。</li>
<li>浏览和服务器的交互</li>
</ol>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps8143.tmp.jpg" alt="img"></p>
<ol start="3">
<li>url地址</li>
</ol>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsD623.tmp.jpg" alt="img"></p>
<h3 id="1-4认识html"><a href="#1-4认识html" class="headerlink" title="1.4认识html"></a>1.4认识html</h3><ol>
<li>他是超文本标记语言（Hypertextmarkuplanguage）—超链接</li>
<li>html基本结构</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt; ! <span class="attr">doctype</span> <span class="attr">html</span>&gt;</span>    声明文档类型</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>              根标签</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>             头标签</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>       标题标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>             主体标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>标签的分类</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//单标签   </span><br><span class="line"><span class="tag">&lt;<span class="name">!</span> <span class="attr">Doctype</span> <span class="attr">html</span>&gt;</span></span><br><span class="line">//双标签   </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>   <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>   <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>标签关系分类</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">包含（嵌套关系）  <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>     父子</span><br><span class="line">  并列关系       <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>     兄弟姐妹</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>块级元素可以包含行内元素的</li>
<li>块级元素不一定能包含块级元素</li>
<li>行内元素一般不能包含块级元素</li>
</ul>
</blockquote>
<ol start="5">
<li>按默认样式分</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">块级 block</span><br><span class="line">行内块 inline</span><br><span class="line">内联样式 inline-block</span><br></pre></td></tr></table></figure>



<ol start="6">
<li>标签</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//head部分常见元素</span><br><span class="line">- meta     </span><br><span class="line"></span><br><span class="line">  - <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  字符编码</span><br><span class="line"></span><br><span class="line">  - 移动端自适应，视口宽度等于屏幕的宽度（第一步加，viewport）</span><br><span class="line"></span><br><span class="line">- title</span><br><span class="line"></span><br><span class="line">- style</span><br><span class="line"></span><br><span class="line">- link</span><br><span class="line"></span><br><span class="line">- script</span><br><span class="line"></span><br><span class="line">- base  指定基础路径，</span><br><span class="line">// body常见元素</span><br><span class="line">    div/ section/ article /aside /header /footer</span><br><span class="line">	p/span</span><br><span class="line">	em/strong</span><br><span class="line">	table / thead /tbody / tr /th /td</span><br><span class="line">		- td[colspan,rowspan]</span><br><span class="line">	ul / ol /li /dl /dt /dd</span><br><span class="line">	a[href,target], target需要在哪里打开链接，默认值self当前页面。</span><br><span class="line">	from / input /select /textarea /button[submit,]</span><br><span class="line">		- from[target,method,enctype]，method方式   enctype编码方式，主要用于post,有两种方式。</span><br><span class="line">	img[src,alt]  alt图片不能加载的时候，可以使用它用一段文字替换</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> // 有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span>  // 倒序</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">//无序</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>    列表项</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">// 自定义列表</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span>    小标题</span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span>   解释标题</span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span>   解释标题</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 相当于radio --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;radio class=&quot;&quot; value=&quot;男生&quot; disabled=&quot;false&quot; checked=&quot;true&quot; color=&quot;&quot;&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">radio</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 搜索框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 提交文本框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tijiaoanniu&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 时间框文本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输入的是网址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输入文本框   required使得此文本框必须输入内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">required</span> <span class="attr">placeholder</span>=<span class="string">&quot;描述信息...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下拉 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 组合相关的选项 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;订单选项&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 选项 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;dd&quot;</span>&gt;</span>订单<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;dd&quot;</span>&gt;</span>所示<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;dd&quot;</span>&gt;</span>订单<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;dd&quot;</span>&gt;</span>订单<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表格</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- frame控制外边框的显示 rules控制内边框的显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frame</span>=<span class="string">&quot;void&quot;</span> <span class="attr">rules</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>我是表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>表格首行有<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>加黑效果<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>第二行第一列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>第二行第二列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>第四行第一列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>第四行第二列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其他标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义音频内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;ceshi.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;mycanvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标记一个内联框架 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果指定了空字符串（sandbox=&quot;&quot;），该属性对呈现在iframe框架中的内容启用一些额外的限制条件。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">&quot;width: 400px;height: 400px;&quot;</span> <span class="attr">sandbox</span>=<span class="string">&quot;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 根据屏幕匹配的不同尺寸显示不同图片，如果没有匹配到或浏览器不支持 picture 属性则使用 img 元素： --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 650px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;demo1.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 465px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;demo2.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img_girl.jpg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">picture</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 标记下载进度 --&gt;</span></span><br><span class="line">        下载进度：<span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mark部分文字高亮显示 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Do not forget to buy <span class="tag">&lt;<span class="name">mark</span>&gt;</span>milk<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> today.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- pre保留输入文本的样式，包含空格，换行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">            此例演示如何使用 pre 标签</span><br><span class="line">            对空行和    空格</span><br><span class="line">            进行控制</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;ruby&gt; 元素由一个或多个需要解释/发音的字符和一个提供该信息的 &lt;rt&gt; 元素组成，还包括可选的 &lt;rp&gt; 元素，定义当浏览器不支持 &quot;ruby&quot; 元素时显示的内容。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">            汉 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>Han<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">            字 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>zi<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;s&gt; 标记不再正确的文本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">s</span>&gt;</span>My car is blue.<span class="tag">&lt;/<span class="name">s</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>My new car is silver.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;section&gt; 标签定义了文档的某个区域。比如章节、头部、底部或者文档的其他区域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>WWF<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>The World Wide Fund for Nature (WWF) is....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 文本中字体的样式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是正常状态下的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">del</span>&gt;</span>删除线标签<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">em</span>&gt;</span>强调文本<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗文本<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dfn</span>&gt;</span>定义项目<span class="tag">&lt;/<span class="name">dfn</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">code</span>&gt;</span>一段电脑代码Do not forget to buy <span class="tag">&lt;<span class="name">mark</span>&gt;</span>milk<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> today.<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">samp</span>&gt;</span>计算机样本<span class="tag">&lt;/<span class="name">samp</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>键盘输入<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">var</span>&gt;</span>变量int=12<span class="tag">&lt;/<span class="name">var</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>上标<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>4<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>下标<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 时间标签 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我们在每天早上 <span class="tag">&lt;<span class="name">time</span>&gt;</span>9:00<span class="tag">&lt;/<span class="name">time</span>&gt;</span> 开始营业。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我在 <span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2016-02-14&quot;</span>&gt;</span>情人节<span class="tag">&lt;/<span class="name">time</span>&gt;</span> 有个约会。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mycanvas&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        ctx.fillStyle = <span class="string">&#x27;#FF0000&#x27;</span>;</span></span><br><span class="line">        ctx.fillRect(0, 0, 80, 100);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>滚动</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps78E2.tmp.jpg" alt="img"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">behavior</span>=<span class="string">&quot;scroll&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;right&quot;</span> <span class="attr">loop</span>=<span class="string">&quot;5&quot;</span>&gt;</span>我是最凉的仔<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="1-5超链接"><a href="#1-5超链接" class="headerlink" title="1.5超链接"></a>1.5超链接</h3><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps26A9.tmp.jpg" alt="img"></p>
<ul>
<li>href  去往的路径（跳转的页面） 必写属</li>
<li>title  提示文本  鼠标放到链接上显示的文字</li>
<li>target=”_self”  默认值  在自身页面打开（关闭自身页面，打开链接页面） </li>
<li>Target=”_blank”  打开新页面 （自身页面不关闭，打开一个新的链接页面）</li>
<li>锚链接<ul>
<li>先定义一个锚点 <code>&lt;p id=&quot;sa&quot;&gt;&lt;/p&gt;</code></li>
<li>超链接到锚点 <code>&lt;a herf=&quot;#sa&quot;&gt;回到顶部&lt;/a&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="1-6表单元素"><a href="#1-6表单元素" class="headerlink" title="1.6表单元素"></a>1.6表单元素</h3><ol>
<li><p>表单的类型（input）</p>
<ul>
<li>email 输入email格式</li>
<li>tel 手机号码 需要规定格式。</li>
<li>url 只能输入url格式</li>
<li>date 时间控件</li>
<li>number 只能输入数字</li>
<li>search 搜索框</li>
<li>file  上传文件</li>
<li>submit  提交按钮</li>
<li>reset 重置按钮</li>
<li>image  图片按钮</li>
<li>range 范围 滑动条</li>
<li>color 拾色器</li>
<li>time    时间</li>
<li>password 密码</li>
<li>radio 选项</li>
</ul>
</li>
<li><p>表单属性</p>
<ul>
<li>placeholder 占位符</li>
<li>autofocus 自动获取焦点</li>
<li>multiple 文件上传多选或多个邮箱地址 </li>
<li>autocomplete 自动完成，用于表单元素，也可用于表单自身(on/off)，提示用户已经输入过的内容。on 开启（默认） off 取消自动提示</li>
<li>form 指定表单项属于哪个form，处理复杂表单时会需要</li>
<li>novalidate 关闭验证（错误提示），可用于<form>标签</li>
<li>required 提示此项是必填项</li>
<li>pattern 正则表达式 验证表单</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">手机号:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;^(\+86)?1[3,5,8](\d&#123;9&#125;)$&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>





</li>
</ol>
<ol start="3">
<li><p>表单元素</p>
<ul>
<li><code>&lt;datalist&gt; 数据列表与input 配合使用</code></li>
<li><code>&lt;keygen&gt; 生成加密字符串</code>,keygen 元素的作用是提供一种验证用户的可靠方法。<ul>
<li>keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，  一个是私钥，一个公钥。</li>
<li>私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。</li>
</ul>
</li>
<li><code>label一般与input这些表单一起使用</code></li>
<li><code>textarea 输入文本框</code></li>
<li><code>select下拉框</code>    <code>option下拉框的选项</code>     <code>optgroup组合相关的选项</code></li>
<li><code>&lt;fieldset&gt;&lt;/fieldset&gt;  对表单信息进行分组</code>  <code>&lt;legend&gt;&lt;/legend&gt;   分组名称</code></li>
</ul>
</li>
<li><p>表单事件</p>
<ul>
<li>oninput 用户输入内容时触发，可用于移动端输入字数统计</li>
<li>oninvalid 验证不通过时触发</li>
</ul>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps5FFA.tmp.jpg" alt="img"></p>
<ul>
<li>onselect      当选取元素时运行脚本</li>
<li>onsubmit     当提交表单时运行脚本</li>
<li>onblur         当元素失去焦点时运行脚本</li>
<li>onchange      当元素改变时运行脚本</li>
<li>onfocus          当元素获得焦点时运行脚本</li>
<li>onformchange              当表单改变时运行脚本</li>
</ul>
</li>
</ol>
<h3 id="1-7多媒体"><a href="#1-7多媒体" class="headerlink" title="1.7多媒体"></a>1.7多媒体</h3><h4 id="1-7-1音频"><a href="#1-7-1音频" class="headerlink" title="1.7.1音频"></a>1.7.1音频</h4><p>HTML5通过<audio>标签来解决音频播放的问题。</p>
<p>使用相当简单，如下图所示</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps8324.tmp.jpg" alt="img"> </p>
<p>并且可以通过附加属性可以更友好控制音频的播放，如：</p>
<ul>
<li><p>autoplay 自动播放</p>
</li>
<li><p>controls 是否显不默认播放控件</p>
</li>
<li><p>loop 循环播放</p>
</li>
<li><p>preload 预加载 同时设置autoplay时些属性失效</p>
</li>
</ul>
<blockquote>
<p>由于版权等原因，不同的浏览器可支持播放的格式是不一样的<img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps471.tmp.jpg" alt="img"></p>
</blockquote>
<p><strong><em>\</em>多浏览器支持的方案**</strong></p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps37C1.tmp.jpg" alt="img"></p>
<h4 id="1-7-2视频"><a href="#1-7-2视频" class="headerlink" title="1.7.2视频"></a>1.7.2视频</h4><p>HTML5通过<video>标签来解决音频播放的问题。</p>
<p>同音频播放一样，<video>使用也相当简单，如下图</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsF61.tmp.jpg" alt="img"> </p>
<p>同样，通过附加属性可以更友好的控制视频的播放</p>
<ul>
<li><p>autoplay 自动播放</p>
</li>
<li><p>controls 是否显示默认播放控件</p>
</li>
<li><p>loop 循环播放</p>
</li>
<li><p>preload 预加载，同时设置了autoplay，此属性将失效</p>
</li>
<li><p>width 设置播放窗口宽度</p>
</li>
<li><p>height 设置播放窗口的高度</p>
</li>
</ul>
<blockquote>
<p>由于版权等原因，不同的浏览器可支持播放的格式是不一样的</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsF62.tmp.jpg" alt="img"></p>
</blockquote>
<p><strong><em>\</em>多浏览器支持的方案**</strong></p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsAC10.tmp.jpg" alt="img"></p>
<h3 id="1-8表格"><a href="#1-8表格" class="headerlink" title="1.8表格"></a>1.8表格</h3><h4 id="1-8-1属性"><a href="#1-8-1属性" class="headerlink" title="1.8.1属性"></a>1.8.1属性</h4><ul>
<li>边框 border=”1” </li>
<li>宽度 width=”500”</li>
<li>高度 height=”300”</li>
<li>单元格间距  cellspacing=”2” 默认值为2</li>
<li>内容到边框的距离  cellpadding=”2” </li>
<li>背景颜色  bgcolor=”red”</li>
<li>表头  <caption>表头文字</caption></li>
<li>align  left  |  center | right</li>
</ul>
<blockquote>
<p>如果align放到tr或td里，内容的对齐方式，如果放到table里，表格的对齐方式</p>
</blockquote>
<h4 id="1-8-2表格的标准结构"><a href="#1-8-2表格的标准结构" class="headerlink" title="1.8.2表格的标准结构"></a>1.8.2表格的标准结构</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span><span class="tag">&lt;/<span class="name">thead</span>&gt;</span>   头部</span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span>   主体</span><br><span class="line"><span class="tag">&lt;<span class="name">tfoot</span>&gt;</span><span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span>  底部</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-9标签语义化"><a href="#1-9标签语义化" class="headerlink" title="1.9标签语义化"></a>1.9标签语义化</h3><ol>
<li><p>标签语义化概念：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</p>
</li>
<li><p>标签语义化意义：</p>
<p>​     1:网页结构合理，好的语义化的网站标准就是去掉样式表文件之后，结构依然很清晰。</p>
<p>​     2:有利于seo:和搜索引擎建立良好沟通，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取；</p>
<p>​     3:方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）</p>
<p>​     4:便于团队开发和维护</p>
</li>
</ol>
<blockquote>
<p>1：尽可能少的使用无语义的标签div和span；</p>
<p>2：在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； </p>
<p>3：不要使用纯样式标签，如：b、font、u等，改用css设置。</p>
<p>4：需要强调的文本，可以包含在strong或者em标签中strong默认样式是加粗（不要用b），em是斜体（不用i）；</p>
</blockquote>
<h2 id="2-HTML面试真题"><a href="#2-HTML面试真题" class="headerlink" title="2.HTML面试真题"></a>2.HTML面试真题</h2><h3 id="doctype的意义是什么？"><a href="#doctype的意义是什么？" class="headerlink" title="doctype的意义是什么？"></a>doctype的意义是什么？</h3><ul>
<li>让浏览器以标准模式渲染</li>
<li>让浏览器知道元素的合法性</li>
</ul>
<h3 id="HTML有什么变化"><a href="#HTML有什么变化" class="headerlink" title="HTML有什么变化"></a>HTML有什么变化</h3><ul>
<li>新的语义化元素</li>
<li>表单增强</li>
<li>新的API(离线、音视频、图形)</li>
</ul>
<h3 id="em和i有什么区别"><a href="#em和i有什么区别" class="headerlink" title="em和i有什么区别"></a>em和i有什么区别</h3><ul>
<li>em是语义化的标签，表强调</li>
<li>i 是纯样式的标签，表斜体</li>
<li>HTML5中i不推荐使用，一般用作图标。</li>
</ul>
<h3 id="语义化的意义是什么"><a href="#语义化的意义是什么" class="headerlink" title="语义化的意义是什么"></a>语义化的意义是什么</h3><ul>
<li>开发者容易理解</li>
<li>机器容易理解结构（搜索、读屏软件）</li>
<li>有助于SEO</li>
<li>semantic microdata  把页面中的元素更加语义化，有利于搜索。</li>
</ul>
<h3 id="哪些元素可以自闭合"><a href="#哪些元素可以自闭合" class="headerlink" title="哪些元素可以自闭合"></a>哪些元素可以自闭合</h3><ul>
<li>表单元素 input</li>
<li>图片 img</li>
<li>br hr</li>
<li>meta link</li>
</ul>
<h3 id="HTML和DOM的关系"><a href="#HTML和DOM的关系" class="headerlink" title="HTML和DOM的关系"></a>HTML和DOM的关系</h3><ul>
<li>HTML是死的。</li>
<li>DOM是由HTML解析而来的，是活的。</li>
<li>JS可以维护DOM</li>
</ul>
<h3 id="property和attribute的区别"><a href="#property和attribute的区别" class="headerlink" title="property和attribute的区别"></a>property和attribute的区别</h3><ul>
<li>attribute是死的</li>
<li>property是活的，可以直接及时的获取数据。</li>
</ul>
<h3 id="from的作用有哪些？"><a href="#from的作用有哪些？" class="headerlink" title="from的作用有哪些？"></a>from的作用有哪些？</h3><ul>
<li>直接提交表单</li>
<li>使用 submit/reset按钮</li>
<li>便于浏览器保存表单</li>
<li>第三方库可以整体取值</li>
<li>第三方库可以进行验证</li>
</ul>
<h3 id="HTML与XHTML-二者的区别"><a href="#HTML与XHTML-二者的区别" class="headerlink" title="HTML与XHTML 二者的区别"></a>HTML与XHTML 二者的区别</h3><p>1、XHTML 元素必须被正确地嵌套。</p>
<p>  错误：<p><span>this is example.</p></span><br>  正确：<p><span>this is example.</span></p></p>
<p>  而html不需要被正确嵌套也不会报错。</p>
<p>2、  XHTML 元素必须被关闭。即使是空标签</br></p>
<p>​     html可以写成<br>3、  XHTML  标签名必须用小写字母。html可以大写。</p>
<p>4、  XHTML 文档必须拥有<html>根元素。</p>
<p>5、  所有的 XHTML 元素必须被嵌套于 <html> 根元素中。</p>
<p>​     而html不是必须的。</p>
<h3 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><ol>
<li><p>HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<ol>
<li>拖拽释放API</li>
<li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li>
<li>音频、视频API</li>
<li>画布（canvas）API</li>
<li>地理API</li>
<li>本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失</li>
<li>sessionStorage的数据在浏览器关闭后自动删除</li>
<li>表单控件，date、time、email、url、search</li>
<li>新的技术 webworker、websocket、Geolocation</li>
</ol>
</li>
<li><p>移除的元素：</p>
<ol>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ol>
</li>
<li><p>支持HTML5新标签：</p>
<ol>
<li>\1. IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 条件注释</span><br><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt; </span></span><br><span class="line"><span class="comment">&lt;script&gt; src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; </span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用html5shiv框架解决ie8以下浏览器不支持html元素的问题[<a href="https://mulingyuer.com/archives/241/]">https://mulingyuer.com/archives/241/]</a></p>
</blockquote>
</li>
<li><p>区分：</p>
<ol>
<li>DOCTYPE声明新增的结构元素、功能元素</li>
</ol>
</li>
</ol>
<h3 id="介绍一下你对浏览器内核的理解"><a href="#介绍一下你对浏览器内核的理解" class="headerlink" title="介绍一下你对浏览器内核的理解"></a>介绍一下你对浏览器内核的理解</h3><p>​     主要分成两部分：渲染引擎和JS引擎<br>​     渲染引擎：负责取得网页的内容（HTML，XML，图像等等），整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或者打印机。浏览器的内核的不同对于网页的语法解释会有不同 ，所以渲染的效果也会不同。所有网页浏览器，电子邮件客户端以及其它需要编辑，显示网络内容的应用程序都需要内核。<br>​      JS引擎：解析和执行JS来实现网页的动态效果。<br>​     最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax数据请求</title>
    <url>/2020/09/10/4.ajax/</url>
    <content><![CDATA[<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><blockquote>
<p>Web 程序最初的目的就是将信息（数据）放到公共的服务器，让所有网络用户都可以通过浏览器访问。  </p>
</blockquote>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200720144300013.png" alt="image-20200720144300013"></p>
<p>A JAX（Asynchronous JavaScript and XML），最早出现在 2005 年的 Google Suggest，是在浏览器端进行网络编程（发送请求、接收响应）的技术方案，它使我们可以通过 JavaScript 直接获取服务端最新的内容而不必重新加载页面。让 Web 更能接近桌面应用的用户体验。</p>
<a id="more"></a>
<blockquote>
<p>网络编程:  用代码的方法去操作网络</p>
</blockquote>
<p>  说白了，<strong>A JAX 就是浏览器提供的一套 API，可以通过 JavaScript 调用，从而实现通过代码控制请求与响应。实现网络编程。</strong>  </p>
<blockquote>
<p>能力不够API凑</p>
</blockquote>
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200720155220237.png" alt="image-20200720155220237" style="zoom:200%;" />



<h3 id="2-快速上手"><a href="#2-快速上手" class="headerlink" title="2.快速上手"></a>2.快速上手</h3><p>**使用 A JAX 的过程可以类比平常我们访问网页过程  **</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 XMLHttpRequest 类型的对象 —— 相当于打开了一个浏览器(发送请求响应)</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">//   2. 打开与一个网址之间的连接 —— 相当于在地址栏输入访问地址</span></span><br><span class="line">xhr.op en(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;./time.php&#x27;</span>)</span><br><span class="line"><span class="comment">// 3. 通过连接发送一次请求 —— 相当于回车或者点击访问发送请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 4. 指定 xhr 状态变化事件处理函数 —— 相当于处理网页呈现后的操作</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 xhr 的 readyState 判断此次请求的响应是否接收完成</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">       <span class="comment">// 通过 xhr 的 responseText 获取到响应的响应体</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在使用AJAX操作页面的时候，不能使用文件协议访问（文件的方式访问）</p>
<p>获取请求头方法：getAllResponseHeader()  //获取所有的请求头。 getResponseHeader(“server”)  // 获取单个</p>
</blockquote>
<h4 id="2-1-readyState"><a href="#2-1-readyState" class="headerlink" title="2.1.readyState"></a>2.1.readyState</h4><p>由于 readystatechange 事件是在 xhr 对象<strong>状态变化</strong>时触发（不单是在得到响应时），也就意味着这个事件会被触发多次，所以我们有必要了解每一个状态值代表的含义：  </p>
<table>
<thead>
<tr>
<th>readyState</th>
<th>状态描述</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>UNSENT</td>
<td>代理（XHR）被创建，但尚未调用 open() 方法。</td>
</tr>
<tr>
<td>1</td>
<td>OPENED</td>
<td>open() 方法已经被调用，建立了一个与服务端特定端口的连接。</td>
</tr>
<tr>
<td>2</td>
<td>HEADERS_RECEIVED</td>
<td>send() 方法已经被调用，并且已经可以获取状态行和响应头。</td>
</tr>
<tr>
<td>3</td>
<td>LOADING</td>
<td>响应体下载中， responseText 属性可能已经包含部分数据。</td>
</tr>
<tr>
<td>4</td>
<td>DONE</td>
<td>响应体下载完成，可以直接使用 responseText 。</td>
</tr>
</tbody></table>
<p><strong>时间轴</strong></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200720160545591.png" alt="image-20200720160545591"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span>(xhr.readyState)&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//OPENED</span></span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//HEADERS_RECEIVED</span></span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//LOADING</span></span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//DONE</span></span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过理解每一个状态值的含义得出一个结论：一般我们都是在 readyState 值为 4 时，执行响应的后续逻辑。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">	<span class="comment">// 后续逻辑......</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于HTML5提供的onload</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.readyState)   <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-遵循HTTP"><a href="#2-2-遵循HTTP" class="headerlink" title="2.2.遵循HTTP"></a>2.2.遵循HTTP</h4><p>本质上 XMLHttpRequest 就是 JavaScript 在 Web 平台中发送 HTTP 请求的手段，所以我们发送出去的请求任然是HTTP 请求，同样符合 HTTP 约定的格式  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置请求报文的请求行</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;./time.php&#x27;</span>)</span><br><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line"><span class="comment">// 设置请求体</span></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">// 获取响应状态码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.status)</span><br><span class="line"><span class="comment">// 获取响应状态描述</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.statusText)</span><br><span class="line"><span class="comment">// 获取响应头信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.getResponseHeader(<span class="string">&#x27;Content‐Type&#x27;</span>)) <span class="comment">// 指定响应头</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.getAllResponseHeaders()) <span class="comment">// 全部响应头</span></span><br><span class="line"><span class="comment">// 获取响应体</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.responseText) <span class="comment">// 文本形式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.responseXML) <span class="comment">// XML 形式，了解即可不用了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>console.log(this.getResponseHeader(‘Content‐Type’)) // 指定响应头<br>console.log(this.getAllResponseHeaders()) // 全部响应头</p>
</blockquote>
<h4 id="2-3-open-参数"><a href="#2-3-open-参数" class="headerlink" title="2.3.open()参数"></a>2.3.open()参数</h4><p><code>xhr.open(method,url,async)</code></p>
<ul>
<li>method：表示方法，<code>GET</code>或者<code>POST</code></li>
<li>url：请求路径</li>
<li>async：默认值为true，表示请求是异步执行的</li>
</ul>
<blockquote>
<p>注意当async=false时，注意send()与onreadystatechange()的顺序。</p>
</blockquote>
<p><strong>发送信息,即请求体</strong></p>
<ul>
<li>GET方法，通过向URL添加信息，传递信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;demo_get2.asp?fname=Bill&amp;lname=Gates&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<ul>
<li>POST方法，可通过send方法，<code>xhr.send(string)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;ajax_test.asp&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xmlhttp.send(<span class="string">&quot;fname=Bill&amp;lname=Gates&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。</p>
<p>详细请看xhr.responseType</p>
</blockquote>
<h4 id="2-4-服务器响应"><a href="#2-4-服务器响应" class="headerlink" title="2.4.服务器响应"></a>2.4.服务器响应</h4><ol>
<li>获取服务服务器的响应<ul>
<li>responseTest 获得字符串形式的响应数据<ul>
<li>如果来自服务器的响应并非 XML，请使用 responseText 属性。</li>
</ul>
</li>
<li>responseXML获得XML形式的相应数据。<ul>
<li>如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，使用 responseXML 属性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-5-responseType"><a href="#2-5-responseType" class="headerlink" title="2.5.responseType"></a>2.5.responseType</h4><blockquote>
<p>他用来用来指定xhr.response的数据类型，存在兼容性的问题。</p>
</blockquote>
<p>responseType支持的格式</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left"><code>xhr.response</code> 数据类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&quot;&quot;</code></td>
<td align="left"><code>String</code>字符串</td>
<td align="left">默认值(在不设置<code>responseType</code>时)</td>
</tr>
<tr>
<td align="left"><code>&quot;text&quot;</code></td>
<td align="left"><code>String</code>字符串</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&quot;document&quot;</code></td>
<td align="left"><code>Document</code>对象</td>
<td align="left">希望返回 <code>XML</code> 格式数据时使用</td>
</tr>
<tr>
<td align="left"><code>&quot;json&quot;</code></td>
<td align="left"><code>javascript</code> 对象</td>
<td align="left">存在兼容性问题，IE10/IE11不支持</td>
</tr>
<tr>
<td align="left"><code>&quot;blob&quot;</code></td>
<td align="left"><code>Blob</code>对象</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&quot;arrayBuffer&quot;</code></td>
<td align="left"><code>ArrayBuffer</code>对象</td>
<td align="left"></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`</span></span><br><span class="line"><span class="comment">//xhr.responseType = &#x27;arrayBuffer&#x27;;</span></span><br><span class="line">xhr.responseType = <span class="string">&#x27;blob&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>xhr.send(data)</code>中data参数的数据类型会影响请求头部<code>content-type</code>的默认值：</p>
<ul>
<li>如果<code>data</code>是 <code>Document</code> 类型，同时也是<code>HTML Document</code>类型，则<code>content-type</code>默认值为<code>text/html;charset=UTF-8</code>;否则为<code>application/xml;charset=UTF-8</code>；</li>
<li>如果<code>data</code>是 <code>DOMString</code> 类型，<code>content-type</code>默认值为<code>text/plain;charset=UTF-8</code>；</li>
<li>如果<code>data</code>是 <code>FormData</code> 类型，<code>content-type</code>默认值为<code>multipart/form-data; boundary=[xxx]</code></li>
<li>如果<code>data</code>是其他类型，则不会设置<code>content-type</code>的默认值</li>
</ul>
<p>当然这些只是<code>content-type</code>的默认值，但如果用<code>xhr.setRequestHeader()</code>手动设置了中<code>content-type</code>的值，以上默认值就会被覆盖。</p>
<blockquote>
<p>在使用xhr.send()方法，应该用try-catch捕获一下错误，不然无法执行后序的代码。</p>
</blockquote>
<h4 id="2-6-响应状态"><a href="#2-6-响应状态" class="headerlink" title="2.6.响应状态"></a>2.6.响应状态</h4><p><strong>响应状态码</strong>：</p>
<ul>
<li>2xx -表示成功处理请求。如200</li>
<li>3xx -需要重新定向，浏览器直接跳转</li>
<li>4xx - 客户端请求错误， 如404</li>
<li>5xx -服务器端错误</li>
</ul>
<p><code>xhr.statusText</code>：获取的是对响应状态的描述。</p>
<h3 id="3-用法"><a href="#3-用法" class="headerlink" title="3.用法"></a>3.用法</h3><h4 id="3-1-GET请求"><a href="#3-1-GET请求" class="headerlink" title="3.1.GET请求"></a>3.1.GET请求</h4><blockquote>
<p>通常在一次 GET 请求过程中，参数传递都是通过 URL 地址中的 ? 参数传递。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// GET 请求传递参数通常使用的是问号传参</span></span><br><span class="line"><span class="comment">// 这里可以在请求地址后面加上参数，从而传递数据到服务端</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;./delete.php?id=1&#x27;</span>)</span><br><span class="line"><span class="comment">// 一般在 GET 请求时无需设置响应体，可以传 null 或者干脆不传</span></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.responseText)</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 一般情况下 URL 传递的都是参数性质的数据，而 POST 一般都是业务数据</span></span><br></pre></td></tr></table></figure>

<p><strong>GET 还是 POST？</strong></p>
<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>
<p>然而，在以下情况中，请使用 POST 请求：</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
<h4 id="3-2-POST请求"><a href="#3-2-POST请求" class="headerlink" title="3.2.POST请求"></a>3.2.POST请求</h4><blockquote>
<p>POST 请求过程中，都是采用请求体承载需要提交的数据。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// open 方法的第一个参数的作用就是设置请求的 method</span></span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;./add.php&#x27;</span>)</span><br><span class="line"><span class="comment">// 设置请求头中的 Content‐Type 为 application/x‐www‐form‐urlencoded</span></span><br><span class="line"><span class="comment">// 标识此次请求的请求体格式为 urlencoded 以便于服务端接收数据</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content‐Type&#x27;</span>, <span class="string">&#x27;application/x‐www‐form‐urlencoded&#x27;</span>)</span><br><span class="line"><span class="comment">// 需要提交到服务端的数据可以通过 send 方法的参数传递</span></span><br><span class="line"><span class="comment">// 格式：key1=value1&amp;key2=value2</span></span><br><span class="line">xhr.send(<span class="string">&#x27;key1=value1&amp;key2=value2&#x27;</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们的请求报文的请求头的<code>Content-Type</code>应该跟随者请求体的格式的变化而变化。</strong></p>
<h4 id="3-3-同步与异步"><a href="#3-3-同步与异步" class="headerlink" title="3.3.同步与异步"></a>3.3.同步与异步</h4><p>生活的举例</p>
<blockquote>
<p>同步：一个人在同一个时刻只能做一件事情，在执行一些耗时的操作（不需要看管）不去做别的事，只是等待 </p>
<p>异步：在执行一些耗时的操作（不需要看管）去做别的事，而不是等待  </p>
</blockquote>
<p><code>xhr.open()</code> 方法第三个参数要求传入的是一个 bool 值，其作用就是设置此次请求是否采用异步方式执行，默认为 true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;before ajax&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 默认第三个参数为 true 意味着采用异步方式执行</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;./time.php&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="comment">// 这里的代码最后执行</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;request done&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after ajax&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果采用同步的方式执行，将async=false；代码会卡死在<code>xhr.send()</code>这一步：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;before ajax&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 同步方式</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;./time.php&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 同步方式 执行需要 先注册事件再调用 send，否则 readystatechange 无法触发</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里的代码最后执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;request done&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after ajax&#x27;</span>)  </span><br></pre></td></tr></table></figure>

<p>当<code>xhr</code>为同步请求时，有如下限制：</p>
<ul>
<li><code>xhr.timeout</code>必须为<code>0</code></li>
<li><code>xhr.withCredentials</code>必须为 <code>false</code></li>
<li><code>xhr.responseType</code>必须为<code>&quot;&quot;</code>（注意置为<code>&quot;text&quot;</code>也不允许）</li>
</ul>
<h4 id="补充：进程与线程"><a href="#补充：进程与线程" class="headerlink" title="补充：进程与线程"></a>补充：进程与线程</h4><p>进程：</p>
<ul>
<li><p>相当于戏场</p>
</li>
<li><p>进行中的应用程序。</p>
</li>
</ul>
<p>线程：</p>
<ul>
<li>线程就是拿着剧本的（代码）去演戏的演员。</li>
<li>CPU最小的执行单元。</li>
</ul>
<p>多线程技术：</p>
<ul>
<li>对于单核的，实现原理，就是内核的切换。</li>
<li>多核就是，每个cpu处理一个线程，直到执行完。</li>
</ul>
<h4 id="3-4-响应数据格式"><a href="#3-4-响应数据格式" class="headerlink" title="3.4.响应数据格式"></a>3.4.响应数据格式</h4><blockquote>
<p>不管服务端是采用XML还是采用JSON，本质上都是将数据返回给客户端。</p>
<p>服务端应该设置一个合理的Content-Type</p>
</blockquote>
<p><strong>XML</strong>：数据描述的一种文件格式，不建议使用。</p>
<p>获取XML中的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在服务器端返回的值中，存在一个`responseXML`它专门用于获取服务端返回的XML数据。</span></span><br><span class="line"><span class="comment">// 操作方式：通过 DOM 的方式操作</span></span><br><span class="line"><span class="comment">// 条件：服务端响应头中的 `content-Type` 必须是 application/xml</span></span><br><span class="line"><span class="built_in">console</span>.log(xhr.responseXML.documentElement.getElementByTagName(<span class="string">&quot;name&quot;</span>))</span><br></pre></td></tr></table></figure>



<p><strong>JSON</strong>：也是一种数据描述手段，类似于 JavaScript 字面量方式 。</p>
<p>服务端采用 JSON 格式返回数据，客户端按照 JSON 格式解析数据。</p>
<ul>
<li>JSON.parse()  –&gt;  json格式</li>
<li>JSON.stringfy() –&gt;字符串</li>
</ul>
<blockquote>
<p>不管是 JSON 也好，还是 XML，只是在 A JAX 请求过程中用到，并不代表它们之间有必然的联系，它们只是数据协议罢了  </p>
</blockquote>
<h4 id="3-5-获取response数据"><a href="#3-5-获取response数据" class="headerlink" title="3.5.获取response数据"></a>3.5.获取response数据</h4><blockquote>
<p><code>xhr提供了3个属性来获取请求返回的数据，分别是：``xhr.response</code>、<code>xhr.responseText</code>、<code>xhr.responseXML</code></p>
</blockquote>
<ul>
<li><code>xhr.response</code><ul>
<li>默认值：空字符串<code>&quot;&quot;</code></li>
<li>当请求完成时，此属性才有正确的值</li>
<li>请求未完成时，此属性的值可能是<code>&quot;&quot;</code>或者 <code>null</code>，具体与 <code>xhr.responseType</code>有关：当<code>responseType</code>为<code>&quot;&quot;</code>或<code>&quot;text&quot;</code>时，值为<code>&quot;&quot;</code>；<code>responseType</code>为其他值时，值为 <code>null</code></li>
</ul>
</li>
<li><code>xhr.responseText</code><ul>
<li>默认值为空字符串<code>&quot;&quot;</code></li>
<li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseText</code>，否则抛错</li>
<li>只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串<code>&quot;&quot;</code>：请求未完成、请求失败</li>
</ul>
</li>
<li><code>xhr.responseXML</code><ul>
<li>默认值为 <code>null</code></li>
<li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>、<code>&quot;document&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseXML</code>，否则抛错</li>
<li>只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为<code>null</code>：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</li>
</ul>
</li>
</ul>
<h4 id="3-6-处理响应数据渲染"><a href="#3-6-处理响应数据渲染" class="headerlink" title="3.6.处理响应数据渲染"></a>3.6.处理响应数据渲染</h4><blockquote>
<p>模板引擎：<br>artTemplate：<a href="https://aui.github.io/art-template/">https://aui.github.io/art-template/</a>  </p>
</blockquote>
<p>模板引擎实际上就是一个 API，模板引擎有很多种，使用方式大同小异，目的为了可以更容易的将数据渲染到HTML中  </p>
<blockquote>
<p>当将script的标签类型改为type=“text/art-template”，在script标签内，innerHTML的内容不会显示,这样方便渲染数据。</p>
</blockquote>
<p><strong>使用：</strong></p>
<ol>
<li><p>引入art-template<code>&lt;script url=&quot;./art-template&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>使用标准语法或者原始语法，在<code>&lt;script type=&quot;text-x-art-template&quot;&gt;&lt;/script&gt;</code>内写模板块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;&lt;/table&gt;</span><br><span class="line">&lt;script id=<span class="string">&quot;tmpl&quot;</span> type=<span class="string">&quot;text-x-art-template&quot;</span>&gt;</span><br><span class="line">    &#123;&#123;each art-data&#125;&#125;</span><br><span class="line">    	&lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&#123;&#123;$value.author&#125;&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&#123;&#123;$value.content&#125;&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&#123;&#123;$value.times&#125;&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>注意：上面de<code>$value</code>获取的是当前被遍历的那个元素，并不是值。</p>
</blockquote>
<ol start="3">
<li>使用ajax异步请求获取数据，给art-data赋值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 默认第三个参数为 true 意味着采用异步方式执行</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;./time.php&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.readyState !=== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">var</span> res = <span class="built_in">JSON</span>.parse(<span class="built_in">this</span>.responseText)</span><br><span class="line">    <span class="comment">// 为模板准备数据</span></span><br><span class="line">    <span class="keyword">var</span> content = &#123;art-data:res.data&#125;</span><br><span class="line">    <span class="comment">// 借助模板引擎的API，渲染数据</span></span><br><span class="line">    <span class="keyword">var</span> html = template(<span class="string">&#x27;html&#x27;</span>,content)</span><br><span class="line">    <span class="comment">// 将数据添加到table标签内</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>).innerHTML = html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-7-设置请求超时"><a href="#3-7-设置请求超时" class="headerlink" title="3.7.设置请求超时"></a>3.7.设置请求超时</h4><blockquote>
<p>如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。<code>XMLHttpRequest</code>提供了<code>timeout</code>属性来允许设置请求的超时时间。</p>
</blockquote>
<p><code>xhr.timeout</code></p>
<ul>
<li>单位为：毫秒</li>
<li>默认值：0，即不设置超时</li>
<li>在<code>send()</code>之后设置。</li>
<li>同步请求时，xhr.timeout的值必须为0。</li>
</ul>
<p><strong>请求的开始与结束的标志</strong></p>
<ul>
<li>当<code>xhr.onloadstart</code>事件触发的时候，也就是你调用<code>xhr.send()</code>方法的时候。请求开始。</li>
<li>当<code>xhr.loadend</code>事件触发的时候。请求结束。</li>
</ul>
<h4 id="3-8-兼容方案"><a href="#3-8-兼容方案" class="headerlink" title="3.8.兼容方案"></a>3.8.兼容方案</h4><p><code>XMLHttpRequest</code>在老版本浏览器（<code>IE5/6</code>）中有兼容问题，可以通过另外一种方式代替  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="built_in">window</span>.XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="3-9-如何获取上传、下载的进度"><a href="#3-9-如何获取上传、下载的进度" class="headerlink" title="3.9.如何获取上传、下载的进度"></a>3.9.如何获取上传、下载的进度</h4><p>在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。<br>我们可以通过<code>onprogress</code>事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的<code>onprogress</code>事件：</p>
<ul>
<li>上传触发的是<code>xhr.upload</code>对象的 <code>onprogress</code>事件</li>
<li>下载触发的是<code>xhr</code>对象的<code>onprogress</code>事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onprogress = updateProgress;</span><br><span class="line">xhr.upload.onprogress = updateProgress;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">      <span class="keyword">var</span> completedPercent = event.loaded / event.total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-简单的封装"><a href="#4-简单的封装" class="headerlink" title="4.简单的封装"></a>4.简单的封装</h3><blockquote>
<p>函数就可以理解为一个想要做的事情，函数体中约定了这件事情做的过程，直到调用时才开始工作。<br>将函数作为参数传递就像是将一个事情交给别人，这就是委托的概念  </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        *method 请求方法</span></span><br><span class="line"><span class="comment">        * url 请求地址</span></span><br><span class="line"><span class="comment">        * params 请求参数</span></span><br><span class="line"><span class="comment">        * done 请求完成过后需要做的事情（委托/回调）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">method,url,params,done</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> data = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">            <span class="comment">// 对传入的params对象进行处理</span></span><br><span class="line">            <span class="keyword">let</span> pairs = []</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">                pairs.push(key +<span class="string">&#x27;=&#x27;</span>+params[key])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> queryings = pairs.join(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">            <span class="comment">// 判断method,传递不同的请求体</span></span><br><span class="line">            <span class="keyword">if</span> (method.toUpperCase() === <span class="string">&quot;POST&quot;</span>) &#123;</span><br><span class="line">                xhr.setRequestHeader(<span class="string">&quot;content-Type&quot;</span>,<span class="string">&quot;application/x-www-urlencoded&quot;</span>)</span><br><span class="line">                data = queryings</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (method.toUpperCase() === <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">                url = url+<span class="string">&quot;?&quot;</span>+queryings</span><br><span class="line">            &#125;</span><br><span class="line">            xhr.open(method,url)</span><br><span class="line">            xhr.send(data)</span><br><span class="line">            xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    done(<span class="built_in">JSON</span>.parse(<span class="built_in">this</span>.responseText))</span><br><span class="line">                &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">                    done(<span class="built_in">this</span>.responseText)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用函数</span></span><br><span class="line">        ajax(get,<span class="string">&quot;./test.php&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            alert(res)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>



<h3 id="5-jQuery中的ajax"><a href="#5-jQuery中的ajax" class="headerlink" title="5.jQuery中的ajax"></a>5.<code>jQuery</code>中的<code>ajax</code></h3><h4 id="5-1-ajax"><a href="#5-1-ajax" class="headerlink" title="5.1.$ajax()"></a>5.1.<code>$ajax()</code></h4><ol>
<li>引入<code>jQuery</code>文件</li>
<li><strong>使用<code>$.ajax()</code></strong></li>
<li>基本的参数<ul>
<li><code>url</code>：请求地址</li>
<li>type：请求方法，默认为 get</li>
<li><code>dataType</code>：服务端响应数据类型  </li>
<li><code>contentType</code>：请求体内容类型，默认 <code>application/x-www-form-urlencoded</code></li>
<li>data：需要传递到服务端的数据，如果 GET 则通过 URL 传递，如果 POST 则通过请求体传递 </li>
<li>timeout：请求超时时间 </li>
<li><code>beforeSend</code>：请求发起之前触发（open，send之前）</li>
<li>success：请求成功之后触发（响应状态码 200） </li>
<li>error：请求失败触发 </li>
<li>complete：请求完成触发（即不管成功与否，都会触发）</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url: <span class="string">&#x27;./get.php&#x27;</span>,</span><br><span class="line">type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">data: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">beforeSend: <span class="function"><span class="keyword">function</span> (<span class="params">xhr</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;before send&#x27;</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 这里的data会根据服务端响应的content-Type 自动转化为对象</span></span><br><span class="line"><span class="comment">// success 请求成功之后（状态码为200）才会执行</span></span><br><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,</span><br><span class="line">error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;,</span><br><span class="line">complete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;request completed&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="5-2-get"><a href="#5-2-get" class="headerlink" title="5.2 $.get"></a>5.2 <code>$.get</code></h4><p>GET请求快捷方法</p>
<p><code>jQuery.get( url [, data ] [, success(data, textStatus, jqXHR) ] [, dataType ] )</code></p>
<ul>
<li>url:一个包含发送请求的URL字符串</li>
<li>data:发送给服务器的字符串或Key/value键值对。</li>
<li>success:当请求成功后执行的回调函数。</li>
<li>dataType:从服务器返回的预期的数据类型（xml, json, script, 或 html）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">&quot;test.php&quot;</span>,</span><br><span class="line">   <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">     $(<span class="string">&#x27;body&#x27;</span>).append( <span class="string">&quot;Name: &quot;</span> + data.name ) <span class="comment">// John</span></span><br><span class="line">              .append( <span class="string">&quot;Time: &quot;</span> + data.time ); <span class="comment">//  2pm</span></span><br><span class="line">   &#125;, <span class="string">&quot;json&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过<code>$.get()</code>方法返回的jQuery XHR对象，或“jqXHR，”实现了 Promise 接口，使它拥有 Promise 的所有属性，方法和行为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.post(<span class="string">&quot;example.php&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     alert(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   .success(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">&quot;second success&quot;</span>); &#125;)</span><br><span class="line">   .error(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">&quot;error&quot;</span>); &#125;)</span><br><span class="line">   .complete(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">&quot;complete&quot;</span>); &#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5-3-post"><a href="#5-3-post" class="headerlink" title="5.3.$.post"></a>5.3.<code>$.post</code></h4><p>POST请求快捷方法</p>
<p><code>jQuery.post( url [, data ] [, success(data, textStatus, jqXHR) ] [, dataType ] )</code></p>
<h4 id="5-4-getJSON"><a href="#5-4-getJSON" class="headerlink" title="5.4.$.getJSON()"></a>5.4.<code>$.getJSON()</code></h4><p>使用一个HTTP GET请求从服务器加载<code>JSON</code>编码的数据。</p>
<p><code>jQuery.getJSON( url [, data ] [, success(data, textStatus, jqXHR) ] )</code></p>
<ul>
<li>url:一个包含发送请求的URL字符串</li>
<li>data:发送给服务器的字符串或Key/value键值对</li>
<li><strong>success(data, textStatus, jqXHR)</strong>:当请求成功后执行的回调函数。</li>
</ul>
<h4 id="5-5-load"><a href="#5-5-load" class="headerlink" title="5.5.$.load()"></a>5.5.<code>$.load()</code></h4><p>从服务器载入数据并且将返回的 HTML 代码并插入至 匹配的元素 中。</p>
<p><code>.load(url,data,complete)</code></p>
<ul>
<li>url服务器地址</li>
<li>data,向服务器发送请求的Key/value参数，例如{name:””,age:23}</li>
<li>complete，请求成功回调函数</li>
</ul>
<p><strong>Request Method（请求方法）</strong></p>
<p>默认使用 GET 方式 ， 如果data参数提供一个对象，那么使用 POST 方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;我是原页面内容&lt;/h2&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./jquery-3.5.1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 这里参数是$，表示jquery是局部作用域</span></span><br><span class="line">        $(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">            $(<span class="string">&quot;#box&quot;</span>).load(<span class="string">&quot;yemian.html h3&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个空格后面是一个jQuery选择器，返回的内容中匹配改选择器的内容将被载人到页面中。</p>
</blockquote>
<h4 id="5-6-getScript"><a href="#5-6-getScript" class="headerlink" title="5.6.$.getScript"></a>5.6.<code>$.getScript</code></h4><p><code>jQuery.getScript( url [, success(script, textStatus, jqXHR) ] )</code><strong>使用一个HTTP GET请求从服务器加载并执行一个 JavaScript 文件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.getScript(<span class="string">&quot;ajax/test.js&quot;</span>)</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params">script, textStatus</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( textStatus );</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params">jqxhr, settings, exception</span>) </span>&#123;</span><br><span class="line">  $( <span class="string">&quot;div.log&quot;</span> ).text( <span class="string">&quot;Triggered ajaxError handler.&quot;</span> );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>从jQuery 1.5开始，可以用<a href="https://www.jquery123.com/deferred.fail"><code>.fail()</code></a>来处理错误,不在依托全局<code>.ajaxError（）</code>事件</li>
<li>默认情况下，<code>$.getScript()</code> cache选项被设置为 <code>false</code>。可以使用 <a href="https://www.jquery123.com/jquery.ajaxsetup"><code>$.ajaxSetup()</code></a>设置cache=true</li>
</ol>
</blockquote>
<h4 id="5-7-全局事件"><a href="#5-7-全局事件" class="headerlink" title="5.7.全局事件"></a>5.7.全局事件</h4><table>
<thead>
<tr>
<th>事件</th>
<th>参数</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>.ajaxStart()</code></td>
<td>**handler()**被调用的函数</td>
<td><em>在AJAX 请求刚开始时执行一个处理函数</em></td>
<td><code>$(document).ajaxStart(function()&#123;&#125;</code></td>
</tr>
<tr>
<td><code>.ajaxStop()</code></td>
<td>**handler()**被调用的函数</td>
<td><em>在AJAX 请求完成时执行一个处理函数</em></td>
<td><code>$(document).ajaxStop(function() &#123;$( &quot;#loading&quot; ).hide();&#125;);</code></td>
</tr>
<tr>
<td><code>.ajaxError()</code></td>
<td>**handler(event, jqXHR, ajaxSettings, thrownError)**被调用的函数</td>
<td><em>Ajax请求出错时注册一个回调处理函数</em></td>
<td><code>$(document).ajaxError(function() &#123;$( &quot;div.log&quot; ).text(&quot;Triggered ajaxError handler.&quot; );&#125;);</code></td>
</tr>
<tr>
<td><code>.ajaxComplete()</code></td>
<td>**handler(event, XMLHttpRequest, ajaxOptions)**被调用的函数</td>
<td><em>当Ajax请求完成后注册一个回调函数。</em></td>
<td><code>$(document).ajaxComplete(function(event,request, settings)&#123;$( &quot;#msg&quot;).append(&quot;&lt;li&gt;Request Complete.&lt;/li&gt;&quot;);&#125;);</code></td>
</tr>
<tr>
<td><code>.ajaxSuccess()</code></td>
<td><strong>handler(event, XMLHttpRequest, ajaxOptions)</strong></td>
<td><em>绑定一个函数当 Ajax 请求成功完成时执行</em></td>
<td><code>$(document).ajaxSuccess(function(event, request, settings) &#123;$( &quot;#msg&quot; ).append( &quot;&lt;li&gt;Successful Request!&lt;/li&gt;&quot; );&#125;);</code></td>
</tr>
<tr>
<td><code>.ajaxSend()</code></td>
<td><strong>handler(event, jqXHR, ajaxOptions)</strong></td>
<td><em>在Ajax请求发送之前绑定一个要执行的函数</em></td>
<td><code>$(document).ajaxSend(function(event, request, settings) &#123;$( &quot;#msg&quot; ).append( &quot;&lt;li&gt;Starting request at&quot; +settings.url+&quot;&lt;/li&gt;&quot;);&#125;);</code></td>
</tr>
</tbody></table>
<h3 id="6-跨域"><a href="#6-跨域" class="headerlink" title="6.跨域"></a>6.跨域</h3><h4 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1.概念"></a>6.1.概念</h4><p><strong>同源策略</strong>是浏览器的一种安全策略，所谓同源是指<strong>域名，协议，端口</strong>完全相同，<em>只有同源的地址才可以相互通过<code>AJAX</code> 的方式请求。</em><br>同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为跨域请求 。</p>
<p>什么是同源？例如：<a href="http://www.example.com/detail.html">http://www.example.com/detail.html</a> 与一下地址对比  </p>
<table>
<thead>
<tr>
<th>对比地址</th>
<th>是否同源</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://api.example.com/detail.html">http://api.example.com/detail.html</a></td>
<td>不同源</td>
<td>域名不同</td>
</tr>
<tr>
<td><a href="https://www.example.com/detail.html">https://www.example.com/detail.html</a></td>
<td>不同源</td>
<td>协议不同</td>
</tr>
<tr>
<td><a href="http://www.example.com:8080/detail.html">http://www.example.com:8080/detail.html</a></td>
<td>不同源</td>
<td>端口不同</td>
</tr>
<tr>
<td><a href="http://api.example.com:8080/detail.html">http://api.example.com:8080/detail.html</a></td>
<td>不同源</td>
<td>域名、端口不同</td>
</tr>
<tr>
<td><a href="https://api.example.com/detail.html">https://api.example.com/detail.html</a></td>
<td>不同源</td>
<td>协议、域名不同</td>
</tr>
<tr>
<td><a href="https://www.example.com:8080/detail.html">https://www.example.com:8080/detail.html</a></td>
<td>不同源</td>
<td>端口、协议不同</td>
</tr>
<tr>
<td><a href="http://www.example.com/other.html">http://www.example.com/other.html</a></td>
<td>同源</td>
<td>只是目录不同</td>
</tr>
</tbody></table>
<blockquote>
<p>在同源策略下，只能同源地址ajax才能相互访问，它只能发送请求，不能拿到服务端的数据。这与ajax的原理违背，只能发送请求却无法获取服务端的响应。</p>
</blockquote>
<p>可以发送请求的标签：<code>img link script iframe</code></p>
<p><strong>1.img</strong></p>
<p>可以发送不同源地址之间的请求，无法拿到响应结果。</p>
<p><strong>2.link</strong></p>
<p> 真正的定义：链入一个文档，通过 rel 属性申明链入的文档与当前文档之间的关系。</p>
<p><strong>3.script</strong></p>
<p>可以发送不同源地址之间的请求，无法拿到响应结果。</p>
<p>虽然script标签无法获取到响应结果，但是我们可以通过与服务端的配合，让服务端返回一段JS，作用是调用我们事先定义好的一个函数，从而将服务端想要给客服端发送去的数据发送给客户端。<strong>这就是<code>JSONP</code>原理</strong>。</p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSON with Padding，是一种借助于 script 标签发送跨域请求的技巧。<br><strong>原理</strong>：就是在客户端借助 script 标签请求服务端的一个动态网页（php 文件），服务端的这个动态网页返回一段带有函数调用的 JavaScript 全局函数调用的脚本，将原本需要返回给客户端的数据传递进去。  </p>
<p>以后绝大多数情况都是采用 JSONP 的手段完成不同源地址之间的跨域请求<br>客户端 <a href="http://www.zce.me/users-list.html">http://www.zce.me/users-list.html</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://api.zce.me/users.php?callback=foo&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>服务端 <a href="http://api.zce.me/users.php?callback=foo">http://api.zce.me/users.php?callback=foo</a> 返回的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo([<span class="string">&#x27;我&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;你&#x27;</span>, <span class="string">&#x27;原&#x27;</span>, <span class="string">&#x27;本&#x27;</span>, <span class="string">&#x27;需&#x27;</span>, <span class="string">&#x27;要&#x27;</span>, <span class="string">&#x27;的&#x27;</span>, <span class="string">&#x27;数&#x27;</span>, <span class="string">&#x27;据&#x27;</span>])</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：由于 XMLHttpRequest 无法发送不同源地址之间的跨域请求，所以我们必须要另寻他法，script 这种方案就是我们最终选择的方式，我们把这种方式称之为 JSONP，如果你不了解原理，先记住怎么用，多用一段时间再来看原理  </p>
</blockquote>
<p><strong>问题：</strong></p>
<ol>
<li>JSONP 需要服务端配合，服务端按照客户端的要求返回一段 JavaScript 调用客户端的函数</li>
<li>只能发送 GET 请求  </li>
</ol>
<blockquote>
<p>注意：JSONP 用的是 script 标签，更 A JAX 提供的 XMLHttpRequest 没有任何关系！！！  </p>
</blockquote>
<p><code>jQuery 中使用 JSONP 就是将 dataType 设置为 jsonp  </code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">&quot;http://localhost/jsonp/server.php&quot;</span>,</span><br><span class="line">    type:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    dataType:jsonp,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先我们创建一个api接口 */</span></span><br><span class="line"><span class="comment">/* 我们创建的地址是 http://localhost:51355/home/getnametwo?name=czklove */</span></span><br><span class="line"><span class="comment">/* 我们使用jsonp的方式去请求以下这个接口 */</span></span><br><span class="line"><span class="comment">/* 第一步我们创建一个script标签 */</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> scrpt = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    <span class="comment">/* 第二步设置sricpt标签的src属性*/</span> </span><br><span class="line">    scrpt.src = <span class="string">&#x27;http://localhost:51355/home/getnametwo?name=czklove&amp;callback=callback&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(scrpt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* callback为接受返回数据的回到函数 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务端如果使用php,应该将它的请求头的类型，改为js对象，并且定义一个函数。</span></span><br></pre></td></tr></table></figure>



<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>Cross Origin Resource Share，跨域资源共享  ,IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许远端访问</span></span><br><span class="line">header(<span class="string">&#x27;Access‐Control‐Allow‐Origin: *&#x27;</span>); <span class="comment">// 通配符</span></span><br><span class="line">header(<span class="string">&#x27;Access‐Control‐Allow‐Origin: http://localhost/jsonp&#x27;</span>)  <span class="comment">// 也可以是指定域名</span></span><br></pre></td></tr></table></figure>

<p>这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个 <code>AccessControl-Allow-Origin</code> 的响应头，表示这个资源是否允许指定域请求。  </p>
<p><strong>非简单模式下：</strong></p>
<p>非简单请求相对于简单请求，浏览器会多一次预检的功能，如果浏览器检测大本次请求不是简单请求，那么就去浏览器上去拿三个信息</p>
<p>Access-Control-Allow-Origin，Access-Control-Allow-Methods，Access-Control-Allow-Headers，分别是请求源，请求方式，请求头部的一些基本信息，三个都符合要求那么就能像浏览器发送请求，就和正常的简单请求一样了。</p>
<h4 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h4><p>使用<strong>postMessage跨域</strong> 实现跨域 h5新提出来的一个api,支持ie8+,chrome 这种方式不太像是跨域请求数据的方式，而是跨页面传送数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;a 页面&lt;/h1&gt;</span><br><span class="line">    &lt;iframe src=<span class="string">&quot;http://localhost:8082/b.html&quot;</span> id=<span class="string">&quot;iframea&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/* a 页面使用postmessage 向 iframe 的b页面传送数据 */</span></span><br><span class="line"><span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframea&#x27;</span>)</span><br><span class="line"></span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = &#123;<span class="attr">name</span>: <span class="string">&#x27;czklove&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">/* 向 http://localhost跨域传送数据*/</span></span><br><span class="line">    iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(message),<span class="string">&#x27;http://localhost:8082/&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;message-----&#x27;</span> + <span class="built_in">JSON</span>.parse(e.data).name)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>b页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;zheshi第二个页面&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/* 接收数据 */</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;b已经接收到了数据&#x27;</span>+message.name)</span><br><span class="line">        <span class="keyword">if</span>(message) &#123;</span><br><span class="line">            message.name=<span class="string">&#x27;ljkjkjk&#x27;</span>;</span><br><span class="line">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(message),<span class="string">&#x27;http://localhost:8081&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="literal">false</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>js库之jQuery</title>
    <url>/2020/09/10/6.jQuery/</url>
    <content><![CDATA[<h2 id="jQuery基本概念"><a href="#jQuery基本概念" class="headerlink" title="jQuery基本概念"></a>jQuery基本概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>jquery是一个快速、简洁的JavaScript框架，是继Prototype之后的又一个优秀的JavaScript代码库。</p>
<p>jQuery设计的宗旨：（更少的代码做更多的事）具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。</p>
<a id="more"></a>
<p>语言特点：</p>
<ul>
<li><strong>快速获取文档元素</strong>：jQuery的选择机制构建于Css的选择器，它提供了快速查询DOM文档中元素的能力，而且大大强化了JavaScript中获取页面元素的方式。</li>
<li><strong>提供漂亮的页面动态效果</strong>：jQuery中内置了一系列的动画效果，可以开发出非常漂亮的网页，许多网站都使用jQuery的内置的效果，比如淡入淡出、元素移除等动态特效</li>
<li><strong>创建AJAX无刷新网页</strong>：使用AJAX特效后，可以对页面进行局部刷新，提供动态的效果</li>
<li><strong>提供对JavaScript语言的增强</strong>：jQuery提供了对基本JavaScript结构的增强，比如元素迭代和数组处理等操作。</li>
<li><strong>增强的事件处理</strong>：jQuery提供了各种页面事件，它可以避免程序员在HTML中添加太多的事件处理代码，最重要的是，它的<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=71661686&ss_c=ssc.citiao.link">事件处理器</a>消除了各种浏览器兼容性问题。</li>
<li><strong>更改网页内容</strong>：jQuery可以修改网页中的内容，比如更改网页的文本、插入或者翻转网页图像，jQuery简化了原本使用JavaScript代码需要处理的方式。</li>
</ul>
<p>jQuery的模块可以分为3部分：入口模块、底层支持模块和功能模块。</p>
<h3 id="入口函数："><a href="#入口函数：" class="headerlink" title="入口函数："></a>入口函数：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口函数方式1</span></span><br><span class="line"> $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注册事件，把on去掉</span></span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 隐式迭代</span></span><br><span class="line">        $(<span class="string">&quot;div&quot;</span>).show(<span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>js的入口函数执行要比jQuery的入口函数执行要晚一些；</p>
<p>jq的入口函数会等待页面的加载完成才执行，但是不会等待图片的加载。反之，js的入口函数会等待页面加载完，图片加载完才开始执行。</p>
</blockquote>
<h3 id="jq对象与dom对象的区别"><a href="#jq对象与dom对象的区别" class="headerlink" title="jq对象与dom对象的区别"></a>jq对象与dom对象的区别</h3><p>DOM对象（js对象）：使用js的方式获取到的元素就是js对象（DOM对象）</p>
<p>jq对象：使用jq获取到的元素就是jq对象。</p>
<blockquote>
<p>js对象不能调用jq对象的方法</p>
<p>jq对象其实就是js对象的一个集合，是个伪数组，里面存放了一大堆的js对象</p>
</blockquote>
<ul>
<li>DOM对象是不可以调用jq对象的方法，他们不是同一个对象，要想实行DOM调用jq,需要先将DOM对象转换为JQ对象。<ul>
<li><code>$(要转换的DOM对象)</code></li>
</ul>
</li>
<li>同样，将jQ对象转换为DOM对象，就是将对应属性取出来即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(“li”);</span><br><span class="line"><span class="comment">//第一种方法（推荐使用）</span></span><br><span class="line">$li[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line">$li.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="符号的实质"><a href="#符号的实质" class="headerlink" title="$符号的实质"></a>$符号的实质</h3><p>$其实就是一个函数，使用<code>$</code>的时候，记得跟小括号。</p>
<p><code>jQuery===$  // true</code></p>
<p>参数不同，功能不同。</p>
<ul>
<li>参数是function，是入口函数</li>
<li>参数是DOM元素，将DOM转换为jq对象</li>
<li>参数是字符串（“.tt||#dd||div”），用来找对象。</li>
</ul>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>ID选择器</td>
<td>$(“#id”);</td>
<td align="left">获取指定ID的元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>$(“.class”);</td>
<td align="left">获取同一类class的元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td>$(“div”);</td>
<td align="left">获取同一类标签的所有元素</td>
</tr>
<tr>
<td>并集选择器</td>
<td>$(“div,p,li”);</td>
<td align="left">使用逗号分隔，只要符合条件之一就可。</td>
</tr>
<tr>
<td>交集选择器</td>
<td>$(“div.redClass”);</td>
<td align="left">获取class为redClass的div元素（两个都存在）</td>
</tr>
</tbody></table>
<blockquote>
<p>交集选择器就是两个选择器放在一起，即两个都要满足才行。</p>
</blockquote>
<h4 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>子代选择器</td>
<td>$(“ul&gt;li”);</td>
<td align="left">使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>$(“ul li”);</td>
<td align="left">使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td>
</tr>
</tbody></table>
<h4 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>:eq（index）</td>
<td>$(“li:eq(2)”).css(“color”, ”red”);</td>
<td align="left">获取到的li元素中，选择索引号为2的元素，索引号index从0开始。</td>
</tr>
<tr>
<td>:odd</td>
<td>$(“li:odd”).css(“color”, ”red”);</td>
<td align="left">获取到的li元素中，选择索引号为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$(“li:even”).css(“color”, ”red”);</td>
<td align="left">获取到的li元素中，选择索引号为偶数的元素</td>
</tr>
<tr>
<td>:nth-child()</td>
<td>$(“ul li:nth-child(2)”)</td>
<td align="left">获取<em>每个匹配的 ul 中的第二个 li</em></td>
</tr>
<tr>
<td>:first-child()</td>
<td>$(“div span:first-child”)</td>
<td align="left">获取<em>给每个匹配的 div 中查找第一个 span</em></td>
</tr>
<tr>
<td>:nth-last-child()</td>
<td>$(“ul li:nth-last-child(2)”)</td>
<td align="left">获取<em>每个匹配的ul中查找倒数第二个li</em></td>
</tr>
<tr>
<td>:parent</td>
<td>$(“td:parent”)</td>
<td align="left"><em>查找含有子元素的 td 元素，包括含有文本的 td</em></td>
</tr>
</tbody></table>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>[attribute=’value’]</td>
<td>$(‘input[value=”Hot Fuzz”]’)</td>
<td align="left">获取input标签，并且它的值为“Hot Fuzz”</td>
</tr>
<tr>
<td>[attribute*=’value’]</td>
<td>$(‘input[name*=”man”]’)</td>
<td align="left"><em>查找所有 input 的 name 属性中带有 ‘man’ 的元素</em></td>
</tr>
<tr>
<td>[attribute~=’value’]</td>
<td>$(‘input[name~=”man”]’)</td>
<td align="left"><em>查找所有属性中含有 ‘man’ 这个<strong>单词</strong>的</em>元素</td>
</tr>
<tr>
<td>[attribute|=’value’]</td>
<td>$(‘a[hreflang|=”en”]’)</td>
<td align="left"><em>查找hreflang属性值是en</em>的a元素</td>
</tr>
</tbody></table>
<h4 id="筛选选择器-方法"><a href="#筛选选择器-方法" class="headerlink" title="筛选选择器(方法)"></a>筛选选择器(方法)</h4><blockquote>
<p>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>children(selector)</td>
<td>$(“ul”).children(“li”)</td>
<td align="left">相当于$(“ul&gt;li”)，子类选择器</td>
</tr>
<tr>
<td>find(selector)</td>
<td>$(“ul”).find(“li”);</td>
<td align="left">相当于$(“ul li”),后代选择器</td>
</tr>
<tr>
<td>siblings(selector)</td>
<td>$(“#first”).siblings(“li”);</td>
<td align="left">查找兄弟节点，不包括自己本身。</td>
</tr>
<tr>
<td>parent()</td>
<td>$(“#first”).parent();</td>
<td align="left">查找父亲</td>
</tr>
<tr>
<td>eq(index)</td>
<td>$(“li”).eq(2);</td>
<td align="left">相当于$(“li:eq(2)”),index从0开始</td>
</tr>
<tr>
<td>next()</td>
<td>$(“li”).next()</td>
<td align="left">找下一个兄弟</td>
</tr>
<tr>
<td>prev()</td>
<td>$(“li”).prev()</td>
<td align="left">找上一次兄弟</td>
</tr>
<tr>
<td>prevAll()</td>
<td>$(‘li.third-item’).prevAll()</td>
<td align="left">找当前元素之前的所有元素</td>
</tr>
</tbody></table>
<h4 id="index方法"><a href="#index方法" class="headerlink" title="index方法"></a>index方法</h4><p><strong>作用</strong>：获取元素下标（注意：它是一个方法，要加()）</p>
<p><strong>返回值为</strong>：当前元素所在的所有兄弟元素里面的索引。</p>
<h3 id="区分jQuery和JavaScript"><a href="#区分jQuery和JavaScript" class="headerlink" title="区分jQuery和JavaScript"></a>区分jQuery和JavaScript</h3><p>JavaScript是一门编程语言，jquery是用JavaScript实现的一个JavaScript库，目的是简化我们的开发。（联想记忆：不能扛着洗衣机去出差）</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps7EE9.tmp.jpg" alt="img"></p>
<h3 id="css操作"><a href="#css操作" class="headerlink" title="css操作"></a>css操作</h3><p>功能：设置或者修改样式，操作的是style属性。</p>
<ul>
<li>设置单个样式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name：需要设置的样式名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//value：对应的样式值</span></span><br><span class="line"></span><br><span class="line">css(name, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用案例</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#one&quot;</span>).css(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;gray&quot;</span>);<span class="comment">//将背景色修改为灰色</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置多个样式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数是一个对象，对象中包含了需要设置的样式名和样式值</span></span><br><span class="line"></span><br><span class="line">css(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用案例</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#one&quot;</span>).css(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;background&quot;</span>:<span class="string">&quot;gray&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;width&quot;</span>:<span class="string">&quot;400px&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;height&quot;</span>:<span class="string">&quot;200px&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取样式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name:需要获取的样式名称</span></span><br><span class="line"></span><br><span class="line">css(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：获取样式操作只会返回第一个元素对应的样式值。</p>
</blockquote>
<p><strong>隐式迭代</strong>：</p>
<ol>
<li><p>设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值</p>
</li>
<li><p>获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。</p>
</li>
</ol>
<h3 id="class操作"><a href="#class操作" class="headerlink" title="class操作"></a>class操作</h3><ul>
<li>添加样式类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name：需要添加的样式类名，注意参数不要带点.</span></span><br><span class="line"></span><br><span class="line">addClass(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子,给所有的div添加one的样式。</span></span><br><span class="line"></span><br><span class="line">$(“div”).addClass(“one”);</span><br></pre></td></tr></table></figure>

<ul>
<li>移除样式类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name:需要移除的样式类名</span></span><br><span class="line"></span><br><span class="line">removeClass(“name”);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子，移除div中one的样式类名</span></span><br><span class="line"></span><br><span class="line">$(“div”).removeClass(“one”);</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否有样式类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name:用于判断的样式类名，返回值为true false</span></span><br><span class="line"></span><br><span class="line">hasClass(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子，判断第一个div是否有one的样式类</span></span><br><span class="line"></span><br><span class="line">$(“div”).hasClass(“one”);</span><br></pre></td></tr></table></figure>

<ul>
<li>切换样式类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。</span></span><br><span class="line"></span><br><span class="line">toggleClass(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"></span><br><span class="line">$(“div”).toggleClass(“one”);</span><br></pre></td></tr></table></figure>

<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p>attr方法操作标签内的属性（获取和设置属性）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置单个</span></span><br><span class="line">$(<span class="string">&quot;img&quot;</span>).attr(<span class="string">&quot;alt&quot;</span>,<span class="string">&quot;修改了&quot;</span>)</span><br><span class="line"><span class="comment">// 设置多个属性</span></span><br><span class="line">$(<span class="string">&quot;img&quot;</span>).attr(&#123;</span><br><span class="line">    alt:<span class="string">&quot;dd&quot;</span>,</span><br><span class="line">    title:<span class="string">&quot;dddd&quot;</span>,</span><br><span class="line">    aa:<span class="string">&quot;ddf&quot;</span>  <span class="comment">// 自定义属性</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 jQuery的 <code>.attr()</code> 方法得到了一个元素的属性值主要有两个好处：</p>
<ol>
<li><strong>方便</strong>：它可以直接被jQuery对象访问并且链式调用其他jQuery方法。</li>
<li><strong>浏览器兼容</strong>：一些属性在不同浏览器中得到不同的值。 甚至在同一个浏览器的不同版本中。 <code>.attr()</code> 方法减少了兼容性问题。</li>
</ol>
<p>prop方法：对于布尔类型的属性，<code>checked</code>, <code>selected</code>, 或 <code>disabled</code>，只能用prop</p>
<blockquote>
<p><strong>jQuery 1.6之前</strong> ，<a href="https://www.jquery123.com/attr"><code>.attr()</code></a>方法在取某些 attribute 的值时，会返回 property 的值，这就导致了结果的不一致。<strong>从 jQuery 1.6 开始</strong>， <code>.prop()</code>方法 方法返回 property 的值,而 <code>.attr()</code> 方法返回 attributes 的值。</p>
<p><strong>若要检索和更改DOM属性,比如元素的<code>checked</code>, <code>selected</code>, 或 <code>disabled</code>状态，请使用<a href="https://www.jquery123.com/prop">.prop()</a>方法。</strong></p>
</blockquote>
<p>removeAttr(name):移除某个属性</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><h4 id="三组基础的动画"><a href="#三组基础的动画" class="headerlink" title="三组基础的动画"></a>三组基础的动画</h4><ol>
<li><p>show()和hide()</p>
<p><strong>参数：</strong></p>
<ol>
<li>数字形式：表示动画执行的时间。</li>
<li>字符串形式：“fast”、”slow”、“normal”</li>
<li>参数二回调函数：在动画执行完毕后，函数执行</li>
</ol>
</li>
</ol>
<blockquote>
<p>使用时不建议传参数，因为产生的动画不美观。</p>
</blockquote>
<ol start="2">
<li><p>slideUp()和slideDown()  滑入滑出</p>
<p><strong>参数：</strong></p>
<ol>
<li>不传参，默认值normal</li>
<li>毫秒值</li>
<li>字符串形式：“fast”、”slow”、“normal”</li>
<li>也存在回调函数</li>
</ol>
<p>**slideToggle():**如果滑动动画是显示，则就切换为隐藏。</p>
</li>
<li><p>fadeIn()和fadeOut()   淡入淡出</p>
<p><strong>参数：</strong></p>
<ol>
<li>不传参，默认值normal</li>
<li>毫秒值</li>
<li>字符串形式：“fast（相当于600毫秒）”、”slow（200ms）”、“normal（400ms）”</li>
<li>也存在回调函数</li>
</ol>
<p><strong>fadeToggle()    淡入淡出切换</strong></p>
<p><strong>fadeTo(duration, opacity [, complete ])</strong>   调整匹配元素的透明度</p>
<p>​    1. duration 一个字符串或者数字决定动画将运行多久</p>
<pre><code>2. opacity 0和1之间的数字表示目标元素的不透明度

 3. 在动画完成时执行的函数</code></pre>
</li>
</ol>
<h4 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h4><p><strong>animate(properties [, duration ] [, easing ] [, complete ])</strong></p>
<p>参数：</p>
<ol>
<li><p>对象，里面可以传需要动画的样式，例如：<code>&#123;left:800&#125;</code></p>
<ol start="2">
<li>speed 动画执行的时间</li>
<li>动画执行的效果，默认值<code>swing</code>，另外一个值为<code>linner</code></li>
<li>回调函数</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.box&quot;</span>).animate(&#123;<span class="attr">left</span>:<span class="number">800</span>&#125;,<span class="number">2000</span>,linner,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;hahahah&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="动画队列与暂停"><a href="#动画队列与暂停" class="headerlink" title="动画队列与暂停"></a>动画队列与暂停</h4><p>动画队列：在jquery动画中，他会把未执行的动画放在一个统一的队列当中，按照顺序，一个挨着一个执行。</p>
<p>动画队列的缺陷：触发动画执行的过快，在取消执行时，动画还在执行。</p>
<p>解决方法：使用stop()，停止正在执行的动画。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> lis = $(<span class="string">&quot;.item&quot;</span>)</span><br><span class="line">            lis.mouseenter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 使用stop暂停正在执行的动画。</span></span><br><span class="line">                $(<span class="built_in">this</span>).children(<span class="string">&quot;ul&quot;</span>).stop().slideDown(<span class="number">500</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            lis.mouseleave(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// stop()，如果在我执行的前面存在正在执行的动画，需要立刻的暂停，然后执行我当前的动画</span></span><br><span class="line">                $(<span class="built_in">this</span>).children(<span class="string">&quot;ul&quot;</span>).stop().slideUp(<span class="number">500</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>



<h4 id="停止动画"><a href="#停止动画" class="headerlink" title="停止动画"></a>停止动画</h4><p>stop(clearQueue,junpTpEnd):停止当前正在执行的动画</p>
<p>参数：</p>
<pre><code>1. clearQueue是否清除动画队列true 或者false
 2. junpTpEnd 是否跳转到当前动画的最终效果 true,false</code></pre>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>jQuery没有针对于音频的封装，因此使用音频时需要注意</p>
<pre><code>1. 使用的是DOM对象的方法
 2. 使用get()获取他对应的元素</code></pre>
<h3 id="jQuery节点操作"><a href="#jQuery节点操作" class="headerlink" title="jQuery节点操作"></a>jQuery节点操作</h3><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>添加到子元素的最后面</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).append($(<span class="string">&quot;p&quot;</span>))</span><br><span class="line"><span class="number">2.</span>将某个元素添加到另一个子元素的最后面</span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).appendTo($(<span class="string">&quot;div&quot;</span>))</span><br><span class="line"><span class="number">3.</span>添加到子元素的最前面</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).prepend($(<span class="string">&quot;p&quot;</span>))</span><br><span class="line"><span class="number">4.</span>将某个元素添加到另一个子元素的最前面</span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).prependTo($(<span class="string">&quot;div&quot;</span>))</span><br><span class="line"><span class="number">5.</span>将某个元素添加到另一个元素的前面</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).after($(<span class="string">&quot;p&quot;</span>))</span><br><span class="line"><span class="number">6.</span>将某个元素添加到另一个元素的后面</span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>).before($(<span class="string">&quot;p&quot;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="清空节点与删除节点"><a href="#清空节点与删除节点" class="headerlink" title="清空节点与删除节点"></a>清空节点与删除节点</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>清空节点</span><br><span class="line">   $(<span class="string">&quot;div&quot;</span>).html(<span class="string">&quot;&quot;</span>) <span class="comment">// 存在内存泄漏</span></span><br><span class="line">   $(<span class="string">&quot;div&quot;</span>).empty()  <span class="comment">// 推荐</span></span><br><span class="line"><span class="number">2.</span>删除</span><br><span class="line">   $(<span class="string">&quot;div&quot;</span>).remove()</span><br></pre></td></tr></table></figure>

<h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// clone false:不传参数也是深度复制; true:也是深复制，但是可以复制事件。</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).clone()</span><br></pre></td></tr></table></figure>



<h3 id="jQuery特殊属性操作"><a href="#jQuery特殊属性操作" class="headerlink" title="jQuery特殊属性操作"></a>jQuery特殊属性操作</h3><h4 id="1-val-方法"><a href="#1-val-方法" class="headerlink" title="1.val()方法"></a>1.val()方法</h4><blockquote>
<p>val方法用于设置和获取表单元素的值，例如，input,textarea的值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>设置值</span><br><span class="line">$(<span class="string">&quot;input&quot;</span>).val(<span class="string">&quot;按钮&quot;</span>)</span><br><span class="line"><span class="number">2.</span>获取值</span><br><span class="line"><span class="keyword">var</span> dd = $(<span class="string">&quot;input&quot;</span>).val()  <span class="comment">// 按钮</span></span><br></pre></td></tr></table></figure>

<h4 id="2-html方法与text方法"><a href="#2-html方法与text方法" class="headerlink" title="2.html方法与text方法"></a>2.html方法与text方法</h4><blockquote>
<p>html()相当于innerHTML，可获取标签</p>
<p>text() 相当于innerText，可防止攻击</p>
</blockquote>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>设置值</span><br><span class="line">$(<span class="string">&quot;input&quot;</span>).html(<span class="string">&quot;&lt;p&gt;我是文本&lt;/p&gt;&quot;</span>)</span><br><span class="line"><span class="number">2.</span>获取值</span><br><span class="line"><span class="keyword">var</span> dd = $(<span class="string">&quot;input&quot;</span>).html()  <span class="comment">// &lt;p&gt;我是文本&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-width方法与height方法"><a href="#3-width方法与height方法" class="headerlink" title="3.width方法与height方法"></a>3.width方法与height方法</h4><blockquote>
<p>这两种方法，获取到的是数字，不用转换直接是使用。</p>
<p>不传参是获取值，传参是设置值。</p>
</blockquote>
<p>获取可视区域的宽高</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> w = $(<span class="built_in">window</span>).width()</span><br><span class="line">    <span class="keyword">var</span> h = $(<span class="built_in">window</span>).height()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其他方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>innerWidth()   <span class="comment">// 获取的是盒子的padding+width</span></span><br><span class="line"><span class="number">2.</span>outerWidth()   <span class="comment">// 获取的是盒子的padding+width+border</span></span><br><span class="line"><span class="number">3.</span>outerWidth()   <span class="comment">// 获取的是盒子的padding+width+border+margin</span></span><br></pre></td></tr></table></figure>

<h4 id="4-scrollTop与scrollLeft"><a href="#4-scrollTop与scrollLeft" class="headerlink" title="4.scrollTop与scrollLeft"></a>4.scrollTop与scrollLeft</h4><blockquote>
<p>设置或者获取滚动条的位置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取页面被卷起的高度</span></span><br><span class="line">	$(<span class="built_in">window</span>).scrollTop();</span><br><span class="line">	<span class="comment">// 获取页面被卷起的宽度</span></span><br><span class="line">	$(<span class="built_in">window</span>).scrollLeft();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="5-offset方法与position方法"><a href="#5-offset方法与position方法" class="headerlink" title="5.offset方法与position方法"></a>5.offset方法与position方法</h4><blockquote>
<p>获取元素的位置，返回值是一个对象。</p>
</blockquote>
<ol>
<li>offset方法获取元素的相对于document的位置，即使他的父盒子存在相对定位。</li>
<li>position方法，获取的是元素相对于有定位的父元素的位置。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sa = $(<span class="string">&quot;.son&quot;</span>).position()</span><br><span class="line"><span class="keyword">var</span> saa = $(<span class="string">&quot;.son&quot;</span>).position().top</span><br><span class="line"><span class="keyword">var</span> saa1 = $(<span class="string">&quot;.son&quot;</span>).position().left</span><br></pre></td></tr></table></figure>



<h3 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h3><h4 id="jquery事件机制"><a href="#jquery事件机制" class="headerlink" title="jquery事件机制"></a>jquery事件机制</h4><blockquote>
<p>JavaScript中已经学习过了事件，但是jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</p>
</blockquote>
<h4 id="jQuery事件发展历程-了解"><a href="#jQuery事件发展历程-了解" class="headerlink" title="jQuery事件发展历程(了解)"></a>jQuery事件发展历程(了解)</h4><p>简单事件绑定&gt;&gt;bind事件绑定&gt;&gt;delegate事件绑定&gt;&gt;on事件绑定(推荐)</p>
<blockquote>
<p>简单事件注册</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">click(handler)			单击事件</span><br><span class="line">mouseenter(handler)		鼠标进入事件</span><br><span class="line">mouseleave(handler)		鼠标离开事件</span><br></pre></td></tr></table></figure>

<p>缺点：不能同时注册多个事件</p>
<blockquote>
<p>bind方式注册事件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数：事件类型</span></span><br><span class="line"><span class="comment">//第二个参数：事件处理程序</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).bind(<span class="string">&quot;click mouseenter&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//事件响应方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>缺点：不支持动态事件绑定</p>
<blockquote>
<p>delegate注册委托事件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：selector，要绑定事件的元素</span></span><br><span class="line"><span class="comment">// 第二个参数：事件类型</span></span><br><span class="line"><span class="comment">// 第三个参数：事件处理函数</span></span><br><span class="line">$(<span class="string">&quot;.parentBox&quot;</span>).delegate(<span class="string">&quot;p&quot;</span>, <span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//为 .parentBox下面的所有的p标签绑定事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>缺点：只能注册委托事件，因此注册时间需要记得方法太多了</p>
<blockquote>
<p>on注册事件</p>
</blockquote>
<h4 id="on注册事件-重点"><a href="#on注册事件-重点" class="headerlink" title="on注册事件(重点)"></a>on注册事件(重点)</h4><blockquote>
<p>jQuery1.7之后，jQuery用on统一了所有事件的处理方法。</p>
<p>最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。</p>
</blockquote>
<p>on注册简单事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。</span></span><br><span class="line">$(selector).on( <span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>on注册委托事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定</span></span><br><span class="line">$(selector).on( <span class="string">&quot;click&quot;</span>,“span”, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>on注册事件的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</span></span><br><span class="line"><span class="comment">// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。</span></span><br><span class="line"><span class="comment">// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）</span></span><br><span class="line"><span class="comment">// 第四个参数：handler，事件处理函数</span></span><br><span class="line">$(selector).on(events[,selector][,data],handler);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>事件执行顺序：jquery中事件会先执行委托事件，在执行自己的事件。</p>
<h4 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h4><blockquote>
<p>unbind方式（不用）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).unbind(); <span class="comment">//解绑所有的事件</span></span><br><span class="line">$(selector).unbind(<span class="string">&quot;click&quot;</span>); <span class="comment">//解绑指定的事件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>undelegate方式（不用）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$( selector ).undelegate(); <span class="comment">//解绑所有的delegate事件</span></span><br><span class="line">$( selector).undelegate( “click” ); <span class="comment">//解绑所有的click事件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>off方式（推荐）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不传参数：解绑匹配元素的所有事件</span></span><br><span class="line">$(selector).off();</span><br><span class="line"><span class="comment">// 传参数 ：解绑匹配元素的所有click事件</span></span><br><span class="line">$(selector).off(<span class="string">&quot;click&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).click(); <span class="comment">//触发 click事件</span></span><br><span class="line">$(selector).trigger(<span class="string">&quot;click&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="jQuery事件对象"><a href="#jQuery事件对象" class="headerlink" title="jQuery事件对象"></a>jQuery事件对象</h4><p>jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//screenX和screenY	对应屏幕最左上角的值</span></span><br><span class="line"><span class="comment">//clientX和clientY	距离页面左上角的位置（忽视滚动条）</span></span><br><span class="line"><span class="comment">//pageX和pageY	距离页面最顶部的左上角的位置（会计算滚动条的距离）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.keyCode	按下的键盘代码</span></span><br><span class="line"><span class="comment">//event.data	存储绑定事件时传递的附加数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.stopPropagation()	阻止事件冒泡行为 </span></span><br><span class="line"><span class="comment">//event.preventDefault()	阻止浏览器默认行为</span></span><br><span class="line"><span class="comment">//return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p> 节流阀：在全局作用域内定义一个flag=true,当键盘按下的时候，进入节流阀，该flag的值为false，键盘弹起的时候，变为true.</p>
</blockquote>
<h3 id="jquery正则"><a href="#jquery正则" class="headerlink" title="jquery正则"></a>jquery正则</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 名字的效验</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[\u4e00-\u9fa5]&#123;2,4&#125;$/</span></span><br></pre></td></tr></table></figure>



<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h3 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h3><h4 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h4><blockquote>
<p>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">end(); <span class="comment">// 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。</span></span><br></pre></td></tr></table></figure>

<h4 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h4><blockquote>
<p>jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。</p>
</blockquote>
<p>作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一表示当前元素在所有匹配元素中的索引号</span></span><br><span class="line"><span class="comment">// 参数二表示当前元素（DOM对象）</span></span><br><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h4><blockquote>
<p>jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = $.noConflict();<span class="comment">//释放$的控制权,并且把$的能力给了c，这时候c相当于$。</span></span><br><span class="line">c(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    c(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;cyan&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里注意，在引入库的时候，应该将jquery最后引入，这样才能获取控制权，并释放。</p>
</blockquote>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="1-常见插件"><a href="#1-常见插件" class="headerlink" title="1.常见插件"></a>1.常见插件</h4><blockquote>
<p>插件：jquery不可能包含所有的功能，我们可以通过插件扩展jquery的功能。</p>
<p>jQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。</p>
</blockquote>
<h4 id="2-jquery-color-js"><a href="#2-jquery-color-js" class="headerlink" title="2.jquery.color.js"></a>2.jquery.color.js</h4><blockquote>
<p>animate不支持颜色的渐变，但是使用了jquery.color.js后，就可以支持颜色的渐变了。</p>
</blockquote>
<p>使用插件的步骤</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 引入jQuery文件</span><br><span class="line"><span class="number">2.</span> 引入插件（如果有用到css的话，需要引入css）</span><br><span class="line"><span class="number">3.</span> 使用插件</span><br></pre></td></tr></table></figure>

<h4 id="3-jquery-lazyload-js"><a href="#3-jquery-lazyload-js" class="headerlink" title="3.jquery.lazyload.js"></a>3.jquery.lazyload.js</h4><blockquote>
<p>懒加载功能</p>
</blockquote>
<p>引入</p>
<script src="jquery.js" type="text/javascript"></script>
<script src="jquery.lazyload.js" type="text/javascript"></script>

<p>修改img的src</p>
<img class="lazy" data-original="img/example.jpg" width="640" height="480">

<p>在js中使用插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;img.lazy&quot;</span>).lazyload();</span><br></pre></td></tr></table></figure>

<p>npm方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install jquery-lazyload</span></span><br></pre></td></tr></table></figure>



<h4 id="4-jquery-ui-js"><a href="#4-jquery-ui-js" class="headerlink" title="4.jquery.ui.js"></a>4.jquery.ui.js</h4><p>jQueryUI专指由jQuery官方维护的UI方向的插件。</p>
<p>官方API：<a href="http://api.jqueryui.com/category/all/">http://api.jqueryui.com/category/all/</a></p>
<p>其他教程：<a href="http://www.runoob.com/jqueryui/jqueryui-tutorial.html">jQueryUI教程</a></p>
<p>基本使用:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>	<span class="number">1.</span>	引入jQueryUI的样式文件</span><br><span class="line"><span class="number">2.</span>	引入jQuery</span><br><span class="line"><span class="number">3.</span>	引入jQueryUI的js文件</span><br><span class="line"><span class="number">4.</span>	使用jQueryUI功能</span><br></pre></td></tr></table></figure>



<h4 id="jquery插件的原理"><a href="#jquery插件的原理" class="headerlink" title="jquery插件的原理"></a>jquery插件的原理</h4><blockquote>
<p>原理：jquery插件其实说白了就是给jquery对象原型上增加一个新的方法，让jquery对象拥有某一个功能。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在jQuery中，jquery.prototype === $.fn</span></span><br><span class="line"><span class="comment">//通过给$.fn添加方法就能够扩展jquery对象</span></span><br><span class="line">$.fn.pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>css以及css3新增部分&quot;</title>
    <url>/2020/09/10/2css+css3/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-CSS概念"><a href="#1-CSS概念" class="headerlink" title="1.CSS概念"></a>1.CSS概念</h2><ol>
<li><p>概念：css指层叠样式表（Cascading Style Sheets）联机样式表</p>
</li>
<li><p>作用：css是用来美化html这个骨架框的，相当于化妆</p>
<a id="more"></a></li>
<li><p>书写位置：</p>
<ol>
<li>在head中，写<code>&lt;style&gt;样式&lt;/style&gt;</code></li>
<li>在head中，写<code>link</code></li>
</ol>
</li>
<li><p>css3的现状</p>
<ul>
<li>浏览器支持程度差，需要添加私有前缀</li>
<li>移动端支持优于PC端</li>
<li>应用相对广泛</li>
</ul>
</li>
<li><p>css三大特性</p>
<ol>
<li>层叠性：样式发生冲突的时候，总是执行后面的样式，和调用顺序无关</li>
<li>继承性：文字的所有属性都可以继承，比较的特殊的是h1~h6</li>
<li>优先级：<ul>
<li>默认样式&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;!important</li>
<li>​    0                    1                10            100        1000        1000以上</li>
<li>继承的权重为0</li>
<li>权重会叠加</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2.选择器"></a>2.选择器</h2><h3 id="2-1基础选择器"><a href="#2-1基础选择器" class="headerlink" title="2.1基础选择器"></a>2.1基础选择器</h3><ol>
<li>div{} </li>
<li>.box 类名选择器</li>
<li>#box　id选择器，一个ID选择器在一个页面只能调用一次。如果使用2次或者2次以上，不符合w3c规范，JS调用会出问题。</li>
<li>div p 后代选择器，无限制隔代。只要能代表标签，标签、类选择器、ID选择器自由组合。</li>
<li>div.box 交集选择器，即要满足使用了某个标签，还要满足使用了类（id）选择器。</li>
<li>div,p,span 并集选择器，使得这三个标签有相同的属性</li>
<li>div&gt;p 子代</li>
<li>* : 通配符，给所有的标签都使用相同的样式</li>
<li>div+p: 选中div后面相邻的第一个p</li>
<li>div~p: 选中的div后面所有的p</li>
</ol>
<h3 id="2-2属性选择性"><a href="#2-2属性选择性" class="headerlink" title="2.2属性选择性"></a>2.2属性选择性</h3><p>其特点是通过属性来选择元素，具体有以下5种形式：</p>
<ol>
<li><p>E[attr] 表示存在attr属性即可； <code> div[class]</code></p>
</li>
<li><p>E[attr=val] 表示属性值完全等于val; <code>div[class=mydemo]</code></p>
</li>
<li><p>E[attr*=val] 表示的属性值里包含val字符并且在“任意”位置；<code>div[class\*=mydemo]</code></p>
</li>
<li><p>E[attr^=val] 表示的属性值里包含val字符并且在“开始”位置； <code>div[class^=mydemo]</code></p>
</li>
<li><p>E[attr$=val] 表示的属性值里包含val字符并且在“结束”位置； <code>div[class$=demos]</code></p>
</li>
</ol>
<h3 id="2-3伪类选择器"><a href="#2-3伪类选择器" class="headerlink" title="2.3伪类选择器"></a>2.3伪类选择器</h3><ol>
<li>链接中的伪类</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#FF0000</span>;&#125; <span class="comment">/* 未访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#00FF00</span>;&#125; <span class="comment">/* 已访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#FF00FF</span>;&#125; <span class="comment">/* 鼠标划过链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#0000FF</span>;&#125; <span class="comment">/* 已选中的链接 */</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>以某元素相对于其父元素或兄弟元素的位置来获取无素的结构伪类。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">E</span><span class="selector-pseudo">:first-child</span>第一个子元素</span><br><span class="line"><span class="selector-tag">E</span><span class="selector-pseudo">:last-child</span>最后一个子元素</span><br><span class="line"><span class="selector-tag">E</span><span class="selector-pseudo">:nth-child(n)</span> 第<span class="selector-tag">n</span>个子元素，计算方法是<span class="selector-tag">E</span>元素的全部兄弟元素；</span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3)</span>&#123;</span><br><span class="line">           <span class="attribute">color</span>: deeppink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">E</span><span class="selector-pseudo">:nth-last-child(n)</span> 同<span class="selector-tag">E</span><span class="selector-pseudo">:nth-child(n)</span> 相似，只是倒着计算；</span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span><span class="selector-pseudo">:last-child(2)</span>&#123;</span><br><span class="line">         <span class="attribute">color</span>: deeppink;</span><br><span class="line">&#125;</span><br><span class="line">选中所有的奇数的<span class="selector-tag">li</span></span><br><span class="line">   <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2n-1)</span>&#123;</span><br><span class="line">       <span class="attribute">color</span>: red;</span><br><span class="line">   &#125;</span><br><span class="line">选中所有的7 的倍数的<span class="selector-tag">li</span> </span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(7n)</span>&#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">选中前面五个</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(-1n+5)</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">选中后面五个</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-last-child()</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line">选中所有的偶数</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-chlid(even)</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">选中所有的奇数</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:th</span><span class="selector-pseudo">:chlid(odd)</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">12px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>E:empty 选中没有任何子节点的E元素；（使用不是非常广泛）</p>
<p>没有任何的子元素，包括空格.</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 如果div是空的则会被选中*/</span></span><br><span class="line">    <span class="selector-tag">div</span><span class="selector-pseudo">:empty</span>&#123;</span><br><span class="line">      <span class="attribute">background-color</span>: red;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>E:target 结合锚点进行使用，处于当前锚点的元素会被选中；</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">* :target 伪类 要配合锚点使用 */</span><br><span class="line">  /* 表示被激活的状态*/</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#title1&quot;</span>&gt;</span>CSS (层叠样式表)<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;title1&quot;</span>&gt;</span>CSS (层叠样式表)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">h2:target&#123;</span><br><span class="line">   color:red;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h3 id="2-4伪元素选择器"><a href="#2-4伪元素选择器" class="headerlink" title="2.4伪元素选择器"></a>2.4伪元素选择器</h3><ol>
<li><strong>重点</strong>：E::before、E::after</li>
<li>元素类别：是一个行内元素，需要转换成块元素</li>
</ol>
<blockquote>
<p>E:after、E:before 在旧版本里是伪类，</p>
<p>在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待，这样做的目的是用来做兼容处理。</p>
</blockquote>
<ol start="3">
<li>使用</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪 元素：  伪：假的  元素：标签*  （:after :before  css2 不推荐 ）</span></span><br><span class="line"><span class="comment">           标志性符号： 双冒号(::)</span></span><br><span class="line"><span class="comment">           ::before ,::after 通过 css 模拟出来html标签的效果</span></span><br><span class="line"><span class="comment">           注意：必须有content属性才行，</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;今天&quot;</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;真好&quot;</span>;</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>E::first-letter 文本的第一个字母或者字（中、日、韩文）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">案例：首字母下沉</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">::first-letter</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>E::first-line 文本第一行； 文本第一行高亮..</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选中第一行的伪元素的选择器</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>E::selection 可改变选中文本的样式（color/background-color）；</li>
<li>“:” 与 “::” 区别在于区分伪类和伪元素</li>
<li>关于before和after<ol>
<li>CSS2中 E:before或者E:after，是属于伪类的，并且没有伪元素的概念</li>
<li>CSS3中 提出伪元素的概念 E::before和E::after，并且归属到了伪元素当中，伪类里就不再存在E:before或者  E:after伪类;</li>
</ol>
</li>
</ol>
<h2 id="3-颜色"><a href="#3-颜色" class="headerlink" title="3.颜色"></a>3.颜色</h2><h3 id="3-1常见颜色表示方式"><a href="#3-1常见颜色表示方式" class="headerlink" title="3.1常见颜色表示方式"></a>3.1常见颜色表示方式</h3><ol>
<li>颜色名字,例如：red</li>
<li>16进制的形式，例如：#999999</li>
<li>rgb的形式：rgb(255,0,0),  Red（红色） Green（绿色） Blue（蓝色）</li>
<li>css3新增的rgba， rgba(255,0,0,0.1)<ol>
<li>RGBA是代表Red（红色） Green（绿色） Blue（蓝色）和 Alpha的***<em><a href="http://baike.baidu.com/view/974298.htm"><strong><em>\</em>色彩空间**</strong></a>**</em>*。虽然它有的时候被描述为一个颜色空间</li>
</ol>
</li>
<li>css3新增的hsla<ol>
<li>Hue、Saturation、Lightness、Alpha即HSLA</li>
<li>H 色调 取值范围0~360，0/360表示红色、120表示绿色、240表示蓝色</li>
<li>S 饱和度 取值范围0%~100%</li>
<li>L 亮度 取值范围0%~100%</li>
<li>A 透明度 取值范围0~1</li>
</ol>
</li>
</ol>
<h3 id="3-2透明度"><a href="#3-2透明度" class="headerlink" title="3.2透明度"></a>3.2透明度</h3><ol>
<li>opacity只能针对整个盒子设置透明度，子盒子及内容会继承父盒子的透明度；</li>
<li>transparent 不可调节透明度，始终完全透明</li>
<li>使用rgba 来控制颜色，相对opacity ，不具有继承性.</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.fath</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            border: 1px solid hsla(120, 30%, 60%, 1);</span><br><span class="line"><span class="css">            <span class="comment">/* opacity: 0; */</span>   继承</span></span><br><span class="line"><span class="css">            <span class="comment">/* background-color: transparent; */</span>  无继承</span></span><br><span class="line"><span class="css">            <span class="comment">/* background-color: hsla(260, 80%, 50%, 0); */</span>  无继承</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-attr">[class=son]</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            border: rgba(0, 80, 10, 1);</span><br><span class="line">            background: darkgoldenrod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fath&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>i am a boy<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-文本元素"><a href="#4-文本元素" class="headerlink" title="4.文本元素"></a>4.文本元素</h2><h3 id="4-1属性"><a href="#4-1属性" class="headerlink" title="4.1属性"></a>4.1属性</h3><ol>
<li>font-size:16px; 文字大小</li>
<li>font-weight: 700    ;  值从100-900，文字粗细，不推荐使用font-weight:bold;</li>
<li>font-family:微软雅黑; 文本的字体</li>
<li>font-style: normal | italic;   normal 默认值 italic 斜体</li>
<li>line-height: 行高</li>
</ol>
<h3 id="4-2属性的连写"><a href="#4-2属性的连写" class="headerlink" title="4.2属性的连写"></a>4.2属性的连写</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">font:font-style font-weight font-size/line-height font-family;</span><br><span class="line"><span class="selector-tag">ex</span>:</span><br><span class="line">font:italic 700 13px/35px 微软雅黑;</span><br></pre></td></tr></table></figure>



<h3 id="4-3文字表达"><a href="#4-3文字表达" class="headerlink" title="4.3文字表达"></a>4.3文字表达</h3><ol>
<li>直接写中文名称 <code>微软雅黑</code></li>
<li>写字体的英文名称。 <code>microsoft yahei</code></li>
<li><code>unicode</code>编码</li>
</ol>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsAA02.tmp.jpg" alt="img"></p>
<h3 id="4-4文字折行"><a href="#4-4文字折行" class="headerlink" title="4.4文字折行"></a>4.4文字折行</h3><p>在一行显示不下的情况需要换行。</p>
<ul>
<li>overflow-wrap（word-wrap）通用换行控制<ul>
<li>overflow-wrap:break-word;单词尽量可以不打断折行显示</li>
</ul>
</li>
<li>word-break 针对多字节文字<ul>
<li>word-break:break-all; 单词句子都可以被拆开换行显示</li>
<li>word-break:keep-all;  让所有的单词句子保持为一个单位，保持单位的完整性</li>
</ul>
</li>
<li>white-space空白处是否断行<ul>
<li>white-space:nowrap;不换行</li>
</ul>
</li>
</ul>
<h3 id="4-5字体格式"><a href="#4-5字体格式" class="headerlink" title="4.5字体格式"></a>4.5字体格式</h3><ol>
<li>TureType(.ttf)格式</li>
</ol>
<ul>
<li>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；</li>
</ul>
<ol start="2">
<li>OpenType(.otf)格式</li>
</ol>
<ul>
<li>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；</li>
</ul>
<ol start="3">
<li>Web Open Font Format(.woff)格式</li>
</ol>
<ul>
<li>woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；</li>
</ul>
<ol start="4">
<li>Embedded Open Type(.eot)格式</li>
</ol>
<ul>
<li>.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；</li>
</ul>
<ol start="5">
<li>SVG(.svg)格式</li>
</ol>
<ul>
<li>.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；</li>
</ul>
<h3 id="4-6字体图标"><a href="#4-6字体图标" class="headerlink" title="4.6字体图标"></a>4.6字体图标</h3><p>常见的是把网页常用的一些小的图标，借助工具帮我们生成一个字体包，然后就可以像使用文字一样使用图标了。</p>
<p>优点：</p>
<p>   1、将所有图标打包成字体库，减少请求；</p>
<p>   2、具有矢量性，可保证清晰度；</p>
<p>   3、使用灵活，便于维护；</p>
<p>工具：</p>
<ol>
<li>[font Awesome 使用介绍][<a href="http://fontawesome.dashgame.com/]">http://fontawesome.dashgame.com/]</a></li>
<li>[定制自已的字体图标库](<a href="http://iconfont.cn/">http://iconfont.cn/</a>  <a href="https://icomoon.io/">https://icomoon.io/</a>)</li>
<li><a href="http://www.iconsvg.com/">SVG素材</a></li>
</ol>
<p>示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="comment">/* 如果要在网页中使用web字体（用户电脑上没有这种字体），*/</span></span><br><span class="line"><span class="comment">/* 声明字体*/</span></span><br><span class="line"><span class="comment">/* 告诉浏览器 去哪找这个字体*/</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;webfont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;font/webfont.eot&#x27;</span>); <span class="comment">/* IE9*/</span></span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;font/webfont.eot?#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;font/webfont.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>), <span class="comment">/* chrome、firefox */</span></span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;font/webfont.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>), <span class="comment">/* chrome、firefox、opera、Safari, Android, iOS 4.2+*/</span></span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;font/webfont.svg#webfont&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>); <span class="comment">/* iOS 4.1- */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定义一个类名，谁加这类名，就会使用webfont字体*/</span></span><br><span class="line"><span class="selector-class">.webfont</span>&#123;</span><br><span class="line">	<span class="attribute">font-family</span>: <span class="string">&#x27;webfont&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">	&lt;p class=&quot;webfont&quot;&gt;苍茫的天涯我的爱...&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<h2 id="5-阴影"><a href="#5-阴影" class="headerlink" title="5.阴影"></a>5.阴影</h2><h3 id="5-1文本阴影"><a href="#5-1文本阴影" class="headerlink" title="5.1文本阴影"></a>5.1文本阴影</h3><p>text-shadow，可分别设置偏移量、模糊度、颜色（可设透明度）。</p>
<ol>
<li>水平偏移量 正值向右 负值向左；</li>
<li>垂直偏移量 正值向下 负值向上；</li>
<li>模糊度是不能为负值；</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 文字阴影： 水平位移 垂直位移  模糊程度  阴影颜色*/</span></span><br><span class="line"><span class="selector-tag">text-shadow</span>: 32<span class="selector-tag">px</span> 23<span class="selector-tag">px</span> 30<span class="selector-tag">px</span> <span class="selector-id">#333</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>多个阴影</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* text-shadow :文字阴影</span></span><br><span class="line"><span class="comment">            可以设置多个阴影</span></span><br><span class="line"><span class="comment">           每个阴影之间使用逗号隔开</span></span><br><span class="line"><span class="comment">            text-shadow: -1px -1px 1px #fff, 1px 1px 1px #000;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="selector-class">.tu</span>&#123;</span><br><span class="line">            <span class="attribute">text-shadow</span>: -<span class="number">1px</span> -<span class="number">1px</span> <span class="number">1px</span> <span class="number">#fff</span>, <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#000</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-class">.ao</span>&#123;</span><br><span class="line">            <span class="attribute">text-shadow</span>: -<span class="number">1px</span> -<span class="number">1px</span> <span class="number">1px</span> <span class="number">#000</span>, <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#fff</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2盒子的阴影"><a href="#5-2盒子的阴影" class="headerlink" title="5.2盒子的阴影"></a>5.2盒子的阴影</h3><p><strong>box-shadow :1 2 3 4, rgba()</strong></p>
<ul>
<li>1,2表示x,y的偏移量</li>
<li>3表示阴影的模糊区域</li>
<li>4在原图形的扩展量，是实的</li>
<li>内阴影要加 <code>inset</code></li>
</ul>
<p>作用：1. 营造层次感（立体感）</p>
<p>​            2.充当没有宽度的边框</p>
<p>​            3.特殊效果</p>
<h2 id="6-背景"><a href="#6-背景" class="headerlink" title="6.背景"></a>6.背景</h2><ol>
<li><p>background-color: ;   背景颜色</p>
<ol>
<li><p>background-color 在 css3 中有了稍许改进。除了设置背景颜色之外，如果元素底层的背景图不可用，还可以设置一个“回退色”。</p>
<p>通过在回退色之前增加一个斜杠(/)来实现，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-color: green &#x2F; blue;</span><br></pre></td></tr></table></figure>

<p>此例中，背景色应该是绿色(green)。然而，如果底层背景图不能使用的话，背景色就是蓝色而不是绿色。如果在斜杠前不指定颜色，默认为透明(transparent)。</p>
</li>
</ol>
</li>
<li><p>background-image:url(“1.png”);    背景图片</p>
</li>
<li><p><code>background-size:80px 60px;</code>      背景图大小</p>
<ol>
<li>可以设置长度单位(px)或百分比</li>
<li>设置为<code>cover</code>时，会自动调整缩放比例，保证图片始终填充满背景区域，如有<strong>溢出部分则会被隐藏</strong>。</li>
<li>设置为<code>contain</code>会自动调整缩放比例，保证图片始终<strong>完整显示在背景区域</strong>。 </li>
</ol>
</li>
<li><p>background-repeat:  repeat |  no-repeat  |  repeat-x | repeat-y      是否重复平铺，x,y</p>
<ol>
<li><p>CSS2中当图片平铺时，会被元素在末端截断。CSS3 引入了两个属性来修正这个问题:</p>
<p>* space: 应用同等数量的空白到图片之间，直到填满整个元素<br>* round: 缩小图片直到正好平铺满元素</p>
</li>
</ol>
</li>
<li><p>background-position:  left | right | center  | top  | bottom;</p>
<ol>
<li>百分比%</li>
<li>像素px</li>
<li>方位词</li>
</ol>
</li>
<li><p>background -attachment scroll | fixed    规定背景图像是否固定或者随着页面的其余部分滚动</p>
<ol>
<li>设置为 background-attachment :local; 时，背景图会随内容的滚动而滚动</li>
</ol>
</li>
</ol>
<blockquote>
<p>连写：  background: transparent url(image.jpg) 50% 0 scroll repeat-y;</p>
</blockquote>
<ol start="7">
<li>多背景：只需要用逗号来区别各个图片。第一个声明的图片定位在元素顶部，其它的图片按序在其下排列。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-image: url(top-image.jpg), url(middle-image.jpg), url(bottom-image.jpg);</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>新属性：背景修剪(background-clip)，用来增强背景显示位置的控制能力</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">* background-clip: border-box;  裁切边框以内为背景区域；</span><br><span class="line"></span><br><span class="line">* background-clip: padding-box;   裁切内边距以内为背景区域；</span><br><span class="line"></span><br><span class="line">* background-clip: content-box;    裁切内容区做为背景区域；</span><br><span class="line"></span><br><span class="line">* background-clip: no-clip;  默认值，和 border-box 一样。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>新属性：背景原点(background-origin)，这个属性和 background-position 结合起来使用。可以从边框，内补白或者内容盒子开始计算 。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* background-origin: border-box;   以边框为原点开始计算 background-position.</span><br><span class="line"></span><br><span class="line">* background-origin: padding-box;  以内补白为原点开始计算 background-position</span><br><span class="line"></span><br><span class="line">* background-origin: content-box;  以内容盒子为原点开始计算 background-position</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200618214329332.png" alt="image-20200618214329332"></p>
<ol start="10">
<li><p>新属性：(background-break)，CSS3 中，元素可以被分成几个独立的盒子(例如 使内联元素 span 跨越多行)。background-break 属性用来控制背景怎样在这些不同的盒子中显示。</p>
<ul>
<li>background-break: continuous;<br>默认值。忽略盒之间的距离(也就是像元素没有分成多个盒子，依然是一个整体一样)</li>
<li>background-break: bounding-box;<br>把盒之间的距离计算在内</li>
<li>Background-break: each-box;  为每个盒子单独重绘背景</li>
</ul>
</li>
<li><p>clip-path对容器进行裁剪；常见几何图形；自定义路径</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &#123;<span class="comment">/* 矩形裁剪 */</span></span><br><span class="line">            <span class="comment">/* clip-path: inset(100px 50px); */</span></span><br><span class="line">            <span class="comment">/* 圆形裁剪 */</span></span><br><span class="line">            <span class="comment">/* clip-path: circle(50px at 100px 100px); */</span></span><br><span class="line">            <span class="comment">/*椭圆*/</span></span><br><span class="line">            <span class="comment">/* clip-path: ellipse(150px at 100px 100px); */</span></span><br><span class="line">            <span class="comment">/* 多边形裁剪 */</span></span><br><span class="line">            <span class="comment">/* clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%, 10% 10%, 40px 10px); */</span></span><br><span class="line"> <span class="comment">/*支持动画*/</span></span><br><span class="line"><span class="attribute">transition</span>:clip-path .<span class="number">4s</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="selector-class">.container</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">     <span class="comment">/* clip-path: circle(80px at 100px 100px); */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>自定义路径</p>
<style>
   clip-path: url(#clipPath);
</style>
<svg>
        <defs>
            <clipPath id="clipPath">
                <!-- <circle cx="60" cy="60" r="50" fill="#34538b" /> -->
                <polygon stroke="#979797" points="0.4921875 81.2070313 92.640625 81.2070313 121.601562 0.21875 153.648437 81.2070313 247.390625 80.7734375 173.394531 140.496094 200.308594 227.09375 121.601562 172.71875 53.4960937 227.09375 80.859375 140.496094"></polygon>
            </clipPath>
        </defs>
</svg>

</li>
</ol>
<h2 id="7-盒模型"><a href="#7-盒模型" class="headerlink" title="7.盒模型"></a>7.盒模型</h2><p>CSS3中可以通过<code>box-sizing</code> 来指定盒模型，即可指定为<code>content-box</code>、<code>border-box</code>，这样我们<strong>计算盒子大小的方式就发生了改变</strong>。</p>
<ul>
<li><code>content-box</code>默认值，对象的实际宽度等于设置的width值和border、padding之和</li>
<li><code>border-box</code>对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度</li>
</ul>
<p><em>box-sizing 最主要的用法是规定容器元素的最终尺寸计算方式</em></p>
<p>​     如果你创造了一个 <div> 没有设置 box-sizing 属性为 border-box(不设置的话默认值为 content-box.)，同时你设置<strong>width:100px; border:10px solid red; padding:10px;</strong> 那么最终 div 容器的实际宽度为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100px(width)+2*10px*(padding)+2*10px(border)&#x3D;140px</span><br></pre></td></tr></table></figure>

<p>​     所以你会得到一个比你预期（100px）还要更大的容器，结果就是会破坏网页布局。</p>
<p><strong>注意</strong>：容易 margin 的尺寸不会被计算入最终容器宽度，因为对他的定义为对这个容器的留白，但不属于容器本身。</p>
<p>​      如果当我们定义一个容器的 box-sizing 属性为 border-box 时（表达式：*<em>br{box-sizing:border-box}**），那么我们创建一个和上段中相同设置的 <div> 容器时，那么他的最终宽度即为 100px, 那么它的内容部分（content）的有效宽度变成了 **100px-2\</em>10px-2*10px =60px; 所以你会得到一个你预期大小的盒子容器，但是只是被压缩了内容部分尺寸而已，但是对于整体布局而言益处颇多。</p>
<h2 id="8-边框"><a href="#8-边框" class="headerlink" title="8.边框"></a>8.边框</h2><h3 id="1-边框圆角"><a href="#1-边框圆角" class="headerlink" title="1.边框圆角"></a>1.边框圆角</h3><p>border-radius</p>
<p>圆角处理时，脑中要形成圆、圆心、横轴、纵轴的概念，正圆是椭圆的一种特殊情况。如下图</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsBBF5.tmp.jpg" alt="img"> </p>
<p>为了方便表述，我们将四个角标记成1、2、3、4，如2代表右上角，CSS里提供了border-radius来设置这些角横纵轴半径值。</p>
<p>支持简写模式，具体如下：</p>
<p>1、border-radius: 10px; 表示四个角的横纵轴半径都为10px；</p>
<p>2、border-radius: 10px 5px; 表示1和3角横纵轴半径都为10px，2和4角横纵轴半径为5px；</p>
<p>3、border-radius: 10px 5px 8px; 表示1角模纵轴半径都为10px，2和4角横纵轴半径都为5px，3角的横纵轴半径都为8px；</p>
<p>4、border-radius: 10px 8px 6px 4px; 表示1角横纵轴半径都为10px，表示2角横纵轴半径都为8px，表示3角横纵轴半径都为6px，表示4角横纵轴半径都为6px；</p>
<h3 id="2-边框阴影"><a href="#2-边框阴影" class="headerlink" title="2.边框阴影"></a>2.边框阴影</h3><p>box-shadow</p>
<p>与文字阴影类似，可分别设置盒子阴影偏移量、模糊度、颜色（可设透明度）。</p>
<p>如box-shadow: 5px 5px 5px #CCC</p>
<p>1、水平偏移量 正值向右 负值向左；</p>
<p>2、垂直偏移量 正值向下 负值向上；</p>
<p>3、模糊度是不能为负值；</p>
<p>4、inset可以设置内阴影；</p>
<blockquote>
<p>注：设置边框阴影不会改变盒子的大小，即不会影响其兄弟元素的布局。可以设置多重边框阴影，实现更好的效果，增强立体感，符合渐进增强，实际开发中可以大胆使用。</p>
</blockquote>
<h3 id="3-边框图片"><a href="#3-边框图片" class="headerlink" title="3.边框图片"></a>3.边框图片</h3><p>border-image</p>
<p>设置的图片将会被“切割”成九宫格形式，然后进行设置。如下图</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps9E89.tmp.jpg" alt="img"> </p>
<p>最少“4刀”便可以将一个图片切成9部分，“切割”完成后生成虚拟的9块图形，如下图</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps9E8A.tmp.jpg" alt="img"> </p>
<p>这时我们将一个盒子想象是由9部分组成的，分别是左上角、上边框、右上角、右边框、右下角、下边框、左下角、左边框、中间，那么浏览器会将切割好的9张虚拟图片分别对应到盒子的各个部分上。</p>
<p>其中四个角位置、形状保持不变，中心位置水平垂直两个方向平铺或拉伸，如下图</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps9E8B.tmp.jpg" alt="img"> </p>
<ol>
<li><p>border-image-source 指定图片路径</p>
</li>
<li><p>border-image-repeat 指定截切好的虚拟图片的平铺方式</p>
<ul>
<li><p>stretch 默认值，拉伸</p>
</li>
<li><p>round会自动调整尺寸，完整显示边框图片</p>
</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200618221458873.png" alt="image-20200618221458873"></p>
<ul>
<li>repeat 单纯平铺,多余部分，会被“裁切”而不能完整显示。</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200618221511889.png" alt="image-20200618221511889"></p>
</li>
<li><p>border-image-slice 图像边界向内偏移</p>
</li>
<li><p>border-image-width设置边框背景区域的大小，这个值的大小不会影响到盒子的大小。</p>
</li>
</ol>
<h3 id="4-属性"><a href="#4-属性" class="headerlink" title="4.属性"></a>4.属性</h3><ol>
<li>border-collapse 属性设置表格的边框是否被合并为一个单一的边框</li>
<li>solid  实线   dotted 点线    dashed 虚线</li>
<li>获取焦点</li>
</ol>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsED60.tmp.jpg" alt="img"></p>
<h2 id="9-渐变"><a href="#9-渐变" class="headerlink" title="9.渐变"></a>9.渐变</h2><p>渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。</p>
<h3 id="1-线性渐变（函数）"><a href="#1-线性渐变（函数）" class="headerlink" title="1.线性渐变（函数）"></a>1.线性渐变（函数）</h3><p>linear-gradient线性渐变指沿着某条直线朝一个方向产生渐变效果，如下图是从黄色渐变到绿色。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200618223700061.png" alt="image-20200618223700061"></p>
<p>语法：background-image: linear-gradient(direction, color-stop1, color-stop2, …);</p>
<ol>
<li><p>必要的元素：方向、起始色、终止色、渐变距离</p>
</li>
<li><p>设置渐变方向</p>
<ul>
<li>用关键字如to top、to right</li>
<li>用角度（正负值均可）如45deg、-90deg，当以角度做为参数时，可参照下图来使用，0deg从下往上，90deg从左向右，进而可以推算出180deg从上向下。</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200618224134204.png" alt="image-20200618224134204"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200619101832677.png" alt="image-20200619101832677"></p>
</li>
</ol>
<blockquote>
<p>注：我们可以设置渐变的起始点，这个起始点的值可以是百分比形式，这个百分比在没有设置background-size时，是相对于盒子大小的，当设置了background-size时则是相对于background-size的。</p>
</blockquote>
<h3 id="2-径向渐变（函数）"><a href="#2-径向渐变（函数）" class="headerlink" title="2.径向渐变（函数）"></a>2.径向渐变（函数）</h3><p>radial-gradient径向渐变指从一个中心点开始沿着四周产生渐变效果</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200618224239218.png" alt="image-20200618224239218"></p>
<p>语法：background-image: radial-gradient(shape size at position, start-color, …, last-color);</p>
<p><strong><em>\</em>1、必要的元素：**</strong></p>
<p>a) 辐射范围即圆半径 </p>
<p>b) 中心点 即圆的中心</p>
<p>c) 渐变起始色</p>
<p>d) 渐变终止色</p>
<p>e) 渐变范围</p>
<p><strong><em>\</em>2、关于中心点**</strong></p>
<p>中心位置参照的是盒子的左上角，例如background-image: radial-gradient(120px at 0 0 yellow green)其圆心点为左上角，background-image: radial-gradient(120px at 0 100% yellow green)其圆心为左下角。</p>
<p><strong><em>\</em>3、关于辐射范围**</strong></p>
<p>其半径可以不等，即可以是椭圆，如background-image: radial-gradient(120px 100px at 0 0 yellow green)会是一个椭圆形（横轴120px、纵轴100px）的渐变。</p>
<blockquote>
<p>注：关于渐变不同浏览器有不同的版本，即语法格式不一样，我们以最新语法为准，可自行查找资料了解即可。<a href="http://www.w3cplus.com/css3/new-css3-linear-gradient.html">http://www.w3cplus.com/css3/new-css3-linear-gradient.html</a></p>
</blockquote>
<h2 id="10-过渡"><a href="#10-过渡" class="headerlink" title="10.过渡"></a>10.过渡</h2><ol>
<li><p>补间动画：自动完成从起始状态到终止状态的的过渡。</p>
</li>
<li><p>在CSS3里使用transition可以实现补间动画（过渡效果）</p>
</li>
<li><p>条件：当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡</p>
</li>
<li><p>通过all设置所有属性的过渡效果，也可以分别设置某一属性的过渡效果</p>
</li>
<li><p>transition属性拆解如下表：</p>
<table>
<thead>
<tr>
<th><strong><em>\</em>属性**</strong></th>
<th><strong><em>\</em>示例**</strong></th>
<th><strong><em>\</em>含义**</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><em>\</em>transition-property**</strong></td>
<td></td>
<td>设置过渡属性</td>
</tr>
<tr>
<td><strong><em>\</em>transition-duration**</strong></td>
<td></td>
<td>设置过渡时间</td>
</tr>
<tr>
<td><strong><em>\</em>transition-timing-function**</strong></td>
<td></td>
<td>设置过渡速度</td>
</tr>
<tr>
<td><strong><em>\</em>transition-delay**</strong></td>
<td></td>
<td>设置过渡延时</td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: red;</span><br><span class="line">            <span class="comment">/* 第一个属性：应用过渡的css属性的名称</span></span><br><span class="line"><span class="comment">             * 第二个：过渡效果花费时间</span></span><br><span class="line"><span class="comment">             * 第三个：过渡的时间曲线</span></span><br><span class="line"><span class="comment">             * 第四个：延迟过度开始时间</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="attribute">transition</span>: all <span class="number">4s</span> linear <span class="number">2s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">            <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">500px</span>) <span class="built_in">translateY</span>(<span class="number">500px</span>) <span class="built_in">scale</span>(<span class="number">0.8</span>) <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-隐藏元素"><a href="#11-隐藏元素" class="headerlink" title="11.隐藏元素"></a>11.隐藏元素</h2><p>用 CSS 隐藏页面元素有许多种方法。你可以将 <code>opacity</code> 设为 <code>0</code>、将 <code>visibility</code> 设为 <code>hidden</code>、将 <code>display</code> 设为 <code>none</code> 或者将 <code>position</code> 设为 <code>absolute</code> 然后将位置设到不可见区域。</p>
<h3 id="1-opacity"><a href="#1-opacity" class="headerlink" title="1.opacity"></a>1.opacity</h3><p><code>opacity</code> 属性的意思是设置一个元素的透明度。它不是为改变元素的边界框（bounding box）而设计的。这意味着将 opacity 设为 0 只能从视觉上隐藏元素。而元素本身依然<strong>占据它自己的位置并对网页的布局起作用</strong>。它也将响应用户交互。</p>
<ul>
<li><code>opacity</code> 属性可以用来实现一些效果很棒的动画。任何 <code>opacity</code> 属性值小于 <code>1</code> 的元素也会创建一个新的堆叠上下文</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hide</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你打算使用 <code>opacity</code> 属性在读屏软件中隐藏元素，很不幸，你并不能如愿。元素和它所有的内容会被读屏软件阅读，就像网页上的其他元素那样。换句话说，元素的行为就和它们不透明时一致。</p>
</blockquote>
<h3 id="2-visibility"><a href="#2-visibility" class="headerlink" title="2.visibility"></a>2.visibility</h3><p>第二个要说的属性是 <code>visibility</code>。将它的值设为 <code>hidden</code> 将隐藏我们的元素。如同 <code>opacity</code> 属性，被隐藏的元素依然<strong>会对我们的网页布局起作用</strong>。与 <code>opacity</code> 唯一不同的是它<strong>不会响应任何用户交互</strong>。此外，元素<strong>在读屏软件中也会被隐藏</strong>。</p>
<ul>
<li>这个属性也能够实现动画效果，只要它的初始和结束状态不一样。这确保了 visibility 状态切换之间的过渡动画可以是时间平滑的</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hide</span> &#123;</span><br><span class="line">   <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果一个元素的 <code>visibility</code> 被设置为 <code>hidden</code>，同时想要显示它的某个子孙元素，只要将那个元素的 <code>visibility</code> 显式设置为 <code>visible</code> 即可</p>
</blockquote>
<h3 id="3-display"><a href="#3-display" class="headerlink" title="3.display"></a>3.display</h3><p><code>display</code> 属性依照词义真正隐藏元素。将 <code>display</code> 属性设为 <code>none</code> 确保元素不可见并且连盒模型也不生成。使用这个属性，<strong>被隐藏的元素不占据任何空间</strong>。不仅如此，一旦 <code>display</code> 设为 <code>none</code> 任何对该元素直接打<strong>用户交互操作都不可能生效</strong>。此外，<strong>读屏软件也不会读到元素的内容</strong>。这种方式产生的效果就像元素<strong>完全不存在</strong>。</p>
<ul>
<li>任何这个元素的子孙元素也会被同时隐藏。为这个属性添加过渡动画是无效的，它的任何不同状态值之间的切换总是会立即生效。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hide</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>任何子孙元素 <code>visibility</code> 显式设置成 <code>visible</code> 可以让它变得可见，但是 <code>display</code> 不吃这一套，不管自身的 <code>display</code> 值是什么，只要祖先元素的 <code>display</code> 是 <code>none</code>，它们就都不可见。</p>
<p>但是还是可以通过 JavaScript 来进行操作。</p>
</blockquote>
<h3 id="4-position"><a href="#4-position" class="headerlink" title="4.position"></a>4.position</h3><p>假设有一个元素你想要与它交互，但是你又不想让它影响你的网页布局，没有合适的属性可以处理这种情况（opacity 和 visibility 影响布局， display 不影响布局但又无法直接交互）。在这种情况下，你只能考虑将元素移出可视区域。这个办法既<strong>不会影响布局</strong>，又能让<strong>元素保持可以操作</strong>。可以<strong>被读屏软件读取</strong>。下面是采用这种办法的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hide</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: -<span class="number">9999px</span>;</span><br><span class="line">   <span class="attribute">left</span>: -<span class="number">9999px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-定位"><a href="#12-定位" class="headerlink" title="12.定位"></a>12.定位</h2><h3 id="1-文档流"><a href="#1-文档流" class="headerlink" title="1.文档流"></a>1.文档流</h3><p>文档流，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。并最终窗体自上而下分成一行行，并在每行中按从左到右的顺序排放元素。</p>
<h3 id="2-脱离文档流"><a href="#2-脱离文档流" class="headerlink" title="2.脱离文档流"></a>2.脱离文档流</h3><p>脱离文档流即是元素打乱了这个排列，或是从排版中拿走。</p>
<p>让元素脱离文档流的方法有：浮动和定位。</p>
<h3 id="3-默认定位-static"><a href="#3-默认定位-static" class="headerlink" title="3.默认定位(static)"></a>3.默认定位(static)</h3><p>static：<strong>默认值</strong>。即没有定位，元素在正常的流中，<strong>top，right，bottom，left 和 z‐index 属性无效</strong>。</p>
<p><img src="C:\Users\Administrator\Desktop\20190605201837915.png" alt="20190605201837915"></p>
<h3 id="4-相对定位-relative"><a href="#4-相对定位-relative" class="headerlink" title="4.相对定位(relative)"></a>4.相对定位(relative)</h3><p>relative：生成相对定位的元素，通过 top，bottom，left，right 的位置相对于其正常位置进行定位。其中的相对指的是相对于元素在默认流中的位置。</p>
<ol>
<li>将元素 position 属性设置为 relative 之后，再通过 top，bottom，left，right 属性对其进行相对于原来位置的偏移；</li>
<li>元素偏移之后，他本来在默认文档流中占据的位置仍然存在，其紧挨其后的元素的定位依据它本来的位置定位；</li>
<li>该元素偏移之后，可能存在覆盖其他元素的情况（可以使用 z-index属性显示层级有限级别）。</li>
</ol>
<h3 id="5-绝对定位"><a href="#5-绝对定位" class="headerlink" title="5.绝对定位"></a>5.绝对定位</h3><p>absolute：生成绝对定位的元素，不再以自己原来的位置定位，而是以网页的<strong>左上角</strong>（body）为<strong>原定定位</strong>，如果他的父级祖先元素，设置了相对定位，则根据他们定位</p>
<ol>
<li>绝对定位的元素已经脱离了文档流，普通流中其他元素的布局就像绝对元素不存在一样；</li>
<li>绝对定位的元素的位置是<strong>相对于最近的已定位的祖先元素</strong>，如果元素没有已定位的祖先元素，它的位置就相对于 body；</li>
<li>绝对定位的框可以覆盖页面的其他元素。</li>
</ol>
<h3 id="6-固定定位（fixed）"><a href="#6-固定定位（fixed）" class="headerlink" title="6.固定定位（fixed）"></a>6.固定定位（fixed）</h3><p>fixed：本质上是一种绝对定位，不为元素预留空间。通过指定相对于屏幕视窗的位置来指定元素的空间，且<strong>元素的位置</strong>在屏幕滚动时<strong>不会发生变化</strong>。应用于很多网站顶端的固定导航、右下角的固定广告等等。</p>
<h3 id="7-常见问题"><a href="#7-常见问题" class="headerlink" title="7.常见问题"></a>7.常见问题</h3><ol>
<li><p>absolute, relative, fixed 偏移的参考点分别是什么？</p>
<ul>
<li><p>absolute 偏移的参考点是：相对于最近的已定位的父元素，如果没有，则相对于 body 元素；</p>
</li>
<li><p>relative偏移的参考点是：相对于元素在普通流中的原来位置；</p>
</li>
<li><p>fixed偏移的参考点是：相对于浏览器窗口。</p>
</li>
</ul>
</li>
<li><p>z-index有什么作用? 如何使用?</p>
<ul>
<li>z‐index 属性用于设置节点的堆叠顺序，拥有更高堆叠顺序的节点将显示在堆叠顺序较低的节点前面。</li>
<li>z-index 仅对定位元素有效（position:relative||absolute||fixed）;</li>
<li>z-index 只可比较同级元素</li>
</ul>
</li>
<li><p><strong>position:relative 和负 margin 都可以使元素位置发生偏移，二者有什么区别？</strong></p>
<ol>
<li>相对定位后元素位置发生偏移，它仍会坚守原来占据的空间，不会让文档流的其他元素流入</li>
<li>负margin会使元素在文档流中的位置发生偏移，它会放弃偏移之前占据的空间，紧挨其后的元素会填充这部分空间；</li>
</ol>
</li>
<li><p><strong>文档流、定位和父子元素高度之间的关系?</strong></p>
<ol>
<li>对于正常 static 定位，如果不对父元素设置高度，那么父元素的高度应该是所有子元素的高度之和。</li>
<li>如果使用相对定位（relative），那么元素<strong>不会脱离文档流</strong>，父元素的高度还是其所有子元素高度之和，但是相对定位（relative）的元素，可能超过父元素的范围。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 200<span class="selector-tag">px</span>;<span class="comment">/*不设置高度*/</span></span></span><br><span class="line">            border: 1px solid black;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#666</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            position: relative;</span><br><span class="line">            top: 70px;</span><br><span class="line">            left: 60px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.box3</span> &#123;</span></span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200619174325663.png" alt="image-20200619174325663"></p>
<ol start="3">
<li>如果使用绝对定位，那么元素会脱离文档流，父元素在计算高度的时候，会好像绝对定位的子元素不存在一样。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*修改上面的部分代码*&#x2F;</span><br><span class="line">.box2 &#123;</span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 70px;</span><br><span class="line">            left: 60px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200619174610083.png" alt="image-20200619174610083"></p>
<ol start="4">
<li>对于固定定位的情况，结果和绝对定位一致</li>
</ol>
</li>
<li><p><strong>定位和父子元素宽度之间的关系?</strong></p>
<ol>
<li>对于 div 元素来说，它是块级元素，如果我们不设置其宽度，那么其宽度将和其父容器宽度一致</li>
<li>当设置 box2 为相对定位之后，其不影响 box2 的宽度。</li>
<li>当设置 box2 为绝对定位时，box2 的宽度将由其内容决定。</li>
<li>如果当父元素设置为绝对定位之后，其宽度将由其中最大的元素的宽度决定。</li>
<li>如果相互嵌套的几层父子元素都设置绝对定位，那么里层的元素会脱离文档流，从而无法支撑起外层元素的宽度。</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200619180114603.png" alt="image-20200619180114603"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200619175937797.png" alt="image-20200619175937797"></p>
</li>
</ol>
<h2 id="13-垂直水平居中"><a href="#13-垂直水平居中" class="headerlink" title="13.垂直水平居中"></a>13.垂直水平居中</h2><h3 id="1-宽高固定的时候"><a href="#1-宽高固定的时候" class="headerlink" title="1.宽高固定的时候"></a>1.宽高固定的时候</h3><ol>
<li><p>父元素设置为：position: relative;<br>子元素设置为：position: absolute;<br>距上50%，据左50%，然后减去元素自身宽度的距离就可以实现</p>
<p>absolute + top:50% left:50% + margin负值</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">2px</span> dashed red;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">50px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">绝对定位的百分比(<span class="selector-tag">top50</span>% <span class="selector-tag">left50</span>%)是相对于父元素的宽高，通过这个特性可以让子元素居中显示，但是对于绝对定位是基于子元素的左上角，期望的效果是基于子元素的中心居中显示。</span><br><span class="line">为了修正这个问题，可以借助外边距的负值，负的外边距可以让元素向相反的方向定位，通过指定子元素的外边距为子元素宽度(或高度)一半的负值，就可以让子元素居中了。</span><br><span class="line">? 很常用，容易理解兼容性也很好。缺点是需要已知子元素的宽高。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="absolute-top-0-left-0-right-0-botton-0-margin-auto"><a href="#absolute-top-0-left-0-right-0-botton-0-margin-auto" class="headerlink" title="absolute + top:0 left:0 right:0 botton:0 + margin:auto"></a>absolute + top:0 left:0 right:0 botton:0 + margin:auto</h5></li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">margin</span>: auto;</span><br><span class="line">        &#125;</span><br><span class="line">通过绝对定位子元素，并且在各个定位方向的距离上都设为0，此时再将<span class="selector-tag">margin</span>设为<span class="selector-tag">auto</span>，就可以让子元素居中显示了。</span><br><span class="line">? 比较常用，兼容性较好。缺点是需要已知子元素的宽高</span><br></pre></td></tr></table></figure>

<h3 id="2-不知宽度的情况"><a href="#2-不知宽度的情况" class="headerlink" title="2.不知宽度的情况"></a>2.不知宽度的情况</h3><ol>
<li><p>position transform 元素未知宽度 </p>
<p>如果元素未知宽度，只需将上面例子中的margin: -50px 0 0 -50px;替换为：<strong>transform: translate(-50%,-50%);</strong> </p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">2px</span> dashed red;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>flex布局 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#ff8c00</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">display</span>: flex;</span><br><span class="line">            <span class="comment">/*flex布局*/</span></span><br><span class="line">            <span class="attribute">justify-content</span>: center;</span><br><span class="line">            <span class="comment">/*水平居中*/</span></span><br><span class="line">            <span class="attribute">align-items</span>: center;</span><br><span class="line">            <span class="comment">/*垂直居中*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-class">.box1</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">2px</span> dashed red;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="selector-tag">flex</span>作为现代的布局方案，颠覆了过去的经验，只需要几行代码就可以优雅的做到水平垂直居中。点这里查看<span class="selector-tag">flex</span>详解</span><br><span class="line">? 很常用，目前移动端已经完全可以使用<span class="selector-tag">flex</span>了，<span class="selector-tag">PC</span>端需要看自己业务的兼容情况。</span><br></pre></td></tr></table></figure>
</li>
<li><p>table-cell布局</p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#FF8C00</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">display</span>: table;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-class">.content</span> &#123;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#F00</span>;</span><br><span class="line">            <span class="attribute">display</span>: table-cell;</span><br><span class="line">            <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">            <span class="attribute">text-align</span>: center;</span><br><span class="line">            <span class="comment">/*使子元素水平居中*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-class">.inner</span> &#123;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">            <span class="attribute">display</span>: inline-block;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">20%</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;inner&quot;&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h2 id="14-2D"><a href="#14-2D" class="headerlink" title="14.2D"></a>14.2D</h2><p>转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。</p>
<h3 id="1-移动（translate-x-y-）"><a href="#1-移动（translate-x-y-）" class="headerlink" title="1.移动（translate(x,y)）"></a>1.移动（translate(x,y)）</h3><p>translate(x, y) 可以改变元素的位置，x、y可为负值；</p>
<ol>
<li>移动位置相当于<strong>自身原来位置</strong></li>
<li>y轴正方向朝下</li>
<li>除了可以像素值，也可以是百分比，相对于自身的宽度或高度</li>
</ol>
<h3 id="2-缩放（scale-x-y-）"><a href="#2-缩放（scale-x-y-）" class="headerlink" title="2.缩放（scale(x, y)）"></a>2.缩放（scale(x, y)）</h3><p>scale(x, y) 可以对元素进行水平和垂直方向的缩放，x、y的取值可为小数；</p>
<h3 id="3-旋转（rotate-deg-）"><a href="#3-旋转（rotate-deg-）" class="headerlink" title="3.旋转（rotate(deg)）"></a>3.旋转（rotate(deg)）</h3><p>可以对元素进行旋转，正值为顺时针，负值为逆时针；</p>
<ol>
<li>当元素旋转以后，坐标轴也跟着发生的转变</li>
<li>调整顺序可以解决，把旋转放到最后</li>
</ol>
<h3 id="4-倾斜-skew-deg-deg"><a href="#4-倾斜-skew-deg-deg" class="headerlink" title="4.倾斜 skew(deg, deg)"></a>4.倾斜 skew(deg, deg)</h3><p>skew(deg, deg) 可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。</p>
<h3 id="5-transform-origin"><a href="#5-transform-origin" class="headerlink" title="5.transform-origin"></a>5.transform-origin</h3><p>transform-origin可以调整元素转换的原点</p>
<blockquote>
<p>我们可以同时使用多个转换，其格式为：transform: translate() rotate() scale() …等，其顺序会影响转换的效果。</p>
</blockquote>
<h2 id="15-3D"><a href="#15-3D" class="headerlink" title="15.3D"></a>15.3D</h2><h3 id="1-左手坐标系"><a href="#1-左手坐标系" class="headerlink" title="1.左手坐标系"></a>1.左手坐标系</h3><p>伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。如下图</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsC0E2.tmp.jpg" alt="img"></p>
<h3 id="2-CSS中的3D坐标系"><a href="#2-CSS中的3D坐标系" class="headerlink" title="2.CSS中的3D坐标系"></a>2.CSS中的3D坐标系</h3><p>CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度，如下图</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsD34D.tmp.jpg" alt="img"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform: rotate(deg)  //旋转</span><br><span class="line">transform: translateX()  //x移动</span><br><span class="line">transform: skew()    //倾斜</span><br><span class="line">transform:scale(x,y)  //缩放 可为小数，不加px</span><br></pre></td></tr></table></figure>

<h3 id="3-透视"><a href="#3-透视" class="headerlink" title="3.透视"></a>3.透视</h3><p>电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。</p>
<p><strong>perspective有两种写法</strong></p>
<ul>
<li>作为一个属性，设置给父元素，作用于所有3D转换的子元素</li>
<li>作为transform属性的一个值，做用于元素自身</li>
<li>perspective的值，设置的是用户眼睛距离平面的距离，距离最小显示的越大，越大则越小。</li>
<li>透视效果只是视觉上的呈现，并不是真正的3d</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200620165318359.png" alt="image-20200620165318359"></p>
<p>​                                                                  透视会产生“近大远小”的效果。</p>
<blockquote>
<p><strong>注：并非任何情况下需要透视效果，根据开发需要进行设置。\</strong></p>
</blockquote>
<h3 id="4-3D呈现（transform-style）"><a href="#4-3D呈现（transform-style）" class="headerlink" title="4.3D呈现（transform-style）"></a>4.3D呈现（transform-style）</h3><p>设置内嵌的元素在 3D 空间如何呈现，这些子元素必须为转换原素。</p>
<p>flat：所有子元素在 2D 平面呈现</p>
<p>preserve-3d：保留3D空间</p>
<p>3D元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置transform-style: preserve-3d来使其变成一个真正的3D图形。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.out &#123;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 500px;</span><br><span class="line">            border: 1px solid #000;</span><br><span class="line">            background-color: pink;</span><br><span class="line">            margin: 100px auto;</span><br><span class="line">            transform: rotateY(66deg);</span><br><span class="line">            /*可以让里面的子盒子保持3d 效果，加给父盒子 */</span><br><span class="line">            /* preseve-3d: 让子盒子 位于3d空间里面*/</span><br><span class="line">            /*flat： 子盒子被扁平化*/</span><br><span class="line">            transform-style: preserve-3d;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .in &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            margin: 50px auto;</span><br><span class="line">            transform: rotateX(132deg);</span><br><span class="line">            border: 1px solid #000;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;in&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h3 id="5-元素背景是否显示"><a href="#5-元素背景是否显示" class="headerlink" title="5.元素背景是否显示"></a>5.元素背景是否显示</h3><p>backface-visibility：hidden;设置元素背面是否可见。写在父盒子中。</p>
<h2 id="16-动画"><a href="#16-动画" class="headerlink" title="16.动画"></a>16.动画</h2><p>动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p>
<p><strong>1、必要元素：</strong></p>
<p>​    a、通过@keyframes指定动画序列；</p>
<p>​    b、通过百分比将动画序列分割成多个节点；</p>
<p>​    c、在各节点中分别定义各属性</p>
<p>​    d、通过animation将动画应用于相应元素；</p>
<p><strong>2、关键属性</strong></p>
<p>​    a、animation-name设置动画序列名称</p>
<p>​    b、animation-duration动画持续时间</p>
<p>​    c、animation-delay动画延时时间</p>
<p>​    d、animation-timing-function动画执行速度，linear、ease等</p>
<p>​    e、animation-play-state动画播放状态，running、paused等</p>
<p>​    f、animation-direction动画逆播，alternate等</p>
<p>​    g、animation-fill-mode动画执行完毕后状态，forwards、backwards等</p>
<p>​    h、animation-iteration-count动画执行次数，inifinate等</p>
<p>​    i、steps(60) 表示动画分成60步完成</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: green;</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="comment">/*animation: move 2s 3  alternate linear;*/</span></span><br><span class="line">            <span class="comment">/* animation属性详解*/</span></span><br><span class="line">            <span class="comment">/* 动画名称*/</span></span><br><span class="line">            <span class="attribute">animation-name</span>: move;</span><br><span class="line">            <span class="comment">/* 一次动画持续时间  前两属性是必须，且顺序固定*/</span></span><br><span class="line">            <span class="attribute">animation-duration</span>: <span class="number">3s</span>;</span><br><span class="line">            <span class="comment">/* 动画执行次数  无数次：infinite*/</span></span><br><span class="line">            <span class="attribute">animation-iteration-count</span>: <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/* 动画的方向： normal 正常 ， alternate： 反向*/</span></span><br><span class="line">            <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">            <span class="comment">/* 动画延迟执行*/</span></span><br><span class="line">            <span class="comment">/*animation-delay: 1s;*/</span></span><br><span class="line">            <span class="comment">/* 设置动画结束盒子盒子的状态</span></span><br><span class="line"><span class="comment">                forwards：保持动画结束后的状态</span></span><br><span class="line"><span class="comment">                backwards：保持动画开始前的状态*/</span></span><br><span class="line">            <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">            <span class="comment">/* 运动曲线  linear   ease-in-out  steps()*/</span></span><br><span class="line">            <span class="comment">/*animation-timing-function:ease-in;*/</span></span><br><span class="line">            <span class="comment">/*以每一帧进行运动*/</span></span><br><span class="line">            <span class="attribute">animation-timing-function</span>: <span class="built_in">steps</span>(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">            0% &#123;&#125;</span><br><span class="line">            100% &#123;</span><br><span class="line">                <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">500px</span>) <span class="built_in">rotate</span>(<span class="number">345deg</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>\</em>参数值的顺序：**</strong></p>
<p>关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意</p>
<p><strong>调用</strong></p>
<p>​      infinite:无限次</p>
<p>​     运动曲线：linear匀速、ease动画以低速开始，然后加快，在结束前变慢、ease-in动画以低速开始、ease-out动画以低速结束、ease-in-out动画以低速开始和结束、cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">animation</span>: 动画名称 持续时间 执行次数 是否反向 运动曲线 延迟执行</span><br></pre></td></tr></table></figure>



<h2 id="17-布局"><a href="#17-布局" class="headerlink" title="17.布局"></a>17.布局</h2><p>常见的布局方式</p>
<ul>
<li>table表格布局<ul>
<li>衍生一种类似于表格的布局用div</li>
</ul>
</li>
<li>浮动：float 浮动+margin</li>
<li>inline-block布局</li>
<li>定位</li>
<li>flexbox（弹性）布局</li>
<li>伸缩布局</li>
<li>响应式布局</li>
</ul>
<h3 id="1-伸缩布局"><a href="#1-伸缩布局" class="headerlink" title="1.伸缩布局"></a>1.伸缩布局</h3><p>CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。</p>
<ul>
<li>主轴：flex容器的主轴主要是用来配置flex项目，默认是水平方向。</li>
<li>侧轴：与主轴垂直的轴称作侧轴，默认垂直方向的</li>
<li>方向：默认主轴从左向右，侧轴默认从上到下</li>
</ul>
<blockquote>
<p>主轴和侧轴并不是固定不变的，通过flex-direction可以互换。</p>
</blockquote>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200620183853643.png" alt="image-20200620183853643"></p>
<ol>
<li><p><strong>必要元素</strong></p>
<ul>
<li>指定一个盒子为伸缩盒子 display: flex</li>
<li>设置属性来调整此盒的子元素的布局方式 例如 flex-direction</li>
<li>明确主侧轴及方向</li>
<li>可互换主侧轴，也可改变方向</li>
</ul>
</li>
<li><p><strong>属性详解</strong></p>
<ol>
<li>flex-direction调整主轴方向（默认为水平方向）<ul>
<li>row 水平方向</li>
<li>reverse-row 反转</li>
<li>column 垂直方向</li>
<li>reverse-column 反转列</li>
</ul>
</li>
<li>justify-content调整主轴对齐<ul>
<li>flex-start、 起点对齐</li>
<li>flex-end、 终点对齐</li>
<li>center  中间对齐</li>
<li>space-around、 环绕</li>
<li>space-between 两端对齐</li>
</ul>
</li>
<li>align-items设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式<ul>
<li>flex-start、 起点对齐</li>
<li>flex-end、 终点对齐</li>
<li>center  中间对齐</li>
<li>strethc: 拉伸;</li>
</ul>
</li>
<li>flex-wrap控制是否换行<ul>
<li>控制是否换行，包括wrap、nowrap</li>
</ul>
</li>
<li>align-content堆栈（由flex-wrap产生的独立行）对齐<ul>
<li>堆栈排列，可对应用flex-wrap: wrap后产生的换行进行控制，包括flex-start、flex-end、center、space-between、space-around、stretch</li>
</ul>
</li>
<li>flex-flow是flex-direction、flex-wrap的简写形式</li>
<li>flex子项目在主轴的缩放比例<ul>
<li>不指定flex属性，则不参与伸缩分配，对父级按比例分配（宽、高），针对子元素。</li>
</ul>
</li>
<li>order控制子项目的排列顺序，正序方式排序，从小到大</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.order</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">            <span class="attribute">order</span>: -<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-class">.order</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">            <span class="attribute">order</span>: <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-class">.order</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">            <span class="attribute">order</span>: <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*通过控制order：数字；按数字的大小拉伸盒子对应着排序。*/</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="2-分栏布局"><a href="#2-分栏布局" class="headerlink" title="2.分栏布局"></a>2.分栏布局</h3><p>类似报纸或杂志中的排版方式，上要用以控制大篇幅文本。</p>
<ul>
<li>column-count：auto | 整数；—控制栏数</li>
<li>column-width： auto | length；—每栏的宽度</li>
<li>column-gap : length ;—两栏之间的间距</li>
<li>column-rule : 宽度，线型，颜色；—栏与栏的间隔线 类似border，solid | dotted | dashed 实线 | 点线 | 虚线</li>
<li>column-width和column-count可以让一个元素进行多列布局 column-gap和column-rule就处在相邻两列之间</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">            width: 600px;</span><br><span class="line">            height: 600px;</span><br><span class="line">            border: 1px solid blue;</span><br><span class="line">            column-count: 3;</span><br><span class="line">            column-width: 100px;</span><br><span class="line">            column-gap: 10px;</span><br><span class="line">            column-rule: 1px dotted red;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>还有一个优势，相对于一线城市来说，工作没有太大的压力，有什么比较困难的需求都会让找个成品或者用个第三方，没有那种让造轮子的领<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-弹性布局（box）"><a href="#3-弹性布局（box）" class="headerlink" title="3.弹性布局（box）"></a>3.弹性布局（box）</h3><ol>
<li><strong>优点:</strong><ul>
<li>适应性强，在做不同屏幕分辨率的界面时非常实用</li>
<li>可以随意按照宽度、比例划分元素的宽高</li>
<li>可以轻松改变元素的显示顺序</li>
<li>弹性布局实现快捷，易维护</li>
</ul>
</li>
<li><strong>元素</strong><ul>
<li>display:box;将一个元素的子元素以弹性布局进行布局</li>
<li>box-orient:horizontal  || vertical || inherit 子元素排列方式 </li>
<li>box-direction:normal || reverse || inherit 子元素的排列顺序</li>
<li>box-align:start || end || center 子元素的对齐方式 (规定水平框中垂直位置 或 垂直框中水平位置)</li>
<li>box-pack: start || end || center 子元素的对齐方式(规定水平框中水平位置 或 垂直框中垂直位置)</li>
<li>box-flex:number;子元素如何分配剩余空间</li>
<li>box-ordinal-group:number;子元素显示顺序</li>
</ul>
</li>
</ol>
<h3 id="4-响应式布局"><a href="#4-响应式布局" class="headerlink" title="4.响应式布局"></a>4.响应式布局</h3><p>如我们需要兼容不同屏幕分辨率、清晰度以及屏幕定向方式竖屏(portrait)、横屏(landscape)，怎样才能做到让一种设计方案满足所有情况？对此，马海祥觉的我们的布局应该是一种弹性的栅格布局，不同尺寸下弹性适应，如以下页面中各模块在不同尺寸下的位置：</p>
<ol>
<li>布局规则</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Extra small &lt;576px</th>
<th>Small ≥576px</th>
<th>Medium ≥768px</th>
<th>Large ≥992px</th>
<th>Extra large ≥1200px</th>
</tr>
</thead>
<tbody><tr>
<td><code>.container</code></td>
<td>100%</td>
<td>540px</td>
<td>720px</td>
<td>960px</td>
<td>1140px</td>
</tr>
<tr>
<td><code>.container-sm</code></td>
<td>100%</td>
<td>540px</td>
<td>720px</td>
<td>960px</td>
<td>1140px</td>
</tr>
<tr>
<td><code>.container-md</code></td>
<td>100%</td>
<td>100%</td>
<td>720px</td>
<td>960px</td>
<td>1140px</td>
</tr>
<tr>
<td><code>.container-lg</code></td>
<td>100%</td>
<td>100%</td>
<td>100%</td>
<td>960px</td>
<td>1140px</td>
</tr>
<tr>
<td><code>.container-xl</code></td>
<td>100%</td>
<td>100%</td>
<td>100%</td>
<td>100%</td>
<td>1140px</td>
</tr>
<tr>
<td><code>.container-fluid</code></td>
<td>100%</td>
<td>100%</td>
<td>100%</td>
<td>100%</td>
<td>100%</td>
</tr>
</tbody></table>
<ol start="2">
<li>1rem===16px</li>
</ol>
<h4 id="1、Meta标签定义"><a href="#1、Meta标签定义" class="headerlink" title="1、Meta标签定义"></a>1、Meta标签定义</h4><p>使用 viewport meta 标签在手机浏览器上控制布局</p>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />

<p>通过快捷方式打开时全屏显示</p>
<meta name="apple-mobile-web-app-capable" content="yes" />

<p>隐藏状态栏</p>
<meta name="apple-mobile-web-app-status-bar-style" content="blank" />

<p>iPhone会将看起来像电话号码的数字添加电话连接，应当关闭</p>
<meta name="format-detection" content="telephone=no" />

<h4 id="2-使用Media-Queries适配对应样式"><a href="#2-使用Media-Queries适配对应样式" class="headerlink" title="2.使用Media Queries适配对应样式"></a>2.使用Media Queries适配对应样式</h4><p><strong>设备类型(media type):</strong></p>
<p>all所有设备；<br>　　screen 电脑显示器；<br>　　print打印用纸或打印预览视图；<br>　　handheld便携设备；<br>　　tv电视机类型的设备；<br>　　speech语意和音频盒成器；<br>　　braille盲人用点字法触觉回馈设备；<br>　　embossed盲文打印机；<br>　　projection各种投影设备；<br>　　tty使用固定密度字母栅格的媒介，比如电传打字机和终端。</p>
<p><strong>设备特性(media feature):</strong></p>
<p>width浏览器宽度；<br>　　height浏览器高度；<br>　　device-width设备屏幕分辨率的宽度值；<br>　　device-height设备屏幕分辨率的高度值；<br>　　orientation浏览器窗口的方向纵向还是横向，当窗口的高度值大于等于宽度时该特性值为portrait，否则为landscape；<br>　　aspect-ratio比例值，浏览器的纵横比；<br>　　device-aspect-ratio比例值，屏幕的纵横比。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* for 240 px width screen */</span></span><br><span class="line">　　<span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-device-width:</span><span class="number">240px</span>)&#123;</span><br><span class="line">　　 selector&#123; ... &#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/* for 320px width screen */</span></span><br><span class="line">　　<span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-width:</span><span class="number">241px</span>) <span class="keyword">and</span> (<span class="attribute">max-device-width:</span><span class="number">320px</span>)&#123;</span><br><span class="line">　　 selector&#123; ... &#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/* for 480 px width screen */</span></span><br><span class="line">　　<span class="keyword">@media</span> <span class="keyword">only</span> screen (<span class="attribute">min-device-width:</span><span class="number">321px</span>)<span class="keyword">and</span> (<span class="attribute">max-device-width:</span><span class="number">480px</span>)&#123;</span><br><span class="line"> 　　selector&#123; ... &#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-瀑布流布局"><a href="#5-瀑布流布局" class="headerlink" title="5.瀑布流布局"></a>5.瀑布流布局</h3><p>瀑布流布局是流式布局的一种。是当下比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。</p>
<h4 id="瀑布流布局的原理"><a href="#瀑布流布局的原理" class="headerlink" title="瀑布流布局的原理"></a>瀑布流布局的原理</h4><ul>
<li>瀑布流布局要求要进行布置的元素等宽，然后计算元素的宽度与浏览器宽度之比，得到需要布置的列数。</li>
<li>创建一个数组，长度为列数，里面的值为已布置元素的总高度（最开始为0）</li>
<li>然后将未布置的元素依次布置到高度最小的那一列，就得到了瀑布流布局。</li>
</ul>
<h3 id="6-流式布局（Fluid）"><a href="#6-流式布局（Fluid）" class="headerlink" title="6.流式布局（Fluid）"></a>6.流式布局（Fluid）</h3><p>流式布局（Fluid） 固定布局和流式布局在网页设计中最常用的两种布局方式。固定布局能呈现网页的原始设计效果，流式布局则不受窗口宽度影响，流式布局使用百分比宽度来限定布局元素，这样可以根据客户端分辨率的大小来进行合理的显示。</p>
<h3 id="7-浮动"><a href="#7-浮动" class="headerlink" title="7.浮动"></a>7.浮动</h3><ul>
<li>元素浮动</li>
<li>文档脱离文档流，但是不脱离文本流（如果设置了绝对定位，文本流也会脱离）</li>
<li>特性<ul>
<li>形成“块”（BFC）</li>
<li>位置尽量往靠上靠左或右</li>
</ul>
</li>
<li>对父级元素的影响<ul>
<li>从布局上“消失”</li>
<li>高度塌陷—–解决—-&gt;清除浮动（:after的使用，clear:both;…）</li>
</ul>
</li>
</ul>
<h3 id="8-inline-block布局（定宽布局）"><a href="#8-inline-block布局（定宽布局）" class="headerlink" title="8.inline-block布局（定宽布局）"></a>8.inline-block布局（定宽布局）</h3><p>首先要将元素设置为inline-block元素</p>
<ul>
<li>像文本一样排block元素</li>
<li>没有清除浮动等问题</li>
<li>需要处理间隙问题<ul>
<li>处理方式一：给父级元素设置font-size:0;</li>
<li>处理方式二:清除元素与元素之间的空白间隙</li>
</ul>
</li>
</ul>
<h2 id="18-css预处理器"><a href="#18-css预处理器" class="headerlink" title="18.css预处理器"></a>18.css预处理器</h2><ol>
<li><p>定义</p>
<ul>
<li>基于CSS的另一种语言</li>
<li>通过工具编译为css</li>
<li>添加了很多css不具备的特性</li>
<li>能提升css文件的组织</li>
</ul>
</li>
<li><p>常见的预处理</p>
<ul>
<li>less 使用js写的</li>
<li>sass</li>
</ul>
</li>
<li><p>提供的新特征</p>
<ul>
<li>嵌套 反应层级和约束</li>
<li>变量和计算 减少重复代码，便于更改维护css</li>
<li>Extend和Mixin代码片段（用的比较多的重复代码）</li>
<li>循环  —适用于复杂有规律的样式</li>
<li>import CSS文件模块化</li>
</ul>
</li>
<li><p>预编译为css</p>
<ul>
<li>less的预编译<ul>
<li>$ ./node_modules/.bin/lessc 1-nest.less&gt;1-new-less.css</li>
</ul>
</li>
<li>sass的预编译<ul>
<li>$ ./node_modules/.bin/node-sass 1-nest.scss&gt;1-new-scss.css</li>
</ul>
</li>
</ul>
</li>
<li><p>变量的定义</p>
<ul>
<li>less的变量的定义 <code>@fontSize:12px;</code></li>
<li>sass的变量定义 <code>$fontSize:12px;</code></li>
</ul>
</li>
<li><p>mixin提供css代码复用的功能</p>
<ul>
<li>less mixin提供css代码复用的功能————解析为css,是将复用的代码复制到所需位置，产生大量重复代码</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="selector-class">.box</span>();</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="selector-class">.box</span>();</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>sass mixin提供css样式代码可以实现复用的功能。——–解析为css,是将复用的代码复制到所需位置，产生大量重复代码</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$fontSize</span>: <span class="number">12px</span>;</span><br><span class="line"><span class="keyword">@mixin</span> block(<span class="variable">$fontSize</span>)&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$fontSize</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:lighten(<span class="variable">$bgColor</span>, <span class="number">40%</span>);</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.nav</span>&#123;</span><br><span class="line">        <span class="keyword">@include</span> block(<span class="variable">$fontSize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        <span class="keyword">@include</span> block(<span class="variable">$fontSize</span> + <span class="number">2px</span>);</span><br><span class="line">        &amp;<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>:red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>extend</p>
<ul>
<li>less的extend,也可以实现代码的复用功能，但是它会去除解析完的css样式大量代码重复的功能。</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@fontSize:</span> <span class="number">12px</span>;</span><br><span class="line"><span class="variable">@bgColor:</span> red;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">@fontSize</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:lighten(<span class="variable">@bgColor</span>, <span class="number">40%</span>);</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.nav</span><span class="selector-pseudo">:extend(.block)</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        <span class="selector-tag">&amp;</span><span class="selector-pseudo">:extend(.block)</span>;</span><br><span class="line">        <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>:red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>scss的extend,也可以实现代码的复用功能，但是它会去除解析完的css样式大量代码重复的功能。</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$fontSize</span>: <span class="number">12px</span>;</span><br><span class="line"><span class="variable">$bgColor</span>: red;</span><br><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$fontSize</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:lighten(<span class="variable">$bgColor</span>, <span class="number">40%</span>);</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.nav</span>&#123;</span><br><span class="line">        <span class="keyword">@extend</span> .block;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        <span class="keyword">@extend</span> .block;</span><br><span class="line">        &amp;<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>:red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环</p>
<ul>
<li>less的循环:适用于样式有规律的</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.gen-col</span>(<span class="variable">@n</span>) <span class="keyword">when</span> (<span class="variable">@n</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="selector-class">.gen-col</span>(<span class="variable">@n</span> - <span class="number">1</span>);  <span class="comment">//递归</span></span><br><span class="line">    <span class="selector-class">.col-</span><span class="variable">@&#123;n&#125;</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1000px</span>/<span class="number">12</span>*<span class="variable">@n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gen-col</span>(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>sass中的循环</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @mixin gen-col($n)&#123;</span></span><br><span class="line"><span class="comment">//     @if $n &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">//         @include gen-col($n - 1);</span></span><br><span class="line"><span class="comment">//         .col-#&#123;$n&#125;&#123;</span></span><br><span class="line"><span class="comment">//             width: 1000px/12*$n;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// @include gen-col(12);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">12</span> &#123;</span><br><span class="line">    <span class="selector-class">.col-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1000px</span>/<span class="number">12</span>*<span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块化</p>
<ul>
<li>less中实现css代码的模块化，实现代码的分块进行管理，最后统一导入到一个文件中，进行编译。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./6-import-variable&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./6-import-module1&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./6-import-module2&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>scss中实现css代码的模块化，实现代码的分块进行管理，最后统一导入到一个文件中，进行编译</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./6-import-variable&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./6-import-module1&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./6-import-module2&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>css预处理的框架</p>
<ul>
<li>SASS-Compass    <a href="http://compass-style.org/help/">http://compass-style.org/help/</a></li>
<li>Less-Lesshat /EST  <a href="https://github.com/ecomfe/est">https://github.com/ecomfe/est</a></li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;est/all&quot;</span>;</span><br><span class="line"><span class="comment">// 支持到IE7</span></span><br><span class="line"><span class="variable">@support-ie-version:</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">@use-autoprefixer:</span> false;</span><br></pre></td></tr></table></figure>

<ul>
<li>提供现成的mixin</li>
<li>类似JS类库 封装常用功能</li>
</ul>
</li>
</ol>
<h2 id="私有化前缀"><a href="#私有化前缀" class="headerlink" title="私有化前缀"></a>私有化前缀</h2><p>​       -webkit-: 谷歌 苹果</p>
<p>​       -moz-:火狐</p>
<p>​       -ms-：ie</p>
<p>​       -o-：欧朋</p>
<h2 id="css初始化"><a href="#css初始化" class="headerlink" title="css初始化"></a>css初始化</h2><p>淘宝的样式初始化：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">hr</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma, arial, \<span class="number">5</span>b8b\<span class="number">4</span>f53; &#125;</span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>&#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125;</span><br><span class="line"><span class="selector-tag">address</span>, <span class="selector-tag">cite</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">var</span> &#123; <span class="attribute">font-style</span>:normal; &#125;</span><br><span class="line"><span class="selector-tag">code</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">samp</span> &#123; <span class="attribute">font-family</span>:couriernew, courier, monospace; &#125;</span><br><span class="line"><span class="selector-tag">small</span>&#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; &#125;</span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123; <span class="attribute">list-style</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>:underline; &#125;</span><br><span class="line"><span class="selector-tag">sup</span> &#123; <span class="attribute">vertical-align</span>:text-top; &#125;</span><br><span class="line"><span class="selector-tag">sub</span>&#123; <span class="attribute">vertical-align</span>:text-bottom; &#125;</span><br><span class="line"><span class="selector-tag">legend</span> &#123; <span class="attribute">color</span>:<span class="number">#000</span>; &#125;</span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">img</span> &#123; <span class="attribute">border</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123; <span class="attribute">border-collapse</span>:collapse; <span class="attribute">border-spacing</span>:<span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>



<h2 id="css工程化"><a href="#css工程化" class="headerlink" title="css工程化"></a>css工程化</h2><h3 id="1-使用的工具PostCSS"><a href="#1-使用的工具PostCSS" class="headerlink" title="1.使用的工具PostCSS"></a>1.使用的工具PostCSS</h3><ol>
<li>过程：css—–&gt;PostCSS解析转换——&gt;CSS</li>
<li>作用：PostCSS是一个解析转换css的工具，具有模块化、添加前缀、兼容性等等功能<ul>
<li>PostCSS本身只有解析能力</li>
<li>各种神奇的特性全靠插件</li>
<li>编译速度有了很大的提升</li>
<li>目前插件200多个<ul>
<li>import  模块合并</li>
<li>autoprefixier  自动添加前缀的</li>
<li>cssnano 压缩代码，包括去除无用的，代码简化等</li>
<li>cssnext使用CSS新特性</li>
<li>precss变量、循环、minxin等</li>
</ul>
</li>
</ul>
</li>
<li>安装：<code>cnpm i postcss-cli</code></li>
<li>解析：<code>$ ./node_modules/.bin/postcss src/01.postcss.css -o bulid/01.postcss.css</code></li>
<li>插件：创建配置文件<code>postcss.config.js</code>，在里面使用require导入插件</li>
</ol>
<h3 id="2-Postcss支持的构建工具"><a href="#2-Postcss支持的构建工具" class="headerlink" title="2.Postcss支持的构建工具"></a>2.Postcss支持的构建工具</h3><ul>
<li>CLI命令行工具</li>
<li>webpack postcss-loader</li>
<li>Gulp gulp-postcss</li>
<li>Grunt grunt-postcss</li>
<li>Rollup rollup-postcss</li>
</ul>
<h3 id="3-webpack支持"><a href="#3-webpack支持" class="headerlink" title="3.webpack支持"></a>3.webpack支持</h3><h4 id="css之modules实现防止命名一样带来的样式冲突问题。"><a href="#css之modules实现防止命名一样带来的样式冲突问题。" class="headerlink" title="css之modules实现防止命名一样带来的样式冲突问题。"></a>css之modules实现防止命名一样带来的样式冲突问题。</h4><ul>
<li><p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。</p>
</li>
<li><p>产生局部作用域的唯一方法，就是使用一个独一无二的<code>class</code>的名字，不会与其他选择器重名。这就是 CSS Modules 的做法。</p>
</li>
<li><p>CSS Modules 允许使用<code>:global(.className)</code>的语法，声明一个全局规则。凡是这样声明的<code>class</code>，都不会被编译成哈希字符串。 </p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-pseudo">:global(.title)</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="css之插件extract-text-webpack-plugin"><a href="#css之插件extract-text-webpack-plugin" class="headerlink" title="css之插件extract-text-webpack-plugin"></a>css之插件<code>extract-text-webpack-plugin</code></h4><p>防止将样式打包在js中引起页面样式加载错乱的现象;实现将模块化的css抽离一个文件，在html文件中直接引入，提高性能。</p>
<ul>
<li><p>安装：<code>npm install extract-text-webpack-plugin --save-dev</code></p>
</li>
<li><p>在webpack.config.js中引入该插件 :</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">&quot;extract-text-webpack-plugin&quot;</span>);<span class="comment">//引入</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          use: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">              modules:<span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">     <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">            filename: <span class="string">&#x27;css/[name].css&#x27;</span> <span class="comment">//路径以及命名</span></span><br><span class="line">        &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该插件有三个参数意义分别如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use:指需要什么样的loader去编译文件,这里由于源文件是.css所以选择css-loader</span><br><span class="line">fallback:编译后用什么loader来提取css文件</span><br><span class="line">publicfile:用来覆盖项目路径,生成该css文件的文件路径</span><br></pre></td></tr></table></figure>

<h3 id="3-webpack和css"><a href="#3-webpack和css" class="headerlink" title="3.webpack和css"></a>3.webpack和css</h3><ul>
<li>css-loader 将css变成js</li>
<li>style-loader将JS样式插入到head</li>
<li>ExtractTextPlugin 将css从js中提取出来</li>
<li>css moudules解决css命名冲突的问题</li>
<li>less-loader sass-loader 各类与处理器</li>
<li>postcss-loader Postcss处理</li>
</ul>
<h3 id="4-插件"><a href="#4-插件" class="headerlink" title="4.插件"></a>4.插件</h3><h4 id="autoprefixer"><a href="#autoprefixer" class="headerlink" title="autoprefixer"></a><a href="https://github.com/postcss/autoprefixer">autoprefixer</a></h4><p>这个就不用多说了，必装插件之一。方便的写规范的css，它会为你提供非常<a href="https://github.com/postcss/autoprefixer/tree/master/lib/hacks">完整的hack兼容方案</a>的。当然这里需要了解一下的是，它的大部分兼容数据来源<a href="http://caniuse.com/">Can I Use</a>，另外一个稍微需要了解的插件配置参数就是<a href="https://github.com/postcss/autoprefixer#options">browsers</a>，比如这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;  plugins: [    require(&#39;autoprefixer&#39;)(&#123; browsers: &#39;last 2 versions&#39; &#125;)  ]&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个参数的详细介绍可以看看<a href="https://github.com/ai/browserslist#queries">Browserslist Queries</a>，文中说了，强烈建议将查询写入package.json（后面会告诉你为何要写在这里），而非配置postcss.config.js中autoprefixer的browsers参数。所以此处建议写法如下：</p>
<p>postcss.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;  plugins: [    require(&#39;autoprefixer&#39;);  ]&#125;</span><br></pre></td></tr></table></figure>

<p>package.json内增加如下示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;browserslist&quot;: [  &quot;&gt; 1%&quot;,  &quot;last 2 versions&quot;]</span><br></pre></td></tr></table></figure>

<p>这里我对着官方文档简单说一下数组内的值对应的含义：</p>
<ul>
<li><code>last 2 versions</code>: 每个浏览器中最新的两个版本。</li>
<li><code>&gt; 5%</code> or <code>&gt;= 5%</code>: 全球浏览器使用率大于5%或大于等于5%（上例中则是1%）。</li>
</ul>
<p>其他的一些参数简单介绍：</p>
<ul>
<li><code>ie 6-8</code>: 选择包含ie6-8的版本。</li>
<li><code>Firefox &gt; 20</code>: 火狐版本号大于20。</li>
</ul>
<p>还有很多不一一列举，这里的配置还是很详细的，一般来说最省事的就是不加参数，按照默认即可。</p>
<p>需要配置的话，就在package.json里面添加<code>browserslist</code>参数，这样其他插件也能够从中获取到项目将要兼容的版本，目前包含以下几个插件会读取改配置：</p>
<ul>
<li><a href="https://github.com/postcss/autoprefixer">Autoprefixer</a></li>
<li><a href="https://github.com/babel/babel-preset-env">babel-preset-env</a> (no config support, only tool option)</li>
<li><a href="https://github.com/amilajack/eslint-plugin-compat">eslint-plugin-compat</a></li>
<li><a href="https://github.com/ismay/stylelint-no-unsupported-browser-features">stylelint-no-unsupported-browser-features</a></li>
<li><a href="https://github.com/jonathantneal/postcss-normalize">postcss-normalize</a></li>
</ul>
<p>关于autoprefixer的介绍差不多就这些了~</p>
<h4 id="postcss-partial-import"><a href="#postcss-partial-import" class="headerlink" title="postcss-partial-import"></a><a href="https://github.com/jonathantneal/postcss-partial-import">postcss-partial-import</a></h4><p>这个没啥好说的，也是很容易理解的插件，就是让你的css文件支持<code>@import</code>，支持W3C的写法也支持SASS那种写法，这里就不多说啦。</p>
<ul>
<li>安装：<code>npm install postcss-partial-import --save-dev</code></li>
<li>引入，添加到配置文件</li>
</ul>
<h4 id="cssnano"><a href="#cssnano" class="headerlink" title="cssnano"></a><a href="http://cssnano.co/">cssnano</a></h4><p>很显然这个插件作者比较高调，<a href="https://github.com/ben-eb/cssnano">github的cssnano</a>上面是没有什么说明和介绍的，当然官方也写得很详细了。这个插件给我的感觉就是css代码压缩工具（实际上它集成了很多强化的功能，表面上看起来是压缩实际上进行了相当多处理，可以看看这个表格<a href="http://cssnano.co/guides/optimisations/">Optimisations</a>），他的配置建议采用<a href="http://cssnano.co/guides/presets/">默认配置</a>，除非你知道你在做什么。</p>
<p>安装：<code>cnpm install cssnano --save-dev</code></p>
<p>配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;cssnano&#x27;</span>)(&#123;</span><br><span class="line">      preset: <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cssnext"><a href="#cssnext" class="headerlink" title="cssnext"></a><a href="https://cssnext.github.io/features/">cssnext</a></h4><p>cssnext是一个CSS发起者，它允许您在当前站点上使用未来的CSS语法。W3C有许多新的CSS规则，这些规则目前没有被浏览器实现，但可以使开发人员更快、更容易地编写更复杂的CSS。cssnext是用来弥补这个缺口的。</p>
<p>值得一看它的特性，看看你能用它完成什么，例如你可以在你的设计中使用自定义媒体查询、自定义选择器、颜色修改器、SVG过滤器和新的伪类。</p>
<p><img src="C:\Users\Administrator\Desktop\html+css高配版\20190327164411661.jpg"></p>
<p>安装：<code>npm install postcss-cssnext</code></p>
<h4 id="precss"><a href="#precss" class="headerlink" title="precss"></a><a href="https://github.com/jonathantneal/precss">precss</a></h4><p>与scss几乎一样</p>
<ul>
<li>变量、条件、循环、Mixin Extend、import、属性值引用</li>
</ul>
<p>另外还有几个插件，建议安装（当然如果你完全不知道干啥的可以忽略）：</p>
<ol>
<li><a href="https://github.com/postcss/postcss-mixins">postcss-mixins</a> 一个和SASS的mixins用法相同的插件</li>
<li><a href="https://github.com/OEvgeny/postcss-atroot">postcss-atroot</a> 让你的嵌套css处于根部(<strong>即产生在与父级同级的地方</strong>)，官方有个bar.css的@import的例子很棒，可以看看举一反三</li>
<li><a href="https://github.com/travco/postcss-extend">postcss-extend</a> 有相同结构却有那么一点点不同的区别，用这个可以方便的统一管理相同部分样式代码</li>
</ol>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol>
<li><p>css样式（选择器）的优先级</p>
<ul>
<li>计算权重确定</li>
<li>！important</li>
<li>内联样式</li>
<li>后写的优先级高</li>
</ul>
</li>
<li><p>雪碧图的作用</p>
<ul>
<li>减少HTTP请求数，提高页面的加载性能</li>
<li>可以减少图片的大小</li>
</ul>
</li>
<li><p>自定义字体的使用场景</p>
<ul>
<li>宣传/品牌/banner等固定文案</li>
<li>字体图案</li>
</ul>
</li>
<li><p>base64的使用</p>
<ul>
<li>可以减少HTTP的请求</li>
<li>适用于小图片</li>
<li>base64图片体积为原图的4/3</li>
</ul>
</li>
<li><p>伪元素和伪类的区别？</p>
<ul>
<li>伪类表状态</li>
<li>伪元素是真正存在的</li>
<li>伪元素双冒号，伪类单冒号</li>
</ul>
</li>
<li><p>如何产生不占空间的边框</p>
<ol>
<li>box-shadow</li>
<li>outline</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* outline: dotted chartreuse thick; */</span></span><br><span class="line"><span class="selector-tag">outline</span>: <span class="selector-tag">solid</span> <span class="selector-tag">rebeccapurple</span> 3<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">box-shadow</span>: 0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 15<span class="selector-tag">px</span> 8<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(10, 120, 69, 0<span class="selector-class">.6</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何实现ios图标的圆角</p>
<ol>
<li>clip-path:(svg)</li>
</ol>
</li>
<li><p>如何实现背景图的居中显示/不重复/改变大小</p>
<ol>
<li>background-position</li>
<li>background-repeat</li>
<li>background-size（cover / contain）</li>
</ol>
</li>
<li><p>如何实现一个3D效果</p>
<ol>
<li>perspective:500px</li>
<li>transform-style:preserve-3d;</li>
<li>transform:translate rotate….</li>
</ol>
</li>
<li><p>css中动画的实现方式有几种</p>
<ol>
<li>transition</li>
<li>keyframes(animation)</li>
</ol>
</li>
<li><p>过度动画和关键帧动画的区别</p>
<ol>
<li>过渡动画需要有状态变化</li>
<li>关键帧动画不需要状态变化</li>
<li>关键帧动画能控制更精细</li>
</ol>
</li>
<li><p>css动画的性能</p>
<ol>
<li>性能不坏</li>
<li>部分情况下优于JS</li>
<li>但是JS可以做到更好（js设计的更加精细）</li>
<li>部分高危属性—-box-shadow等</li>
</ol>
</li>
<li><p>常见的CSS预处理器</p>
<ol>
<li>Less使用node.js编写的</li>
<li>Sass是由Ruby写的的，官方提供了Node版本，是用C++写的。</li>
</ol>
</li>
<li><p>预处理的作用</p>
<ol>
<li>帮助我们更好的组织CSS代码</li>
<li>提高代码复用率</li>
<li>提高可维护性</li>
</ol>
</li>
<li><p>预处理器的能力</p>
<ol>
<li>嵌套 反映层级和约束</li>
<li>变量和计算  减少重复代码，便于更改维护css</li>
<li>Extend和Mixin代码片段 （用的比较多的重复代码）</li>
<li>循环    —-适用于复杂有规律的样式</li>
<li>import CSS 文件模块化（可按需拆减）</li>
</ol>
</li>
<li><p>预处理器的优缺点</p>
<ol>
<li>优点：提高代码的复用率和课维护性</li>
<li>缺点：需要引入编译过程 有学习成本</li>
</ol>
</li>
<li><p>如何看待bootstrap1的优缺点</p>
<ol>
<li>css代码结构合理，现成的样式可以直接使用</li>
<li>定制较为繁琐  体积大</li>
</ol>
</li>
<li><p>bootstrap如何实现响应式布局</p>
<ol>
<li>原理：通过media query设置不同分辨率的class</li>
<li>使用：为不同的分辨率选择不同的网格class</li>
</ol>
</li>
<li><p>如何基于bootstrap定制自己的样式</p>
<ol>
<li>用css同名类覆盖</li>
<li>修改源码重新构建<ol>
<li>找到bootstrap.scss文件入口，修改变量参数，然后重构，需要了解bootstrap的结构。</li>
</ol>
</li>
<li>引用scss源文件  修改变量—推荐使用<ol>
<li>将bootsrap当做css预处理器的模块引入，按需求引入，对结构的了解更加高</li>
</ol>
</li>
</ol>
</li>
<li><p>如何解决CSS模块化问题</p>
<ol>
<li>Less Sass 等css预处理器</li>
<li>PostCSS插件（postcss-import / precss等）</li>
<li>webpack处理CSS（css-loader + style-loader）</li>
</ol>
</li>
<li><p>PostCSS可以做什么？</p>
<ol>
<li>取决于插件可以做什么</li>
<li>autoprefixer cssnext precss等 兼容处理</li>
<li>import 模块合并</li>
<li>css语法检查 兼容性检查</li>
<li>压缩文件</li>
</ol>
</li>
<li><p>CSS modules是做什么的，如何使用</p>
<ol>
<li>解决类名冲突的问题</li>
<li>使用postcss或者webpack等构件工具进行编译</li>
<li>在HTML模板中使用编译过程产生的类名</li>
</ol>
</li>
<li><p>为什么使用JS来引入、加载CSS</p>
<ol>
<li>js作为入口管理资源有天然优势</li>
<li>将组价的结构、样式、行为封装到一起，增强内聚，降低偶合</li>
<li>可以做更多的处理（webpack）</li>
</ol>
</li>
<li><p>display:none和visibility:hidden的区别？</p>
<ul>
<li><p>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，</p>
<p>就当他从来不存在。</p>
</li>
<li><p>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>
</li>
</ul>
</li>
<li><p>CSS中 link 和@import 的区别是？</p>
<ul>
<li>link属于HTML标签，而@import是CSS提供的;</li>
<li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</li>
<li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li>
</ul>
</li>
<li><p>position的absolute与fixed共同点与不同点</p>
<ul>
<li><p>static  relative定位不脱离文档流，relative相对定位在某父元素下指定left right top等是嵌入到页面中</p>
</li>
<li><p>共同点：</p>
<p>1.改变行内元素的呈现方式，display被置为inline-block；</p>
<p>2.让元素脱离普通流，不占据空间；</p>
<p>3.默认会覆盖到非定位元素上</p>
</li>
<li><p>不同点：</p>
<p>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。</p>
<p>当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>
</li>
</ul>
</li>
<li><p>介绍一下CSS的盒子模型？</p>
<ul>
<li><p>盒模型的组成包括:content, padding, border, margin组成。 </p>
</li>
<li><p>有两种盒模型:标准盒模型和IE盒模型。两种盒模型的主要区别是:标准盒模型的宽高是值内容宽高(content),而IE盒模型的宽高是指content+padding+border。 </p>
</li>
<li><p>设置盒模型的方式是：设置box-sizing </p>
<ul>
<li><p>box-sizing:content-box 默认值</p>
</li>
<li><p>box-sizing:border-box   得到的是设置的实际盒子大小。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p>
<ul>
<li><p>CSS 选择符：</p>
<p>1.id选择器(# myid)</p>
<p>2.类选择器(.myclassname)</p>
<p>3.标签选择器(div, h1, p)</p>
<p>4.相邻选择器(h1 + p)</p>
<p>5.子选择器(ul &gt; li)</p>
<p>6.后代选择器(li a)</p>
<p>7.通配符选择器( * )</p>
<p>8.属性选择器(a[rel = “external”])</p>
<p>9.伪类选择器(a: hover, li:nth-child)</p>
</li>
<li><p>可继承的样式：1.font-size2.font-family3.color4.text-indent</p>
</li>
<li><p>不可继承的样式：</p>
<p>1.border</p>
<p>2.padding</p>
<p>3.margin</p>
<p>4.width</p>
<p>5.height</p>
</li>
<li><p>优先级算法：</p>
<p>1.优先级就近原则，同权重情况下样式定义最近者为准;</p>
<p>2.载入样式以最后载入的定位为准;</p>
<p>3.!important &gt;  id &gt; class &gt; tag  </p>
<p>4.important 比 内联优先级高，但内联比 id 要高</p>
</li>
<li><p>CSS3新增伪类举例：</p>
<p>p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。</p>
<p>p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。</p>
<p>p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。</p>
<p>p:only-child   选择属于其父元素的唯一子元素的每个 <p> 元素。</p>
<p>p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。</p>
<p>:enabled :disabled 控制表单控件的禁用状态。</p>
<p>:checked     单选框或复选框被选中。</p>
</li>
</ul>
</li>
<li><p>列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？</p>
<ul>
<li><p>display 的值的作用：</p>
<p>1.block 象块类型元素一样显示。</p>
<p>2.inline 缺省值。象行内元素类型一样显示。</p>
<p>3.inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。</p>
<p>4.list-item 象块类型元素一样显示，并添加样式列表标记。</p>
</li>
<li><p>position 的值的定位区别：</p>
<p>1.absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。</p>
<p>2.fixed 生成固定定位的元素，相对于浏览器窗口进行定位（老IE不支持）。</p>
<p>3.relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。</p>
<p>4.static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。</p>
<p>5.inherit 规定从父元素继承 position 属性的值。</p>
</li>
</ul>
</li>
<li><p>CSS3有哪些新特性？</p>
<ol>
<li><p>CSS3实现圆角（border-radius），阴影（box-shadow），</p>
</li>
<li><p>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</p>
</li>
<li><p>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜</p>
</li>
<li><p>增加了更多的CSS选择器  多背景 rgba</p>
</li>
<li><p>在CSS3中唯一引入的伪类是 ::selection.</p>
</li>
<li><p>媒体查询，多栏布局</p>
</li>
<li><p>border-image</p>
</li>
</ol>
</li>
<li><p>为什么要初始化CSS样式。</p>
<ul>
<li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</li>
<li>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化.</li>
</ul>
</li>
<li><p>解释下 CSS sprites，以及你要如何在页面或网站中使用它。</p>
<ol>
<li>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的”background-image”，”background-repeat”，”background-position” 的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。</li>
<li>这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了 http2</li>
</ol>
</li>
<li><p>解释下浮动和它的工作原理？清除浮动的技巧</p>
<ul>
<li><p>浮动元素引起的问题：</p>
<ol>
<li><p>父元素的高度无法被撑开，影响与父元素同级的元素</p>
</li>
<li><p>与浮动元素同级的非浮动元素会跟随其后</p>
</li>
<li><p>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</p>
</li>
</ol>
</li>
<li><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
</li>
<li><p>使用空标签清除浮动。这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;clear:both;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用overflow。给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</li>
<li>使用after伪对象清除浮动。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">.clearfix:after&#123;``content``: ``&quot;.&quot;``;``display``: ``block``;``height``: ``0``;``clear``: ``both``;``visibility``: ``hidden``;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 overflow 为 hidden 或者 auto</li>
</ul>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>html以及html5新增部分</title>
    <url>/2020/09/10/9.webpack4/</url>
    <content><![CDATA[<h1 id="从基础到实战-手摸手带你掌握新版Webpack4-0详解"><a href="#从基础到实战-手摸手带你掌握新版Webpack4-0详解" class="headerlink" title="从基础到实战 手摸手带你掌握新版Webpack4.0详解"></a>从基础到实战 手摸手带你掌握新版Webpack4.0详解</h1><p>知识点概览：</p>
<blockquote>
<p>Loader，HMR ,Create React App, Caching,<br>Plugin, SourceMap,Vue Cli 3.0 ,Shimming,<br>WebpackDevServer,TreeShaking, CodeSplitting,<br>Babel, React , Library, Eslint ,PWA,<br>Vue, Mode,性能优化,多页应用,原理,<br>PreLoading, PreFetching ,环境变量,TypeScript</p>
</blockquote>
<a id="more"></a>
<p>收获：</p>
<blockquote>
<p>彻底学会Webpack的配置<br>理解 Webpack的作用及原理<br>上手项目的打包过程配置<br>拥有工程化的前端思维<br>步入高级前端工程师行列</p>
</blockquote>
<h2 id="一：初识Webpack"><a href="#一：初识Webpack" class="headerlink" title="一：初识Webpack"></a>一：初识Webpack</h2><p>官网图镇楼：</p>
<p><img src="./readmeimages/%E5%AE%98%E7%BD%91%E5%9B%BE.jpg"></p>
<h3 id="1-1-什么是WebPack"><a href="#1-1-什么是WebPack" class="headerlink" title="1. 1 什么是WebPack"></a>1. 1 什么是WebPack</h3><p><strong>webpack</strong> 是一个现代 JavaScript 应用程序的<em>静态模块打包工具</em>：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并生成一个或多个 <em>bundle</em>，将其打包为合适的格式以供浏览器使用。</p>
<p><strong>webpack构建：</strong></p>
<blockquote>
<p>构建就是把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。</p>
</blockquote>
<p>1.代码转换：TypeScript 编译成 JavaScript、SCSS或Less 编译成 CSS 等。</p>
<p>2.文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</p>
<p>3.代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</p>
<p>4.模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</p>
<p>5.自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器,nodemon。</p>
<p>6.代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</p>
<p>7.自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</p>
<p>构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力,更加方便了我们的开发。</p>
<h3 id="1-2-什么是-webpack-模块"><a href="#1-2-什么是-webpack-模块" class="headerlink" title="1.2  什么是 webpack 模块"></a>1.2  什么是 webpack 模块</h3><ul>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">ES2015 <code>import</code></a> 语句</p>
</li>
<li><p><a href="http://www.commonjs.org/specs/modules/1.0/">CommonJS</a> <code>require()</code> 语句</p>
</li>
<li><p><a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD</a> <code>define</code> 和 <code>require</code> 语句</p>
</li>
<li><p>css/sass/less 文件中的 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@import"><code>@import</code> 语句</a>。</p>
</li>
<li><p>样式(<code>url(...)</code>)或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接</p>
<p><strong>详细请看官网文档</strong>：<a href="https://webpack.js.org/concepts/modules">Modules</a>       <a href="https://webpack.js.org/api">MODULES</a> </p>
</li>
</ul>
<h3 id="1-3-搭建Webpack环境"><a href="#1-3-搭建Webpack环境" class="headerlink" title="1.3 搭建Webpack环境"></a>1.3 搭建Webpack环境</h3><ul>
<li><p>去官网下载<a href="https://nodejs.org/en/">node</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 查看node版本号</span><br><span class="line">node -v</span><br><span class="line">// 查看npm版本号</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-4-初始化项目"><a href="#1-4-初始化项目" class="headerlink" title="1.4 初始化项目"></a>1.4 初始化项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir webpack-productname</span><br><span class="line"><span class="built_in">cd</span> webpack-productname </span><br><span class="line">//初始化webpack配置清单package.json</span><br><span class="line">npm init -y   </span><br></pre></td></tr></table></figure>

<h3 id="1-5-安装webpack"><a href="#1-5-安装webpack" class="headerlink" title="1.5 安装webpack"></a>1.5 安装webpack</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//全局安装（不推荐），因为如果有两个项目用了webpack不同版本，就会出现版本不统一运行不起来的情况。只有卸了当前版本安装对应版本非常麻烦。</span><br><span class="line">npm install webpack webpack-cli -g</span><br><span class="line">//查看版本</span><br><span class="line">webpack -v</span><br><span class="line">//全局卸载</span><br><span class="line">npm uninstall webpack webpack-cli -g</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//在项目里安装webpack（推荐使用）。可以在不同项目中使用不同的webpack版本。</span><br><span class="line"><span class="built_in">cd</span> webpack-productname</span><br><span class="line">npm install webpack webpack-cli -D</span><br><span class="line">//查看版本</span><br><span class="line">npx webpack -v</span><br><span class="line">//查看对用包的详细信息</span><br><span class="line">npm info webpack</span><br><span class="line">//安装指定版本包</span><br><span class="line">npm install webpack@4.16.1 webpack-cli -D</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong></p>
<blockquote>
<p>由于npm安装走的是国外的网络，比较慢容易出现安装失败的现象。</p>
<p>可以用yarn安装，首先得全局安装yarn，<code>npm install yarn -g</code> 。</p>
<p>或使用nrm快速切换npm源，首先得全局安装nrm, <code>npm install -g nrm</code>。</p>
<h4 id="nrm-使用："><a href="#nrm-使用：" class="headerlink" title="nrm 使用："></a>nrm 使用：</h4><p>nrm ls  查看可选源。</p>
<p>nrm test npm 测试速度。看哪个快就use哪个。</p>
<p>nrm use cnpm  使用cnpm 。</p>
</blockquote>
<p>webpack-cli：使我们们可以在命令行里正确的使用webpack</p>
<h3 id="1-6-webpack的配置文件"><a href="#1-6-webpack的配置文件" class="headerlink" title="1.6 webpack的配置文件"></a>1.6 webpack的配置文件</h3><p>webpack 开箱即用，可以无需使用任何配置文件。然而，webpack 会假定项目的入口起点为 <code>src/index</code>，然后会在 <code>dist/main.js</code> 输出结果，并且在生产环境开启压缩和优化。通常，你的项目还需要继续扩展此能力，为此你可以在项目根目录下创建一个 <code>webpack.config.js</code> 文件，webpack 会自动使用它。</p>
<p>在项目根目录下创建 <code>webpack.config.js</code> 文件，这是webpack默认配置文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//默认是production，打包的文件默认被压缩。开发时可以设置为development，不被压缩</span></span><br><span class="line">    mode:<span class="string">&#x27;production&#x27;</span>, </span><br><span class="line">    <span class="comment">//打包项目的入口文件</span></span><br><span class="line">    entry: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">    <span class="comment">//打包项目的输出文件</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">//自定义打包输出文件名</span></span><br><span class="line">        filename:<span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="comment">//输出文件的绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname,<span class="string">&#x27;bundle&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以自己指定配置文件来完成webpack的打包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx webpack --config + 自定义配置文件</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/concepts">概念</a>    <a href="https://webpack.js.org/configuration">配置</a></p>
<h3 id="1-7-webpack打包输出内容"><a href="#1-7-webpack打包输出内容" class="headerlink" title="1.7 webpack打包输出内容"></a>1.7 webpack打包输出内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">执行 `npm run build` 后，在控制台输出</span><br><span class="line"></span><br><span class="line">Hash:1b245e275a547956bf52 //本次打包对应唯一一个<span class="built_in">hash</span>值</span><br><span class="line">Version:webpack 4.29.6 //本次打包对应webpack版本</span><br><span class="line">Time:162ms Built at:2019-4-11 23:13:43 //本次打包耗时，及打包的时间</span><br><span class="line">Asset Size Chunks Chunk Names //打包后的文件名，大小，id，入口文件名</span><br><span class="line">bundle.js 1.36 KiB 0 [emitted] main </span><br><span class="line">Entrypoint main=bundle.js</span><br><span class="line">[0]./src/index.js 159 bytes &#123;0&#125;[built]</span><br><span class="line">[1]./src/header.js 187 bytes &#123;e&#125;[built]</span><br><span class="line">[2]./src/sidebar.js 193 bytes &#123;e&#125;[built]</span><br><span class="line">[3]./src/content.js 193 bytes &#123;e&#125; [built]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="二：Webpack核心概念"><a href="#二：Webpack核心概念" class="headerlink" title="二：Webpack核心概念"></a>二：Webpack核心概念</h2><h3 id="LOADER"><a href="#LOADER" class="headerlink" title="LOADER"></a>LOADER</h3><h3 id="2-1-什么是Loader"><a href="#2-1-什么是Loader" class="headerlink" title="2.1 什么是Loader"></a>2.1 什么是Loader</h3><p>webpack可以使用 <a href="https://webpack.docschina.org/concepts/loaders">loader</a> 来预处理文件，就是通过使用不同的Loader，webpack可以把不同的静态文件都编译成js文件，比如css,sass,less,ES6/7,vue,JSX等。</p>
<h4 id="使用Loader打包静态资源"><a href="#使用Loader打包静态资源" class="headerlink" title="使用Loader打包静态资源"></a>使用Loader打包静态资源</h4><h4 id="支持加载图片文件："><a href="#支持加载图片文件：" class="headerlink" title="支持加载图片文件："></a><strong>支持加载图片文件</strong>：</h4><p>需要安装 <code>file-loader</code>:解决CSS等文件中的引入图片路径问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install file-loader -D</span><br></pre></td></tr></table></figure>

<p>在 <code>webpack.config.js</code> 里添加 loader 配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//配置模块,主要用来配置不同文件的加载器</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">      <span class="comment">//配置模块规则</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>, <span class="comment">//正则匹配要使用相应loader的文件</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;file-loader&#x27;</span>, <span class="comment">//要用到的loader</span></span><br><span class="line">              options: &#123;</span><br><span class="line">                  <span class="comment">//palceholder占位符</span></span><br><span class="line">                  name:<span class="string">&#x27;[name].[ext]&#x27;</span>, <span class="comment">//打包后的图片名字，后缀和打包的之前的图片一样</span></span><br><span class="line">                  outputPath: <span class="string">&#x27;images/&#x27;</span> <span class="comment">//图片打包后的地址</span></span><br><span class="line">              &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/loaders/file-loader">file-loader</a></p>
<h4 id="将小图片转换成base64格式"><a href="#将小图片转换成base64格式" class="headerlink" title="将小图片转换成base64格式"></a><strong>将小图片转换成base64格式</strong></h4><p>需要安装 <code>url-loader</code>:当图片小于limit的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install url-loader -D</span><br></pre></td></tr></table></figure>

<p>在 <code>webpack.config.js</code> 里添加 loader 配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|bmp/</span>)$/i,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name:<span class="string">&#x27;[name].[ext]&#x27;</span>,</span><br><span class="line">              outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">              limit: <span class="number">8192</span> <span class="comment">//小于8192b,就可以转化成base64格式。大于就会打包成文件格式</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/loaders/url-loader">url-loader</a></p>
<hr>
<h4 id="支持加载样式CSS文件："><a href="#支持加载样式CSS文件：" class="headerlink" title="支持加载样式CSS文件："></a><strong>支持加载样式CSS文件</strong>：</h4><p>需要安装 <code>css-loader    style-loader</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader style-loader -D</span><br></pre></td></tr></table></figure>

<p>在 <code>webpack.config.js</code> 里添加 loader 配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">//匹配以css为后缀的文件</span></span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],<span class="comment">//loader的执行顺序是从右向左，从下到上。css-loader：分析几个css文件之间的关系，最终合并为一个css。style-loader:在得到css生成的内容时，把其挂载到html的head里，成为内联样式。</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="支持加载样式SASS文件："><a href="#支持加载样式SASS文件：" class="headerlink" title="支持加载样式SASS文件："></a><strong>支持加载样式SASS文件</strong>：</h4><p>需要安装 <code>sass-loader node-sass</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install sass-loader node-sass -D</span><br></pre></td></tr></table></figure>

<p>在 <code>webpack.config.js</code> 里添加 loader 配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">&quot;style-loader&quot;</span>, <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">                <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">                <span class="string">&quot;sass-loader&quot;</span> <span class="comment">// 将 Sass 编译成 CSS，默认使用 Node Sass</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="为-css-样式属性加不同浏览器的前缀"><a href="#为-css-样式属性加不同浏览器的前缀" class="headerlink" title="为 css 样式属性加不同浏览器的前缀"></a>为 css 样式属性加不同浏览器的前缀</h4><p>为了浏览器的兼容性，有时候我们必须加入-webkit,-ms,-o,-moz这些前缀</p>
<ul>
<li>Trident内核：主要代表为IE浏览器, 前缀为-ms</li>
<li>Gecko内核：主要代表为Firefox, 前缀为-moz</li>
<li>Presto内核：主要代表为Opera, 前缀为-o</li>
<li>Webkit内核：产要代表为Chrome和Safari, 前缀为-webkit</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure>

<p>在项目跟目录下创建 <strong>postcss.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">&quot;style-loader&quot;</span>, <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">                <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">                <span class="string">&#x27;postcss-loader&#x27;</span>,<span class="comment">//注意postcss-loader放置位置，应放在css-loader之后，sass|less|stylus-loader之前。</span></span><br><span class="line">                <span class="string">&quot;sass-loader&quot;</span> <span class="comment">// 将 Sass 编译成 CSS，默认使用 Node Sass</span></span><br><span class="line">                </span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给loader加一些配置项：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">&quot;style-loader&quot;</span>, </span><br><span class="line">                &#123;</span><br><span class="line">                 	loader: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        importLoaders:<span class="number">2</span> ,<span class="comment">//如果sass文件里还引入了另外一个sass文件，另一个文件还会从sass-loader向上解析。如果不加，就直接从css-loader开始解析// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class="line">                        modules: <span class="literal">true</span> <span class="comment">//开启css的模块打包。css样式不会和其他模块发生耦合和冲突</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, </span><br><span class="line">                <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;sass-loader&quot;</span>, </span><br><span class="line">                </span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="为字体图标文件配loader"><a href="#为字体图标文件配loader" class="headerlink" title="为字体图标文件配loader"></a>为字体图标文件配loader</h4><p>在 <a href="https://www.iconfont.cn/">阿里巴巴矢量图标库中</a>，把需要的字体图标下载到本地，解压。将<code>iconfont.eot iconfont.svg iconfont.ttf iconfont.woff</code> 文件放入到项目中，在src中新建一个放字体图标的文件夹font。将iconfont.css文件拷贝到项目中，自己改一下引入字体图标的路径。</p>
<p>需要安装 <code>file-loader</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i file-loader -D</span><br></pre></td></tr></table></figure>



<p><strong>webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">            use:&#123;</span><br><span class="line">                loader:<span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/guides/asset-management">asset-management</a></p>
<hr>
<h3 id="plugin-可以在webpack运行到某个时刻的时候，帮你做一些事情"><a href="#plugin-可以在webpack运行到某个时刻的时候，帮你做一些事情" class="headerlink" title="plugin : 可以在webpack运行到某个时刻的时候，帮你做一些事情"></a>plugin : 可以在webpack运行到某个时刻的时候，帮你做一些事情</h3><p>使用plugins让打包更便捷</p>
<h4 id="HtmlWebpackPlugin-：htmlWebpackPlugin-会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中"><a href="#HtmlWebpackPlugin-：htmlWebpackPlugin-会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中" class="headerlink" title="HtmlWebpackPlugin ：htmlWebpackPlugin 会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中"></a>HtmlWebpackPlugin ：htmlWebpackPlugin 会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中</h4><p>安装：<code>npm i html-webpack-plugin -D</code></p>
<p>基本用法：在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;index_bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">    plugins: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">&#x27;src/index.html&#x27;</span> <span class="comment">//以index.html为模板，把打包生成的js自动引入到这个html文件中</span></span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="CleanWebpackPlugin-自动清除上一次打包的dist文件"><a href="#CleanWebpackPlugin-自动清除上一次打包的dist文件" class="headerlink" title="CleanWebpackPlugin :自动清除上一次打包的dist文件"></a>CleanWebpackPlugin :自动清除上一次打包的dist文件</h4><p>安装：<code>npm i clean-webpack-plugin -D</code></p>
<p>基本用法：在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;index_bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">&#x27;src/index.html&#x27;</span> <span class="comment">//在打包之后，以.html为模板，把打包生成的js自动引入到这个html文件中</span></span><br><span class="line">    &#125;),</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]), <span class="comment">// 在打包之前，可以删除dist文件夹下的所有内容</span></span><br><span class="line">    </span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Entry与Output的基础配置"><a href="#Entry与Output的基础配置" class="headerlink" title="Entry与Output的基础配置"></a>Entry与Output的基础配置</h3><p>在打包多入口文件时的配置</p>
<p>基本用法：在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">   	main: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    sub: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">&#x27;http://cdn.com.cn&#x27;</span>, <span class="comment">//将注入到html中的js文件前面加上地址</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">&#x27;src/index.html&#x27;</span> <span class="comment">//在打包之后，以.html为模板，把打包生成的js自动引入到这个html文件中</span></span><br><span class="line">    &#125;),</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]), <span class="comment">// 在打包之前，可以删除dist文件夹下的所有内容</span></span><br><span class="line">    </span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详细请看官网：<a href="https://webpack.js.org/configuration/output">Output</a>  <a href="https://webpack.js.org/guides/output-management">output-management</a></p>
<hr>
<h3 id="SourceMap-的配置"><a href="#SourceMap-的配置" class="headerlink" title="SourceMap 的配置"></a>SourceMap 的配置</h3><p>sourcemap：打包编译后的文件和源文件的映射关系，用于开发者调试用。</p>
<ul>
<li><p>source-map 把映射文件生成到单独的文件，最完整但最慢</p>
</li>
<li><p>cheap-module-source-map 在一个单独的文件中产生一个不带列映射的Map</p>
</li>
<li><p>eval-source-map 使用eval打包源文件模块,在同一个文件中生成完整sourcemap</p>
</li>
<li><p>cheap-module-eval-source-map sourcemap和打包后的JS同行显示，没有映射列</p>
<p> development环境推荐使用： devtool: ‘cheap-module-eval-source-map’,<br> production环境推荐使用： devtool: ‘cheap-module-source-map’,</p>
</li>
</ul>
<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">	<span class="comment">//devtool:&#x27;none&#x27;,//在开发者模式下，默认开启sourcemap,将其关闭</span></span><br><span class="line">    <span class="comment">//devtool:&#x27;source-map&#x27;//开启映射打包会变慢</span></span><br><span class="line">    <span class="comment">//devtool:&#x27;inline-source-map&#x27;//不单独生成.map文件，会将生成的映射文件以base64的形式插入到打包后的js文件的底部</span></span><br><span class="line">    <span class="comment">//devtool:&#x27;cheap-inline-source-map&#x27;//代码出错提示不用精确显示第几行的第几个字符出错，只显示第几行出错，会提高一些性能</span></span><br><span class="line">    <span class="comment">//devtool:&#x27;cheap-module-inline-source-map&#x27;//不仅管自己的业务代码出错，也管第三方模块和loader的一些报错</span></span><br><span class="line">    <span class="comment">//devtool:&#x27;eval&#x27;//执行效率最快，性能最好，但是针对比较复杂的代码的情况下，提示内容不全面</span></span><br><span class="line">	<span class="comment">//devtool: &#x27;cheap-module-eval-source-map&#x27;,//在开发环境推荐使用，提示比较全，打包速度比较快</span></span><br><span class="line">    <span class="comment">//devtool: &#x27;cheap-module-source-map&#x27;,//在生产环境中推荐使用，提示效果会好一些</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">		template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">	&#125;), <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>])],</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细请看官网：<a href="https://webpack.js.org/configuration/devtool">devtool</a></p>
<hr>
<h3 id="使用WebpackDevServer-提升开发效率"><a href="#使用WebpackDevServer-提升开发效率" class="headerlink" title="使用WebpackDevServer 提升开发效率"></a>使用WebpackDevServer 提升开发效率</h3><p>解决每次在src里编写完代码都需要手动重新运行 npm run dev</p>
<p>1.在 package.json 中配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;haiyang&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bundle&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;webpack --watch&quot;</span>,<span class="comment">// 加--watch自动监听代码的变化</span></span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2.在 webpack.config.js 中，加 devServer</p>
<p>安装 <code>npm i webpack-dev-server –D</code></p>
<ul>
<li>contentBase :配置开发服务运行时的文件根目录</li>
<li>open :自动打开浏览器</li>
<li>host：开发服务器监听的主机地址</li>
<li>compress :开发服务器是否启动gzip等压缩</li>
<li>port：开发服务器监听的端口</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">+	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">    	proxy: &#123;<span class="comment">//配置跨域，访问的域名会被代理到本地的3000端口</span></span><br><span class="line">      		<span class="string">&#x27;/api&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: []</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [],</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 package.json 中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;haiyang&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bundle&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;webpack --watch&quot;</span>,<span class="comment">// 加--watch自动监听代码的变化</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server&quot;</span>,<span class="comment">//配置热更新</span></span><br><span class="line">	</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细请看官网 ：<a href="https://webpack.js.org/configuration/dev-server">dev-server</a></p>
<p><strong>扩充知识：自己写一个类似webpackdevserver的工具</strong> </p>
<p>了解即可，功能不全，自行扩展。</p>
<p>在 package.json 中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;haiyang&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bundle&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;webpack --watch&quot;</span>,<span class="comment">// 加--watch自动监听代码的变化</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server&quot;</span>,<span class="comment">//配置热更新</span></span><br><span class="line">+	&quot;server&quot; : &quot;node server.js&quot; //自己写一个类似webpackdevserver的工具</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>安装 ：<code>npm i express webpack-dev-middleware -D</code></p>
<p>在 项目根目录下创建 server.js 文件</p>
<p>在 server.js 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> complier = webpack(config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(complier, &#123;&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;server is running&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="模块热替换-hot-module-replacement"><a href="#模块热替换-hot-module-replacement" class="headerlink" title="模块热替换(hot module replacement)"></a>模块热替换(hot module replacement)</h3><p>在 package.json 中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;haiyang&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server&quot;</span> <span class="comment">//将文件打包到内存中，有助于开发</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 webpack.config.js 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">+		hot: <span class="literal">true</span>,<span class="comment">//开启热更新</span></span><br><span class="line">+		hotOnly: <span class="literal">true</span><span class="comment">//尽管html功能没有实现，也不让浏览器刷新</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">		&#125;), </span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]),</span><br><span class="line">+		<span class="keyword">new</span> webpack.HotModuleReplacementPlugin() <span class="comment">//使用模块热更新插件</span></span><br><span class="line">	],</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果模块启用了HMR，就可以用 module.hot.accept(),监听模块的更新。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./library.js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用更新过的 library 模块执行某些操作...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<blockquote>
<p>引入css,用框架Vue，React 时，不需要写 module.hot.accept()，因为在使用css-loader，vue-loader，babel-preset时，就已经配置好了HMR，不需要自己写</p>
</blockquote>
<p>详细请看官方文档：<a href="https://webpack.js.org/guides/hot-module-replacement">hot-module-replacement</a>   <a href="https://webpack.js.org/api/hot-module-replacement">api/hot-module-replacement</a>  <a href="https://webpack.js.org/concepts/hot-module-replacement">concepts/hot-module-replacement</a>  </p>
<hr>
<h3 id="使用-Babel-处理-ES6-7-语法-转义为ES5"><a href="#使用-Babel-处理-ES6-7-语法-转义为ES5" class="headerlink" title="使用 Babel 处理 ES6/7 语法  转义为ES5"></a>使用 Babel 处理 ES6/7 语法  转义为ES5</h3><p>BABEL官网：<a href="https://babeljs.io/setup">https://babeljs.io/setup</a></p>
<p>安装依赖包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i babel-loader @babel/core @babel/preset-env -D</span><br><span class="line">//生产依赖，兼容低版本浏览器</span><br><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure>

<p>在 webpack.config.js 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">     	exclude: <span class="regexp">/node_modules/</span>,<span class="comment">//不需要对第三方模块进行转换，耗费性能</span></span><br><span class="line">     	loader: <span class="string">&quot;babel-loader&quot;</span> ,</span><br><span class="line">        options:&#123;</span><br><span class="line">            <span class="string">&quot;presets&quot;</span>: [[<span class="string">&quot;@babel/preset-env&quot;</span>,&#123;</span><br><span class="line">                targets: &#123;<span class="comment">//这个项目运行在大于什么版本的浏览器上，已经支持es6的语法的高版本浏览器就不需要转义成es5了</span></span><br><span class="line">                    edge: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">                    firefox: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">                    chrome: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">                    safari: <span class="string">&quot;11.1&quot;</span>,</span><br><span class="line">                  &#125;,</span><br><span class="line">                useBuiltIns:<span class="string">&#x27;usage&#x27;</span> <span class="comment">//按需添加polyfill,把用到的代码都转成低版本浏览器兼容的</span></span><br><span class="line">            &#125;]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 index.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在业务代码运行之前最顶部导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@babel/polyfill&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="注意：在开发类库，第三方模块或组件库时不能用-babel-polyfill-这种方案，因为会把声明的变量变成全局变量，会污染全局环境。"><a href="#注意：在开发类库，第三方模块或组件库时不能用-babel-polyfill-这种方案，因为会把声明的变量变成全局变量，会污染全局环境。" class="headerlink" title="注意：在开发类库，第三方模块或组件库时不能用 @babel/polyfill 这种方案，因为会把声明的变量变成全局变量，会污染全局环境。"></a>注意：在开发类库，第三方模块或组件库时不能用 @babel/polyfill 这种方案，因为会把声明的变量变成全局变量，会污染全局环境。</h3><p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br><span class="line">npm install --save @babel/runtime</span><br><span class="line">npm install --save @babel/runtime-corejs2</span><br></pre></td></tr></table></figure>

<p>在 webpack.config.js 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">     	exclude: <span class="regexp">/node_modules/</span>,<span class="comment">//不需要对第三方模块进行转换，耗费性能</span></span><br><span class="line">     	loader: <span class="string">&quot;babel-loader&quot;</span> ,</span><br><span class="line">        options:&#123;</span><br><span class="line">            <span class="string">&quot;plugins&quot;</span>: [[<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,&#123;</span><br><span class="line">                <span class="string">&quot;corejs&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">&quot;helpers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;regenerator&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;useESModules&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于babel需要配置的内容非常多，我们需要在项目根目录下创建一个 <code>.babelrc</code> 文件。</p>
<p>就不需要在 webpack.config.js 中写 babel 的配置了。</p>
<p>在  <code>.babelrc</code>  中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="string">&quot;plugins&quot;</span>: [[<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,&#123;</span><br><span class="line">                <span class="string">&quot;corejs&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">&quot;helpers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;regenerator&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;useESModules&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;]]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="配置-React-代码的打包"><a href="#配置-React-代码的打包" class="headerlink" title="配置 React 代码的打包"></a>配置 React 代码的打包</h3><p>业务代码：</p>
<p>在  <code>.babelrc</code>  中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	&#123; </span><br><span class="line">            <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">                [<span class="string">&quot;@babel/preset-env&quot;</span>,&#123;</span><br><span class="line">                targets: &#123;</span><br><span class="line">                    edge: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">                    firefox: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">                    chrome: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">                    safari: <span class="string">&quot;11.1&quot;</span>,</span><br><span class="line">                  &#125;,</span><br><span class="line">                useBuiltIns:<span class="string">&#x27;usage&#x27;</span> </span><br><span class="line">            		&#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//执行顺序：从下往上，从右向左的顺序</span></span><br></pre></td></tr></table></figure>

<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i react react-dom --save</span><br><span class="line">npm install --save-dev @babel/preset-react</span><br></pre></td></tr></table></figure>

<p>详细内容请看官网：<a href="https://webpack.js.org/loaders/babel-loader">babel-loader</a></p>
<hr>
<h2 id="三：Webpack进阶"><a href="#三：Webpack进阶" class="headerlink" title="三：Webpack进阶"></a>三：Webpack进阶</h2><h3 id="Tree-Shaking：只支持-ES-Module-例如-import-和-export-的静态结构特性的引入。当引入一个模块时，不引入所有的代码，只引入需要的代码"><a href="#Tree-Shaking：只支持-ES-Module-例如-import-和-export-的静态结构特性的引入。当引入一个模块时，不引入所有的代码，只引入需要的代码" class="headerlink" title="Tree Shaking：只支持 ES Module 例如 import 和 export 的静态结构特性的引入。当引入一个模块时，不引入所有的代码，只引入需要的代码"></a>Tree Shaking：只支持 ES Module 例如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"><code>import</code></a> 和 <code>export</code> 的静态结构特性的引入。当引入一个模块时，不引入所有的代码，只引入需要的代码</h3><p>在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">		hot: <span class="literal">true</span>,</span><br><span class="line">		hotOnly: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: []</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [],</span><br><span class="line">+	optimization: &#123; <span class="comment">//在开发环境中加，生产环境不加</span></span><br><span class="line">		usedExports: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 package.json 中：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">+ &quot;sideEffects&quot;: [&quot;*.css&quot;], //对 所有的css文件 不使用Tree shaking。如果填 false，就是都需要用到Tree shaking</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细内容请看官网：<a href="https://webpack.js.org/guides/tree-shaking">tree-shaking</a></p>
<hr>
<h3 id="Develoment-和Production模式的区分打包"><a href="#Develoment-和Production模式的区分打包" class="headerlink" title="Develoment 和Production模式的区分打包"></a>Develoment 和Production模式的区分打包</h3><p>在项目根目录下创建两个文件，webpack.dev.js，webpack.prod.js</p>
<p>webpack.dev.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">		hot: <span class="literal">true</span>,</span><br><span class="line">		hotOnly: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span>, </span><br><span class="line">			loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">		&#125;), </span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]),</span><br><span class="line">		<span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">	],</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		usedExports: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.prod.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span>, </span><br><span class="line">			loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">		&#125;), </span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]),</span><br><span class="line">		</span><br><span class="line">	],</span><br><span class="line">	</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 package.json 中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --config webpack.dev.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --config webpack.prod.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决 webpack.dev.js，webpack.prod.js 存在大量重复代码，在项目根目录下创建一个 webpack.common.js 文件，把公共代码提取出来</p>
<p>安装 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i webpack-merge -D </span><br></pre></td></tr></table></figure>

<p> webpack.common.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span>, </span><br><span class="line">			loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">		&#125;), </span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>],&#123;</span><br><span class="line">            root:path.resolve(__dirname,<span class="string">&#x27;../&#x27;</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">		</span><br><span class="line">	],</span><br><span class="line">	</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.dev.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> commenConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.commin.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">	</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">		hot: <span class="literal">true</span>,</span><br><span class="line">		hotOnly: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	plugins: [	</span><br><span class="line">		<span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">	],</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		usedExports: <span class="literal">true</span></span><br><span class="line">	&#125;,	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将开发配置和公共配置做结合</span></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commenConfig, devConfig)</span><br></pre></td></tr></table></figure>

<p>webpack.prod.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> commenConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.commin.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将线上配置和公共配置做结合</span></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commenConfig, prodConfig)</span><br></pre></td></tr></table></figure>

<p>最后在根目录下创建一个build文件夹，将 webpack.common.js ， webpack.dev.js ，webpack.prod.js 放在build文件夹下,统一管理。</p>
<p>在 package.json 中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --config ./build/webpack.dev.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --config ./build/webpack.prod.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细请看官网文档：<a href="https://webpack.js.org/guides/production">guides/production</a></p>
<hr>
<h3 id="Webpack和Code-Splitting"><a href="#Webpack和Code-Splitting" class="headerlink" title="Webpack和Code Splitting"></a>Webpack和Code Splitting</h3><p>安装： <code>npm i lodash --save</code>    <code>npm i babel-plugin-dynamic-import-webpack -D</code></p>
<p> 代码分割，和webpack无关，为了提升性能<br> webpack中实现代码分割，两种方式:</p>
<p>第一种方法:同步代码： 只需要在webpack.common.js中做optimization的配置即可</p>
<p>第二种方法:异步代码(import): 异步代码，无需做任何配置，会自动进行代码分割，放置到新的文件中</p>
<p>第一种方法：在 webpack.common.js 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: []</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [],</span><br><span class="line">+    optimization:&#123;</span><br><span class="line">+       splitChunks:&#123; <span class="comment">//启动代码分割，有默认配置项</span></span><br><span class="line">+            chunks:<span class="string">&#x27;all&#x27;</span></span><br><span class="line">+        &#125;  </span><br><span class="line">+    &#125;,</span><br><span class="line">	</span><br><span class="line">	output: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法在 <code>.babelrc</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	presets: [</span><br><span class="line">		[</span><br><span class="line">			<span class="string">&quot;@babel/preset-env&quot;</span>, &#123;</span><br><span class="line">				targets: &#123;</span><br><span class="line">					chrome: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">				&#125;,</span><br><span class="line">				useBuiltIns: <span class="string">&#x27;usage&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">	],</span><br><span class="line">+	plugins: [<span class="string">&quot;dynamic-import-webpack&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>详细内容请看官网：<a href="https://webpack.js.org/guides/code-splitting">code-splitting</a></p>
<hr>
<h3 id="SplitChunksPlugin-配置参数详解"><a href="#SplitChunksPlugin-配置参数详解" class="headerlink" title="SplitChunksPlugin 配置参数详解"></a>SplitChunksPlugin 配置参数详解</h3><p>安装：<code>npm install --save-dev @babeL/plugin-syntax-dynamic-import</code></p>
<p>在业务 index.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&quot;lodash&quot; */</span> <span class="string">&#x27;lodash&#x27;</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: _ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"> 		<span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">		element.innerHTML = _.join([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>], <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"> 		<span class="keyword">return</span> element;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> getComponent().then(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line"> 	<span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在 <code>.babelrc</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	presets: [</span><br><span class="line">		[</span><br><span class="line">			<span class="string">&quot;@babel/preset-env&quot;</span>, &#123;</span><br><span class="line">				targets: &#123;</span><br><span class="line">					chrome: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">				&#125;,</span><br><span class="line">				useBuiltIns: <span class="string">&#x27;usage&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">	],</span><br><span class="line">+	plugins: [<span class="string">&quot;@babeL/plugin-syntax-dynamic-import&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 webpack.common.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: []</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [],</span><br><span class="line">+    optimization:&#123;</span><br><span class="line">+       splitChunks:&#123; <span class="comment">//启动代码分割,不写有默认配置项</span></span><br><span class="line">+            chunks: <span class="string">&#x27;all&#x27;</span>,<span class="comment">//参数all/initial/async，只对所有/同步/异步进行代码分割</span></span><br><span class="line">              minSize: <span class="number">30000</span>, <span class="comment">//大于30kb才会对代码分割</span></span><br><span class="line">              maxSize: <span class="number">0</span>,</span><br><span class="line">              minChunks: <span class="number">1</span>,<span class="comment">//打包生成的文件，当一个模块至少用多少次时才会进行代码分割</span></span><br><span class="line">              maxAsyncRequests: <span class="number">5</span>,<span class="comment">//同时加载的模块数最多是5个</span></span><br><span class="line">              maxInitialRequests: <span class="number">3</span>,<span class="comment">//入口文件最多3个模块会做代码分割，否则不会</span></span><br><span class="line">              automaticNameDelimiter: <span class="string">&#x27;~&#x27;</span>,<span class="comment">//文件自动生成的连接符</span></span><br><span class="line">              name: <span class="literal">true</span>,</span><br><span class="line">            cacheGroups:&#123;<span class="comment">//对同步代码走缓存组</span></span><br><span class="line">             vendors: &#123;</span><br><span class="line">                  test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                  priority: <span class="number">-10</span>,<span class="comment">//谁优先级大就把打包后的文件放到哪个组</span></span><br><span class="line">    			filename:<span class="string">&#x27;vendors.js&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">              minChunks: <span class="number">2</span>,</span><br><span class="line">              priority: <span class="number">-20</span>,</span><br><span class="line">              reuseExistingChunk: <span class="literal">true</span>,<span class="comment">//模块已经被打包过了，就不用再打包了，复用之前的就可以</span></span><br><span class="line">              filename:<span class="string">&#x27;common.js&#x27;</span> <span class="comment">//打包之后的文件名   </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">+        &#125;  </span><br><span class="line">+    &#125;,</span><br><span class="line">	</span><br><span class="line">	output: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/plugins/split-chunks-plugin">split-chunks-plugin</a> </p>
<hr>
<h3 id="Lazy-Loading-懒加载，Chunk是什么？"><a href="#Lazy-Loading-懒加载，Chunk是什么？" class="headerlink" title="Lazy Loading 懒加载，Chunk是什么？"></a>Lazy Loading 懒加载，Chunk是什么？</h3><blockquote>
<p>用户当前需要用什么功能就只加载这个功能对应的代码，也就是所谓的按需加载 在给单页应用做按需加载优化时，一般采用以下原则：</p>
<ul>
<li>对网站功能进行划分，每一类一个chunk</li>
<li>对于首次打开页面需要的功能直接加载，尽快展示给用户</li>
<li>某些依赖大量代码的功能点可以按需加载</li>
<li>被分割出去的代码需要一个按需加载的时机</li>
</ul>
<p>每一个文件就是一个 chunk</p>
</blockquote>
<p>详细请看官方文档：<a href="https://webpack.js.org/guides/lazy-loading">lazy-loading</a></p>
<hr>
<h3 id="打包分析，Preloading，Prefetching"><a href="#打包分析，Preloading，Prefetching" class="headerlink" title="打包分析，Preloading，Prefetching"></a>打包分析，Preloading，Prefetching</h3><p>打开网址：webpack分析工具：<code>https://github.com/webpack/analyse</code></p>
<p>在 package.json 中</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev-build&quot;</span>: <span class="string">&quot;webpack --profile --json &gt; stats.json --config ./build/webpack.dev.js&quot;</span>, <span class="comment">//把打包过程的描述放在stats.json文件中</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --config ./build/webpack.dev.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --config ./build/webpack.prod.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在控制台运行  <code>npm run dev-build</code> ,在根目录下生成 stats.json 文件。打开网址 <code>http://webpack.github.io/analyse/</code> ,把stats.json文件传上去，会出现分析结果。</p>
<p>详细请看官方文档：<a href="https://webpack.js.org/guides/code-splitting/#bundle-analysis">bundle-analysis 打包分析工具</a> </p>
<h4 id="介绍-webpack-bundle-analyzer-的使用："><a href="#介绍-webpack-bundle-analyzer-的使用：" class="headerlink" title="介绍 webpack-bundle-analyzer 的使用："></a><strong>介绍 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 的使用：</strong></h4><p>通过使用<a href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a>可以看到项目各模块的大小，可以按需优化。</p>
<p>官网图镇楼：</p>
<p><img src="https://cloud.githubusercontent.com/assets/302213/20628702/93f72404-b338-11e6-92d4-9a365550a701.gif"></p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NPM</span></span><br><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br><span class="line"><span class="comment"># Yarn</span></span><br><span class="line">yarn add -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>

<p>配置：在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(</span><br><span class="line">    	&#123;</span><br><span class="line">              analyzerMode: <span class="string">&#x27;server&#x27;</span>,</span><br><span class="line">              analyzerHost: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">              analyzerPort: <span class="number">8889</span>,</span><br><span class="line">              reportFilename: <span class="string">&#x27;report.html&#x27;</span>,</span><br><span class="line">              defaultSizes: <span class="string">&#x27;parsed&#x27;</span>,</span><br><span class="line">              openAnalyzer: <span class="literal">true</span>,</span><br><span class="line">              generateStatsFile: <span class="literal">false</span>,</span><br><span class="line">              statsFilename: <span class="string">&#x27;stats.json&#x27;</span>,</span><br><span class="line">              statsOptions: <span class="literal">null</span>,</span><br><span class="line">              logLevel: <span class="string">&#x27;info&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：在 package.json 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;analyz&quot;</span>: <span class="string">&quot;NODE_ENV=production npm_config_report=true npm run build&quot;</span></span><br></pre></td></tr></table></figure>

<p>在线分析:在 控制台输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack --profile --json &gt; stats.json</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>profile：记录下构建过程中的耗时信息；</li>
<li>json：以 JSON 的格式输出构建结果，最后只输出一个 .json 文件，这个文件中包括所有构建相关的信息。</li>
<li>Webpack 官方提供了一个可视化分析工具 <a href="https://webpack.github.io/analyse">Webpack Analyse</a></li>
<li>Modules：展示所有的模块，每个模块对应一个文件。并且还包含所有模块之间的依赖关系图、模块路径、模块ID、模块所属 Chunk、模块大小；</li>
<li>Chunks：展示所有的代码块，一个代码块中包含多个模块。并且还包含代码块的ID、名称、大小、每个代码块包含的模块数量，以及代码块之间的依赖关系图；</li>
<li>Assets：展示所有输出的文件资源，包括 .js、.css、图片等。并且还包括文件名称、大小、该文件来自哪个代码块；</li>
<li>Warnings：展示构建过程中出现的所有警告信息；</li>
<li>Errors：展示构建过程中出现的所有错误信息；</li>
<li>Hints：展示处理每个模块的过程中的耗时。</li>
</ul>
</blockquote>
<p>打开谷歌控制台查看代码使用率，按 <code>ctrl+shift+p</code>  ，输入 coverage 查看。</p>
<h3 id="预取-预加载模块-prefetch-preload-module"><a href="#预取-预加载模块-prefetch-preload-module" class="headerlink" title="预取/预加载模块(prefetch/preload module)"></a>预取/预加载模块(prefetch/preload module)</h3><p>假如有一个HomePage组件，其内部有一个LoginButton.js登陆组件，再点击后按需加载 LoginModel 组件。</p>
<p>LoginButton.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">&#x27;LoginModal&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这会生成 <code>&lt;link rel=&quot;prefetch&quot; href=&quot;login-modal-chunk.js&quot;&gt;</code> 并追加到页面头部，指示着浏览器在闲置时间预取 <code>login-modal-chunk.js</code> 文件。就是说，只要首页加载完成，就会在空闲时间把登录模块也加载了。</p>
<p>总结：</p>
<blockquote>
<p>/* webpackPrefetch: true */：把主加载流程加载完毕，在空闲时在加载其他，等再点击其他时，只需要从缓存中读取即可，性能更好。推荐使用，提高代码利用率。把一些交互后才能用到的代码写到异步组件里，通过懒加载的形式，去把这块的代码逻辑加载进来，性能提升，页面访问速度更快。</p>
<p>/* webpackPreload: true */: 和主加载流程一起并行加载。</p>
</blockquote>
<p>详细请看官方文档：<a href="https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules">prefetchingpreloading-modules</a></p>
<hr>
<h3 id="CSS文件的代码分割"><a href="#CSS文件的代码分割" class="headerlink" title="CSS文件的代码分割"></a>CSS文件的代码分割</h3><p>在 webpack.config.js 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [],</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		splitChunks: &#123;</span><br><span class="line">      	 chunks: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,<span class="comment">//入口文件打包后生成的文件名</span></span><br><span class="line">+         chunkFilename: <span class="string">&#x27;[name].chunk.js&#x27;</span>,<span class="comment">//main.js异步加载的间接的js文件。用来打包import(&#x27;module&#x27;)方法中引入的模块</span></span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为CSS的下载和JS可以并行,当一个HTML文件很大的时候，我们可以把CSS单独提取出来加载</p>
<ul>
<li><a href="https://github.com/webpack-contrib/mini-css-extract-plugin">mini-css-extract-plugin</a>:一般在线上环境使用这个插件，因为在开发环境中不支持HMR。</li>
<li>filename 打包入口文件</li>
<li>chunkFilename 用来打包<code>import(&#39;module&#39;)</code>方法中引入的模块</li>
</ul>
<p>安装 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//抽离css文件</span><br><span class="line">npm install --save-dev mini-css-extract-plugin</span><br><span class="line">//压缩css文件</span><br><span class="line">npm i optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>在 webpack.prod.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">&quot;optimize-css-assets-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules:[&#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">+				MiniCssExtractPlugin.loader, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">+				MiniCssExtractPlugin.loader,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">+	optimization: &#123;</span><br><span class="line">		minimizer: [<span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">+		<span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">			filename: <span class="string">&#x27;[name].css&#x27;</span>,<span class="comment">//直接引用的css文件</span></span><br><span class="line">			chunkFilename: <span class="string">&#x27;[name].chunk.css&#x27;</span><span class="comment">//间接引用的css文件</span></span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, prodConfig);</span><br></pre></td></tr></table></figure>

<p>在 webpack.dev.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">		hot: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">                <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">	],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, devConfig);</span><br></pre></td></tr></table></figure>

<p>在 webpack.common.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span>, </span><br><span class="line">			loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">		&#125;), </span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>], &#123;</span><br><span class="line">			root: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	],</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		usedExports: <span class="literal">true</span>,<span class="comment">//TreeShaking</span></span><br><span class="line">		splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		chunkFilename: <span class="string">&#x27;[name].chunk.js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 package.json 中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;sideEffects&quot;</span>: [<span class="string">&quot;*.css&quot;</span>] <span class="comment">//除了css文件，其余的都TreeShaking</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/plugins/mini-css-extract-plugin">mini-css-extract-plugin</a></p>
<hr>
<h3 id="Webpack-与浏览器缓存（Caching）"><a href="#Webpack-与浏览器缓存（Caching）" class="headerlink" title="Webpack 与浏览器缓存（Caching）"></a>Webpack 与浏览器缓存（Caching）</h3><p>在 webpack.common.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span>, </span><br><span class="line">			loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">		&#125;), </span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>], &#123;</span><br><span class="line">			root: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	],</span><br><span class="line">	optimization: &#123;</span><br><span class="line">+		runtimeChunk: &#123;<span class="comment">//兼容老版本webpack4，把manifest打包到runtime里，不影响业务代码和第三方模块</span></span><br><span class="line">			name: <span class="string">&#x27;runtime&#x27;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		usedExports: <span class="literal">true</span>,</span><br><span class="line">		splitChunks: &#123;</span><br><span class="line">          chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">          cacheGroups: &#123;</span><br><span class="line">            vendors: &#123;</span><br><span class="line">                test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                priority: <span class="number">-10</span>,</span><br><span class="line">                name: <span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">   	   &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	performance: <span class="literal">false</span>,<span class="comment">//禁止提示性能上的一些问题</span></span><br><span class="line">+	output: &#123;</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 webpack.dev.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">		hot: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">	],</span><br><span class="line">+	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		chunkFilename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, devConfig);</span><br></pre></td></tr></table></figure>

<p>在 webpack.prod.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">&quot;optimize-css-assets-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules:[&#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				MiniCssExtractPlugin.loader, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				MiniCssExtractPlugin.loader,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		minimizer: [<span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">			filename: <span class="string">&#x27;[name].css&#x27;</span>,</span><br><span class="line">			chunkFilename: <span class="string">&#x27;[name].chunk.css&#x27;</span></span><br><span class="line">		&#125;)</span><br><span class="line">	],</span><br><span class="line">+	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].[contenthash].js&#x27;</span>, <span class="comment">//源代码不变，hash值就不会变，解决浏览器缓存问题。打包上线时，用户只需要更新有变化的代码，没有变化的从浏览器缓存读取</span></span><br><span class="line">		chunkFilename: <span class="string">&#x27;[name].[contenthash].js&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, prodConfig);</span><br></pre></td></tr></table></figure>

<p>详细请看官网文档：<a href="https://webpack.js.org/concepts/manifest/#manifest">manifest</a></p>
<hr>
<h3 id="Shimming-垫片"><a href="#Shimming-垫片" class="headerlink" title="Shimming (垫片)"></a>Shimming (垫片)</h3><p>在 webpack.common.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">			use: [&#123;</span><br><span class="line">				loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				loader: <span class="string">&#x27;imports-loader?this=&gt;window&#x27;</span></span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">		&#125;), </span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>], &#123;</span><br><span class="line">			root: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>)</span><br><span class="line">		&#125;),</span><br><span class="line">+		<span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">			$: <span class="string">&#x27;jquery&#x27;</span>,<span class="comment">//发现模块中有$字符串，就自动引入iquery,就可以用jquery</span></span><br><span class="line">			_join: [<span class="string">&#x27;lodash&#x27;</span>, <span class="string">&#x27;join&#x27;</span>]<span class="comment">//_join代表lodash里的join方法</span></span><br><span class="line">		&#125;),</span><br><span class="line">	],</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		runtimeChunk: &#123;</span><br><span class="line">			name: <span class="string">&#x27;runtime&#x27;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		usedExports: <span class="literal">true</span>,</span><br><span class="line">		splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">      	vendors: &#123;</span><br><span class="line">      		test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">      		priority: <span class="number">-10</span>,</span><br><span class="line">      		name: <span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	performance: <span class="literal">false</span>,</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果想让每个js模块的this都指向window："><a href="#如果想让每个js模块的this都指向window：" class="headerlink" title="如果想让每个js模块的this都指向window："></a><code>如果想让每个js模块的this都指向window：</code></h4><p>安装： <code>npm install imports-loader -D</code></p>
<p>在 webpack.common.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">			use: [&#123;</span><br><span class="line">				loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">			&#125;, &#123;<span class="comment">//每个js模块的this都指向window</span></span><br><span class="line">+				loader: <span class="string">&#x27;imports-loader?this=&gt;window&#x27;</span></span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">		&#125;), </span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>], &#123;</span><br><span class="line">			root: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>)</span><br><span class="line">		&#125;),</span><br><span class="line">+		<span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">			$: <span class="string">&#x27;jquery&#x27;</span>,<span class="comment">//发现模块中有$字符串，就自动引入iquery,就可以用jquery</span></span><br><span class="line">			_join: [<span class="string">&#x27;lodash&#x27;</span>, <span class="string">&#x27;join&#x27;</span>]<span class="comment">//_join代表lodash里的join方法</span></span><br><span class="line">		&#125;),</span><br><span class="line">	],</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		runtimeChunk: &#123;</span><br><span class="line">			name: <span class="string">&#x27;runtime&#x27;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		usedExports: <span class="literal">true</span>,</span><br><span class="line">		splitChunks: &#123;</span><br><span class="line">          chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">          cacheGroups: &#123;</span><br><span class="line">            vendors: &#123;</span><br><span class="line">                test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                priority: <span class="number">-10</span>,</span><br><span class="line">                name: <span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	performance: <span class="literal">false</span>,</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/loaders/imports-loader">imports-loader</a>   <a href="https://webpack.js.org/guides/shimming">shimming</a> </p>
<hr>
<h3 id="环境变量的使用"><a href="#环境变量的使用" class="headerlink" title="环境变量的使用"></a>环境变量的使用</h3><p>只需要一个common.js文件通过在package.json中传递不同的参数，区分是开发环境还是生产环境。</p>
<p>在 package.json 中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;haiyang&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sideEffects&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;*.css&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev-build&quot;</span>: <span class="string">&quot;webpack --config ./build/webpack.common.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --config ./build/webpack.common.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --env.production --config ./build/webpack.common.js&quot;</span> <span class="comment">//通过--env.production,把环境变量传进去</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@babel/core&quot;</span>: <span class="string">&quot;^7.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/plugin-syntax-dynamic-import&quot;</span>: <span class="string">&quot;^7.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/plugin-transform-runtime&quot;</span>: <span class="string">&quot;^7.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/preset-env&quot;</span>: <span class="string">&quot;^7.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/preset-react&quot;</span>: <span class="string">&quot;^7.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;autoprefixer&quot;</span>: <span class="string">&quot;^9.3.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span>: <span class="string">&quot;^8.0.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clean-webpack-plugin&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;css-loader&quot;</span>: <span class="string">&quot;^1.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;express&quot;</span>: <span class="string">&quot;^4.16.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;file-loader&quot;</span>: <span class="string">&quot;^2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;imports-loader&quot;</span>: <span class="string">&quot;^0.8.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;mini-css-extract-plugin&quot;</span>: <span class="string">&quot;^0.5.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;node-sass&quot;</span>: <span class="string">&quot;^4.10.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;optimize-css-assets-webpack-plugin&quot;</span>: <span class="string">&quot;^5.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postcss-loader&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sass-loader&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;style-loader&quot;</span>: <span class="string">&quot;^0.23.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url-loader&quot;</span>: <span class="string">&quot;^1.1.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.1.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-dev-middleware&quot;</span>: <span class="string">&quot;^3.4.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.1.10&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-merge&quot;</span>: <span class="string">&quot;^4.1.5&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@babel/polyfill&quot;</span>: <span class="string">&quot;^7.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/runtime&quot;</span>: <span class="string">&quot;^7.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@babel/runtime-corejs2&quot;</span>: <span class="string">&quot;^7.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jquery&quot;</span>: <span class="string">&quot;^3.3.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lodash&quot;</span>: <span class="string">&quot;^4.17.11&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^16.6.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^16.6.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^4.25.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在 webpack.common.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.dev.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.prod.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">			use: [&#123;</span><br><span class="line">				loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				loader: <span class="string">&#x27;imports-loader?this=&gt;window&#x27;</span></span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">		&#125;), </span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>], &#123;</span><br><span class="line">			root: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>)</span><br><span class="line">		&#125;),</span><br><span class="line">		<span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">			$: <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">			_join: [<span class="string">&#x27;lodash&#x27;</span>, <span class="string">&#x27;join&#x27;</span>]</span><br><span class="line">		&#125;),</span><br><span class="line">	],</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		runtimeChunk: &#123;</span><br><span class="line">			name: <span class="string">&#x27;runtime&#x27;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		usedExports: <span class="literal">true</span>,</span><br><span class="line">		splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">      	vendors: &#123;</span><br><span class="line">      		test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">      		priority: <span class="number">-10</span>,</span><br><span class="line">      		name: <span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	performance: <span class="literal">false</span>,</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(env &amp;&amp; env.production) &#123;<span class="comment">//线上环境</span></span><br><span class="line">		<span class="keyword">return</span> merge(commonConfig, prodConfig);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;<span class="comment">//开发环境</span></span><br><span class="line">		<span class="keyword">return</span> merge(commonConfig, devConfig);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 webpack.dev.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">		hot: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				<span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">	],</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">		chunkFilename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = devConfig;</span><br></pre></td></tr></table></figure>

<p>在webpack.prod.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">&quot;optimize-css-assets-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">	devtool: <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules:[&#123;</span><br><span class="line">			test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				MiniCssExtractPlugin.loader, </span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						importLoaders: <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">			use: [</span><br><span class="line">				MiniCssExtractPlugin.loader,</span><br><span class="line">				<span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		minimizer: [<span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">			filename: <span class="string">&#x27;[name].css&#x27;</span>,</span><br><span class="line">			chunkFilename: <span class="string">&#x27;[name].chunk.css&#x27;</span></span><br><span class="line">		&#125;)</span><br><span class="line">	],</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].[contenthash].js&#x27;</span>,</span><br><span class="line">		chunkFilename: <span class="string">&#x27;[name].[contenthash].js&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = prodConfig;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四：Webpack实战配置案例"><a href="#四：Webpack实战配置案例" class="headerlink" title="四：Webpack实战配置案例"></a>四：Webpack实战配置案例</h2><h3 id="Library的打包：库代码通过webpack进行打包"><a href="#Library的打包：库代码通过webpack进行打包" class="headerlink" title="Library的打包：库代码通过webpack进行打包"></a>Library的打包：库代码通过webpack进行打包</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/library%2041">41</a>】</p>
<p>在 webpack.config.js 中： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">	entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">	externals: <span class="string">&#x27;lodash&#x27;</span>,</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">		filename: <span class="string">&#x27;library.js&#x27;</span>,</span><br><span class="line">		library: <span class="string">&#x27;root&#x27;</span>, <span class="comment">//支持通过&lt;scritp src=ilibrary. js&#x27;&gt;&lt;/script&gt; 标签引入，在全局变量增加一个root变量</span></span><br><span class="line">		libraryTarget: <span class="string">&#x27;umd&#x27;</span> <span class="comment">//别人用的时候，通过任何形式引入库都可以，比如AMD，CMD，ES MODULE，Commonjs</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// library: &#x27;root&#x27;,//打包生成全局变量root</span></span><br><span class="line">		<span class="comment">// libraryTarget: &#x27;this&#x27; //把全局变量root挂载到this上，可以填umd，this，window,global</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// externals: &#123;</span></span><br><span class="line">        <span class="comment">// 	lodash:&#123;</span></span><br><span class="line">        <span class="comment">// 		root：&#x27;_&#x27;, //是用script标签引入进来的，必须在全局注入一个 _ 变量，下面的library才能正常执行</span></span><br><span class="line">        <span class="comment">// 		commonjs:&#x27;lodash&#x27;,//在用commonjs规范引入是，名字必须是lodash</span></span><br><span class="line">        <span class="comment">// 	&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 package.json 中：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;main&quot;: &quot;./dist/library.js&quot;, //最终要给别人使用的</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://www.npmjs.com/">npm</a>  官网注册一个账号，在命令行输入 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//添加用户名和密码</span><br><span class="line">npm adduser </span><br><span class="line">//把项目发布到npm官网上</span><br><span class="line">npm publish</span><br><span class="line">//但别人用你发布的库时</span><br><span class="line">npm i + 库名 </span><br></pre></td></tr></table></figure>
<p>详细请看官方文档：<a href="https://webpack.js.org/configuration/externals">externals</a>   <a href="https://webpack.js.org/guides/author-libraries">author-libraries</a></p>
<hr>
<h3 id="Progressive-Web-Application：在webpack中配置pwa"><a href="#Progressive-Web-Application：在webpack中配置pwa" class="headerlink" title="Progressive Web Application：在webpack中配置pwa"></a>Progressive Web Application：在webpack中配置pwa</h3><p>渐进式网络应用程序，PWA 可以用来做很多事。其中最重要的是，在**离线(offline)**时应用程序能够继续运行功能。这是通过使用名为 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">Service Workers</a> 的 web 技术来实现的。线上环境时才用到pwa,开发时不需要</p>
<p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2042">42</a>】</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//模拟服务器</span><br><span class="line">npm i http-server -D</span><br><span class="line">//添加 workbox-webpack-plugin 插件，然后调整 webpack.config.js 文件</span><br><span class="line">npm install workbox-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>在 package.json 中：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line"> +   &quot;start&quot;: &quot;http-server dist&quot;,//在dist目录下运行http-server服务</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.dev.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>线上环境时才用到pwa,开发时不需要，只需要改 webpack.prod.js ，</p>
<p>在  webpack.prod.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WorkboxPlugin = <span class="built_in">require</span>(<span class="string">&#x27;workbox-webpack-plugin&#x27;</span>);</span><br><span class="line">plugins: [</span><br><span class="line">		<span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">			filename: <span class="string">&#x27;[name].css&#x27;</span>,</span><br><span class="line">			chunkFilename: <span class="string">&#x27;[name].chunk.css&#x27;</span></span><br><span class="line">		&#125;),</span><br><span class="line">+		<span class="keyword">new</span> WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">			clientsClaim: <span class="literal">true</span>,</span><br><span class="line">			skipWaiting: <span class="literal">true</span></span><br><span class="line">		&#125;)</span><br><span class="line">	],</span><br></pre></td></tr></table></figure>

<p>在业务代码 index.js 中使用pwa</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello, haiyang&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123; <span class="comment">//如果浏览器支持serviceWorker，就执行以下代码</span></span><br><span class="line">	<span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		navigator.serviceWorker.register(<span class="string">&#x27;/service-worker.js&#x27;</span>)</span><br><span class="line">			.then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;<span class="comment">//注册成功</span></span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">&#x27;service-worker registed&#x27;</span>);</span><br><span class="line">			&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="comment">//没注册成功</span></span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">&#x27;service-worker register error&#x27;</span>);</span><br><span class="line">			&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>详细请看官方文档：<a href="https://webpack.js.org/guides/progressive-web-application">progressive-web-application</a> </p>
<hr>
<h3 id="TypeScript-的打包配置"><a href="#TypeScript-的打包配置" class="headerlink" title="TypeScript 的打包配置"></a>TypeScript 的打包配置</h3><p><a href="https://www.typescriptlang.org/">TypeScript</a> 是 JavaScript 的超集，为其增加了类型系统，可以编译为普通 JavaScript 代码。这篇指南里我们将会学习是如何将 webpack 和 TypeScript 进行集成。</p>
<p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/type-script">43</a>】</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev typescript ts-loader</span><br></pre></td></tr></table></figure>



<p>在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">	entry: <span class="string">&#x27;./src/index.tsx&#x27;</span>,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123;</span><br><span class="line">			test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">			use: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目根目录下创建 tsconfig.json 文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;compilerOpitons&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es6&quot;</span>,<span class="comment">//模块引入的方式</span></span><br><span class="line">		<span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,<span class="comment">//转换为es5，在大部分浏览器都能运行</span></span><br><span class="line">		<span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>, <span class="comment">//在typescript中允许引入js文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在从 npm 安装 third party library(第三方库) 时，一定要记得同时安装此 library 的类型声明文件(typing definition)。你可以从 <a href="http://microsoft.github.io/TypeSearch/">TypeSearch</a> 中找到并安装这些第三方库的类型声明文件。在使用时，哪有错可以有警告提示，方便改错。</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//在typescript里用loadah</span><br><span class="line">npm install --save-dev @types/lodash</span><br></pre></td></tr></table></figure>



<p>详细请看官方文档：<a href="https://webpack.js.org/guides/typescript">typescript</a></p>
<hr>
<h3 id="使用-WebpackDevServer-实现请求转发"><a href="#使用-WebpackDevServer-实现请求转发" class="headerlink" title="使用 WebpackDevServer 实现请求转发"></a>使用 WebpackDevServer 实现请求转发</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2044">44</a>】</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//向服务器发送axios请求</span><br><span class="line">npm i axios -D</span><br></pre></td></tr></table></figure>

<p>在 index.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">		axios.get(<span class="string">&#x27;/react/api/header.json&#x27;</span>)</span><br><span class="line">			.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(res);</span><br><span class="line">			&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">		hot: <span class="literal">true</span>,</span><br><span class="line">		hotOnly: <span class="literal">true</span>,</span><br><span class="line">+		proxy: &#123;<span class="comment">//开发时方便接口转发，线上不用</span></span><br><span class="line">			<span class="string">&#x27;/react/api&#x27;</span>: &#123;<span class="comment">//访问 /react/api 时，代理到 target 上</span></span><br><span class="line">				target: <span class="string">&#x27;https://www.dell-lee.com&#x27;</span>,</span><br><span class="line">				secure: <span class="literal">false</span>,<span class="comment">//对https协议的网址的请求的转发</span></span><br><span class="line">     <span class="comment">//   拦截，请求的是html,不走代理直接返回  /index.html文件          </span></span><br><span class="line">	<span class="comment">//bypass: function(req, res, proxyOptions) &#123;</span></span><br><span class="line">      <span class="comment">//    if (req.headers.accept.indexOf(&#x27;html&#x27;) !== -1) &#123;</span></span><br><span class="line">      <span class="comment">//      console.log(&#x27;Skipping proxy for browser request.&#x27;);</span></span><br><span class="line">       <span class="comment">//     return &#x27;/index.html&#x27;;</span></span><br><span class="line">       <span class="comment">//   &#125;</span></span><br><span class="line">     <span class="comment">//   &#125;,</span></span><br><span class="line">				pathRewrite: &#123;</span><br><span class="line">					<span class="string">&#x27;header.json&#x27;</span>: <span class="string">&#x27;demo.json&#x27;</span> <span class="comment">//最后拿的是demo.json的数据</span></span><br><span class="line">				&#125;,</span><br><span class="line">				changeOrigin: <span class="literal">true</span>,<span class="comment">//解决网站对接口的限制</span></span><br><span class="line">				headers: &#123;<span class="comment">//变更请求头</span></span><br><span class="line">					host: <span class="string">&#x27;www.dell-lee.com&#x27;</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/configuration/dev-server#devserverproxy">devserverproxy</a> </p>
<hr>
<h3 id="WebpackDevServer-解决单页面应用路由问题"><a href="#WebpackDevServer-解决单页面应用路由问题" class="headerlink" title="WebpackDevServer 解决单页面应用路由问题"></a>WebpackDevServer 解决单页面应用路由问题</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2045">45</a>】</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i react-router-dom --save</span><br></pre></td></tr></table></figure>

<p>在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;<span class="comment">//配置只在开发时有效，上线时后端也需配置</span></span><br><span class="line">		contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">		open: <span class="literal">true</span>,</span><br><span class="line">		port: <span class="number">8080</span>,</span><br><span class="line">		hot: <span class="literal">true</span>,</span><br><span class="line">		hotOnly: <span class="literal">true</span>,</span><br><span class="line">+		historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    	<span class="comment">//historyApiFallback: &#123;</span></span><br><span class="line">         <span class="comment">// rewrites: [//访问任何路径都展示index.html页面</span></span><br><span class="line">          <span class="comment">//  &#123; from: /\.*/, to: &#x27;/index.html&#x27; &#125;,</span></span><br><span class="line">          <span class="comment">//]</span></span><br><span class="line">        <span class="comment">//&#125;,</span></span><br><span class="line">		proxy: &#123;</span><br><span class="line">			<span class="string">&#x27;/react/api&#x27;</span>: &#123;</span><br><span class="line">				target: <span class="string">&#x27;https://www.dell-lee.com&#x27;</span>,</span><br><span class="line">				secure: <span class="literal">false</span>,</span><br><span class="line">				pathRewrite: &#123;</span><br><span class="line">					<span class="string">&#x27;header.json&#x27;</span>: <span class="string">&#x27;demo.json&#x27;</span></span><br><span class="line">				&#125;,</span><br><span class="line">				changeOrigin: <span class="literal">true</span>,</span><br><span class="line">				headers: &#123;</span><br><span class="line">					host: <span class="string">&#x27;www.dell-lee.com&#x27;</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/configuration/dev-server#devserverhistoryapifallback">devserverhistoryapifallback</a> </p>
<hr>
<h3 id="EsLint-在-Webpack-中的配置"><a href="#EsLint-在-Webpack-中的配置" class="headerlink" title="EsLint 在 Webpack 中的配置"></a>EsLint 在 Webpack 中的配置</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2046">46</a>】</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//安装eslint工具，规范项目中的代码</span><br><span class="line">npm i eslint -D</span><br><span class="line">npm i babel-eslint -D</span><br><span class="line">npm i eslint-loader -D</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//快速生成eslint配置</span><br><span class="line">npx eslint --init</span><br></pre></td></tr></table></figure>

<p>在 .eslintrc.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="string">&quot;extends&quot;</span>: <span class="string">&quot;airbnb&quot;</span>,</span><br><span class="line">  <span class="string">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span>,</span><br><span class="line">  <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;react/prefer-stateless-function&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;react/jsx-filename-extension&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  globals: &#123;</span><br><span class="line">    <span class="built_in">document</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://eslint.cn/docs/user-guide/configuring">eslint</a> </p>
<p>在 vscode 编辑器里安装 eslint 插件，自动检测语法错误。（推荐使用）</p>
<p>在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">+		overlay: <span class="literal">true</span>,<span class="comment">//在浏览器弹出提示有错误</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">			exclude: <span class="regexp">/node_modules/</span>, </span><br><span class="line">	+		use: [<span class="string">&#x27;babel-loader&#x27;</span>, <span class="string">&#x27;eslint-loader&#x27;</span>] <span class="comment">//先检查代码写的是否规范，在转换成es5</span></span><br><span class="line">		&#125;,</span><br><span class="line">        ...],</span><br></pre></td></tr></table></figure>

<p>在真实项目中，也可以不在webpack 中配置eslint，在提交git仓库时，git 钩子 eslint src 。但是没有图形交互式的错误提示。</p>
<p>详细请看官方文档：<a href="https://webpack.js.org/loaders/eslint-loader">eslint-loader</a></p>
<hr>
<h3 id="提升-webpack-打包速度的方法"><a href="#提升-webpack-打包速度的方法" class="headerlink" title="提升 webpack 打包速度的方法"></a>提升 webpack 打包速度的方法</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2047">47</a>】</p>
<h4 id="1-跟上技术的迭代（Node，Npm，Yarn）"><a href="#1-跟上技术的迭代（Node，Npm，Yarn）" class="headerlink" title="1.跟上技术的迭代（Node，Npm，Yarn）"></a>1.跟上技术的迭代（Node，Npm，Yarn）</h4><h4 id="2-在尽可能少的模块上应用-Loader"><a href="#2-在尽可能少的模块上应用-Loader" class="headerlink" title="2.在尽可能少的模块上应用 Loader"></a>2.在尽可能少的模块上应用 Loader</h4><h4 id="3-Plugin-尽可能精简并确保可靠"><a href="#3-Plugin-尽可能精简并确保可靠" class="headerlink" title="3.Plugin 尽可能精简并确保可靠"></a>3.Plugin 尽可能精简并确保可靠</h4><h4 id="4-resolve-参数合理配置"><a href="#4-resolve-参数合理配置" class="headerlink" title="4.resolve 参数合理配置"></a>4.resolve 参数合理配置</h4><p>   仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2048">48</a>】</p>
<p>引入资源文件写后缀，像 图片文件（.jpg, .png, .svg），逻辑代码配置在extensions中:extensions: [‘.js’, ‘.jsx’]</p>
<h4 id="5-使用-DLLPlugin-提高打包速度"><a href="#5-使用-DLLPlugin-提高打包速度" class="headerlink" title="5.使用 DLLPlugin 提高打包速度"></a>5.使用 DLLPlugin 提高打包速度</h4><p>详细请看官方文档：<a href="https://webpack.js.org/plugins/dll-plugin/#root">dll-plugin</a></p>
<p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2049">49</a>】</p>
<p>实现第三方模块只打包一次</p>
<p>安装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i add-asset-html-webpack-plugin --save</span><br></pre></td></tr></table></figure>



<p>在 build 文件夹里创建 webpack.dll.js 文件：把第三方模块单独进行打包，生成一个vendors.dll.js 文件，所有的第三方模块都在这个文件里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">	entry: &#123;</span><br><span class="line">		vendors: [<span class="string">&#x27;lodash&#x27;</span>],</span><br><span class="line">		react: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">		jquery: [<span class="string">&#x27;jquery&#x27;</span>]</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>),</span><br><span class="line">		library: <span class="string">&#x27;[name]&#x27;</span><span class="comment">//打包生成的库名，通过全局变量的形式暴露到全局</span></span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> webpack.DllPlugin(&#123;<span class="comment">//对暴露到全局的代码进行分析，生成vendors.manifest.json 的映射文件，</span></span><br><span class="line">			name: <span class="string">&#x27;[name]&#x27;</span>,</span><br><span class="line">			path: path.resolve(__dirname, <span class="string">&#x27;../dll/[name].manifest.json&#x27;</span>),</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 webpack.common.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AddAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> files = fs.readdirSync(path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>));</span><br><span class="line">files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="regexp">/.*\.dll.js/</span>.test(file)) &#123;</span><br><span class="line">		plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;<span class="comment">//将打包好的dll文件挂载到html中</span></span><br><span class="line">			filepath: path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>, file)</span><br><span class="line">		&#125;))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="regexp">/.*\.manifest.json/</span>.test(file)) &#123;</span><br><span class="line">		plugins.push(<span class="keyword">new</span> webpack.DllReferencePlugin(&#123;<span class="comment">//分析第三方模块是否已经在dll文件里，如果里面有就不用再node_modules在分析打包了</span></span><br><span class="line">			manifest: path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>, file)</span><br><span class="line">		&#125;))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 package.json 中 添加一个脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev-build&quot;: &quot;webpack --config .&#x2F;build&#x2F;webpack.dev.js&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --config .&#x2F;build&#x2F;webpack.dev.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config .&#x2F;build&#x2F;webpack.prod.js&quot;,</span><br><span class="line"> +   &quot;build:dll&quot;: &quot;webpack --config .&#x2F;build&#x2F;webpack.dll.js&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 控制台 先 执行 npm run build:dll 生成对应的 XXX.dll.js 和 XXX.manifest.json 文件。以后再执行 npm run build 或 npm run dev 时，就不用再node_modules查找对应模块进行分析，直接用打包好的 XXX.dll.js就可以，节省打包速度。</p>
<p>总结：</p>
<blockquote>
<p>如果不使用使用 DLLPlugin 插件，当引入第三方模块时，每一次打包都要进行分析，是消耗打包的性能的。使用 DLLPlugin 提高打包速度,在第一次打包时，把第三方模块单独打包生成一个文件 vendors.dll.js ，之后在打包时就可以直接从 vendors.dll.js 中引入之前打包好的第三方模块，速度就会变快。</p>
<p>要想实现，就得做一些配置：</p>
<p>先配置 webpack.dll.js 文件，在配置 webpack.common.js 文件</p>
</blockquote>
<p>==============================================================</p>
<p>.dll 为后缀的文件称为动态链接库，在一个动态链接库中可以包含给其他模块调用的函数和数据</p>
<ul>
<li>把基础模块独立出来打包到单独的动态连接库里</li>
<li>当需要导入的模块在动态连接库里的时候，模块不能再次被打包，而是去动态连接库里获取 <a href="https://webpack.js.org/plugins/dll-plugin/">dll-plugin</a></li>
</ul>
<h3 id="定义Dll"><a href="#定义Dll" class="headerlink" title="定义Dll"></a>定义Dll</h3><ul>
<li>DllPlugin插件： 用于打包出一个个动态连接库</li>
<li>DllReferencePlugin: 在配置文件中引入DllPlugin插件打包好的动态连接库</li>
</ul>
<p>在 webpack.dll.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        react: [<span class="string">&#x27;react&#x27;</span>] <span class="comment">//react模块打包到一个动态连接库</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].dll.js&#x27;</span>, <span class="comment">//输出动态连接库的文件名称</span></span><br><span class="line">        library: <span class="string">&#x27;_dll_[name]&#x27;</span> <span class="comment">//全局变量名称</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            name: <span class="string">&#x27;_dll_[name]&#x27;</span>, <span class="comment">//和output.library中一致，值就是输出的manifest.json中的 name值</span></span><br><span class="line">            path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;[name].manifest.json&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack --config webpack.dll.config.js --mode production</span><br></pre></td></tr></table></figure>

<h3 id="使用动态链接库文件"><a href="#使用动态链接库文件" class="headerlink" title="使用动态链接库文件"></a>使用动态链接库文件</h3><p>在 webpack.common.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">+        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">+            manifest: <span class="built_in">require</span>(path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;react.manifest.json&#x27;</span>)),</span><br><span class="line">+        &#125;)</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack --config webpack.config.js --mode development</span><br></pre></td></tr></table></figure>

<p>==============================================================</p>
<h4 id="6-控制包文件大小"><a href="#6-控制包文件大小" class="headerlink" title="6.控制包文件大小"></a>6.控制包文件大小</h4><p>配置 Tree shaking，把用不到的代码去除掉。配置 SplitChunksPlugin。</p>
<h4 id="7-thread-loader，parallel-webpack，happypack-多进程打包"><a href="#7-thread-loader，parallel-webpack，happypack-多进程打包" class="headerlink" title="7.thread-loader，parallel-webpack，happypack 多进程打包"></a>7.thread-loader，parallel-webpack，happypack 多进程打包</h4><h5 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h5><p>HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 <a href="https://github.com/amireh/happypack">happypack</a></p>
<p>安装：<code>npm i happypack@next -D</code></p>
<p>配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">//把对.js文件的处理转交给id为babel的HappyPack实例</span></span><br><span class="line"> +          use: <span class="string">&#x27;happypack/loader?id=babel&#x27;</span>,</span><br><span class="line">            include: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="comment">//把对.css文件的处理转交给id为css的HappyPack实例</span></span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">+           use: <span class="string">&#x27;happypack/loader?id=css&#x27;</span>,</span><br><span class="line">            include: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">        &#125;],</span><br><span class="line">        noParse: [<span class="regexp">/react\.min\.js/</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">        <span class="comment">//用唯一的标识符id来代表当前的HappyPack是用来处理一类特定文件</span></span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            id: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">            <span class="comment">//如何处理.js文件，和rules里的配置相同</span></span><br><span class="line">            loaders: [&#123;</span><br><span class="line">                loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                query: &#123;</span><br><span class="line">                    presets: [</span><br><span class="line">                        <span class="string">&quot;env&quot;</span>, <span class="string">&quot;react&quot;</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            id: <span class="string">&#x27;css&#x27;</span>,</span><br><span class="line">            loaders: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">            threads: <span class="number">4</span>, <span class="comment">//代表开启几个子进程去处理这一类型的文件</span></span><br><span class="line">            verbose: <span class="literal">true</span> <span class="comment">//是否允许输出日子</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>

<h5 id="ParallelUglifyPlugin"><a href="#ParallelUglifyPlugin" class="headerlink" title="ParallelUglifyPlugin"></a>ParallelUglifyPlugin</h5><p><code>ParallelUglifyPlugin</code>可以把对JS文件的串行压缩变为开启多个子进程并行执行</p>
<p>安装：<code>npm i -D webpack-parallel-uglify-plugin</code></p>
<p>配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">            workerCount: <span class="number">3</span>, <span class="comment">//开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1</span></span><br><span class="line">            uglifyJS: &#123;</span><br><span class="line">                output: &#123;</span><br><span class="line">                    beautify: <span class="literal">false</span>, <span class="comment">//不需要格式化</span></span><br><span class="line">                    comments: <span class="literal">false</span>, <span class="comment">//不保留注释</span></span><br><span class="line">                &#125;,</span><br><span class="line">                compress: &#123;</span><br><span class="line">                    warnings: <span class="literal">false</span>, <span class="comment">// 在UglifyJs删除没有用到的代码时不输出警告</span></span><br><span class="line">                    drop_console: <span class="literal">true</span>, <span class="comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span></span><br><span class="line">                    collapse_vars: <span class="literal">true</span>, <span class="comment">// 内嵌定义了但是只用到一次的变量</span></span><br><span class="line">                    reduce_vars: <span class="literal">true</span>, <span class="comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="8-合理使用-sourceMap"><a href="#8-合理使用-sourceMap" class="headerlink" title="8.合理使用 sourceMap"></a>8.合理使用 sourceMap</h4><h4 id="9-结合-stats-分析打包结果"><a href="#9-结合-stats-分析打包结果" class="headerlink" title="9.结合 stats 分析打包结果"></a>9.结合 stats 分析打包结果</h4><h4 id="10-开发环境内存编译"><a href="#10-开发环境内存编译" class="headerlink" title="10. 开发环境内存编译"></a>10. 开发环境内存编译</h4><h4 id="11-开发环境无用插件剔除"><a href="#11-开发环境无用插件剔除" class="headerlink" title="11.开发环境无用插件剔除"></a>11.开发环境无用插件剔除</h4><hr>
<h3 id="多页面打包配置"><a href="#多页面打包配置" class="headerlink" title="多页面打包配置"></a>多页面打包配置</h3><p>配置多个 entry 里的 html 页面，用HtmlWebpackPlugin 插件，将打包好的j多个js分别插入到对应的html页面中。</p>
<p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/lesson%20410">410</a>】</p>
<p>在 webpack.common.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> AddAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> makePlugins = <span class="function">(<span class="params">configs</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> plugins = [</span><br><span class="line">		<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>], &#123;</span><br><span class="line">			root: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	];</span><br><span class="line">	<span class="built_in">Object</span>.keys(configs.entry).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">		plugins.push(</span><br><span class="line">+			<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">				template: <span class="string">&#x27;src/index.html&#x27;</span>,</span><br><span class="line">				filename: <span class="string">`<span class="subst">$&#123;item&#125;</span>.html`</span>,</span><br><span class="line">				chunks: [<span class="string">&#x27;runtime&#x27;</span>, <span class="string">&#x27;vendors&#x27;</span>, item]</span><br><span class="line">			&#125;)</span><br><span class="line">		)</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">const</span> files = fs.readdirSync(path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>));</span><br><span class="line">	files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="regexp">/.*\.dll.js/</span>.test(file)) &#123;</span><br><span class="line">			plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">				filepath: path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>, file)</span><br><span class="line">			&#125;))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="regexp">/.*\.manifest.json/</span>.test(file)) &#123;</span><br><span class="line">			plugins.push(<span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">				manifest: path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>, file)</span><br><span class="line">			&#125;))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> plugins;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> configs = &#123;</span><br><span class="line">+	entry: &#123;</span><br><span class="line">		index: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">		list: <span class="string">&#x27;./src/list.js&#x27;</span>,</span><br><span class="line">		detail: <span class="string">&#x27;./src/detail.js&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	resolve: &#123;</span><br><span class="line">		extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>],</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123; </span><br><span class="line">			test: <span class="regexp">/\.jsx?$/</span>, </span><br><span class="line">			include: path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">			use: [&#123;</span><br><span class="line">				loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">				options: &#123;</span><br><span class="line">					name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">					outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">					limit: <span class="number">10240</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			test: <span class="regexp">/\.(eot|ttf|svg)$/</span>,</span><br><span class="line">			use: &#123;</span><br><span class="line">				loader: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	optimization: &#123;</span><br><span class="line">		runtimeChunk: &#123;</span><br><span class="line">			name: <span class="string">&#x27;runtime&#x27;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		usedExports: <span class="literal">true</span>,</span><br><span class="line">		splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">      	vendors: &#123;</span><br><span class="line">      		test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">      		priority: <span class="number">-10</span>,</span><br><span class="line">      		name: <span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	performance: <span class="literal">false</span>,</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configs.plugins = makePlugins(configs);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = configs</span><br></pre></td></tr></table></figure>





<h2 id="五：Webpack底层原理及脚手架工具分析"><a href="#五：Webpack底层原理及脚手架工具分析" class="headerlink" title="五：Webpack底层原理及脚手架工具分析"></a>五：Webpack底层原理及脚手架工具分析</h2><h3 id="如何编写一个-Loader"><a href="#如何编写一个-Loader" class="headerlink" title="如何编写一个 Loader"></a>如何编写一个 Loader</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/make-loader%2051">51</a>】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir make-loader</span><br><span class="line"><span class="built_in">cd</span> make-loader</span><br><span class="line">npm init -y</span><br><span class="line">npm i webpack webpack-cli -D</span><br><span class="line">npm i loader-utils -D</span><br></pre></td></tr></table></figure>

<p>在根目录下创建文件夹loaders，里面创建自己定义的loader.js文件</p>
<p>在 webpack.config.js 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	resolveLoader: &#123; <span class="comment">//先在 node_modules 中找用到的loader，如果没找到，再在loaders里查找</span></span><br><span class="line">		modules: [<span class="string">&#x27;node_modules&#x27;</span>, <span class="string">&#x27;./loaders&#x27;</span>]</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [&#123;</span><br><span class="line">			test: <span class="regexp">/\.js/</span>,</span><br><span class="line">			use: [<span class="comment">//使用自己写的replaceLoader</span></span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;replaceLoader&#x27;</span>,</span><br><span class="line">				&#125;,</span><br><span class="line">				&#123;</span><br><span class="line">					loader: <span class="string">&#x27;replaceLoaderAsync&#x27;</span>,</span><br><span class="line">					options: &#123;</span><br><span class="line">						name: <span class="string">&#x27;lee&#x27;</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">			]</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">		filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细请看官方文档：<a href="https://webpack.js.org/api/loaders#thisquery">loaders#thisquery</a>  <a href="https://webpack.js.org/api/loaders#thiscallback">hiscallback</a>  <a href="https://webpack.js.org/api/loaders#thisasync">thisasync</a> </p>
<hr>
<h3 id="如何编写一个-Plugin"><a href="#如何编写一个-Plugin" class="headerlink" title="如何编写一个 Plugin"></a>如何编写一个 Plugin</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/plugin%2052">52</a>】</p>
<p>详细请看官方文档：<a href="https://webpack.js.org/api/compiler-hooks">compiler-hooks</a> </p>
<hr>
<h3 id="Bundler-源码编写（模块分析）"><a href="#Bundler-源码编写（模块分析）" class="headerlink" title="Bundler 源码编写（模块分析）"></a>Bundler 源码编写（模块分析）</h3><p><strong>应对 webpack 原理面试必备：</strong></p>
<p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/bundler%2053">53</a>】</p>
<p>安装 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//高亮显示代码的工具</span><br><span class="line">npm i cli-highlight -g</span><br><span class="line">//分析源代码</span><br><span class="line">npm install @babel/parser --save</span><br><span class="line">npm install @babel/core --save</span><br><span class="line">npm install @babel/traverse --save</span><br><span class="line">npm install @babel/preset-env --save</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Bundler-源码编写（Dependencies-Graph）"><a href="#Bundler-源码编写（Dependencies-Graph）" class="headerlink" title="Bundler 源码编写（Dependencies Graph）"></a>Bundler 源码编写（Dependencies Graph）</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/bundler%2054">54</a>】</p>
<hr>
<h3 id="Bundler-源码编写（生成代码）"><a href="#Bundler-源码编写（生成代码）" class="headerlink" title="Bundler 源码编写（生成代码）"></a>Bundler 源码编写（生成代码）</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/bundler%2055">55</a>】</p>
<h2 id="六：Create-React-App-和-Vue-Cli-3-0脚手架工具配置分析"><a href="#六：Create-React-App-和-Vue-Cli-3-0脚手架工具配置分析" class="headerlink" title="六：Create-React-App 和 Vue-Cli 3.0脚手架工具配置分析"></a>六：Create-React-App 和 Vue-Cli 3.0脚手架工具配置分析</h2><h3 id="通过CreateReactApp深入学习Webpack配置"><a href="#通过CreateReactApp深入学习Webpack配置" class="headerlink" title="通过CreateReactApp深入学习Webpack配置"></a>通过CreateReactApp深入学习Webpack配置</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/my-app56">56</a>】</p>
<p>详细请看官方文档：<a href="https://facebook.github.io/create-react-app/docs/getting-started">CreateReactApp</a> </p>
<p>快速开始：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>把隐藏的配置项展现出来：不可逆操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure>

<p>就会多出来两个文件夹，config，scripts文件夹</p>
<hr>
<h3 id="Vue-Cli-3-0"><a href="#Vue-Cli-3-0" class="headerlink" title="Vue-Cli 3.0"></a>Vue-Cli 3.0</h3><p>仓库源码 【<a href="https://github.com/wudiufo/WebPack4-study/tree/master/my-project57">57</a>】</p>
<p>详细请看官网：<a href="https://cli.vuejs.org/zh/guide/#cli">VUE Cli</a>  <a href="https://cli.vuejs.org/zh/config/#%E5%85%A8%E5%B1%80-cli-%E9%85%8D%E7%BD%AE">全局-cli-配置</a></p>
]]></content>
      <tags>
        <tag>webpack4.0</tag>
      </tags>
  </entry>
  <entry>
    <title>前端必学之nodeJs</title>
    <url>/2020/09/10/8.node/</url>
    <content><![CDATA[<h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-Node-js是什么"><a href="#1-Node-js是什么" class="headerlink" title="1.Node.js是什么"></a>1.Node.js是什么</h3><ul>
<li>node.js他是JavaScript的一个运行环境</li>
<li>他既不是语言，也不是框架，他是一个平台<a id="more"></a>


</li>
</ul>
<h3 id="2-Node-js中的javascript"><a href="#2-Node-js中的javascript" class="headerlink" title="2.Node.js中的javascript"></a>2.Node.js中的javascript</h3><blockquote>
<p>node js对象中没有DOM，BOM对象。有一大堆专供对象</p>
<p>两者都有：数值/布尔/原始类型。ES对象：String,Math,Regex,…</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>前端JS中的数据类型：</strong>                                                                                                                                                 1.基本/原生/值类型   string、number、boolean、null、undefined                                                                           2.引用/对象类型                                                                                                                                                             ES对象类型：String、Number、Boolean、Math、Date、RegExp、Object、Function、Error….                                                                                                                                                               BOM对象类型：window、document、screen、history、location、navigator、event…                  DOM对象类型：Node、Element、Attr….                                                                                                            用户自定义对象类型： { }</th>
</tr>
</thead>
<tbody><tr>
<td><strong>后端Node.js中的数据类型：</strong>                                                                                                                                      1. 基本/原生/值类型   string、number、boolean、null、undefined                                                                     2. 引用/对象类型   ES对象类型：String、Number、Boolean、Math、Date、RegExp、Object、Function、Error….                                                                                                                                                               Node.js特供对象：目前有几百个….                                                                                                                          用户自定义对象类型： { }</td>
</tr>
</tbody></table>
<h3 id="3-模块"><a href="#3-模块" class="headerlink" title="3.模块"></a>3.模块</h3><p><strong>模块的种类</strong></p>
<ul>
<li>内置模块 （node.js内置模块）</li>
<li>第三方模块</li>
<li>自定义模块</li>
</ul>
<p><strong>模块系统</strong></p>
<ul>
<li>在 Node 中没有全局作用域的概念</li>
<li>在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件</li>
<li>require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题<ul>
<li>模块完全是封闭的</li>
<li>外部无法访问内部</li>
<li>内部也无法访问外部</li>
</ul>
</li>
<li>模块作用域固然带来了一些好处<ul>
<li>可以加载执行多个文件</li>
<li>可以完全避免变量命名冲突污染的问题</li>
</ul>
</li>
<li>在某些情况下，模块与模块是需要进行通信的</li>
<li>在每个模块中，都提供了一个对象：<code>exports</code><ul>
<li>该对象默认是一个空对象</li>
<li>你要做的就是把需要被外部访问使用的成员手动的挂载到 <code>exports</code> 接口对象中。</li>
<li>然后谁来 <code>require</code> 这个模块，谁就可以得到模块内部的 <code>exports</code> 接口对象。</li>
</ul>
</li>
</ul>
<p><strong>核心模块</strong></p>
<ul>
<li>核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识<ul>
<li>fs 文件操作模块</li>
<li>http 网络服务构建模块</li>
<li>os 操作系统信息模块</li>
<li>path 路径处理模块</li>
</ul>
</li>
<li>所有核心模块在使用的时候都必须手动的先使用 <code>require</code> 方法来加载，然后才可以使用，例如：<ul>
<li><code>var fs = require(&#39;fs&#39;)</code></li>
</ul>
</li>
</ul>
<h3 id="4-http协议"><a href="#4-http协议" class="headerlink" title="4.http协议"></a>4.http协议</h3><p>http 这个模块的职责就是帮你创建编写服务器的。</p>
<ul>
<li><p>require</p>
</li>
<li><p>端口号</p>
<ul>
<li>ip 地址定位计算机</li>
<li>端口号定位具体的应用程序</li>
</ul>
</li>
<li><p>Content-Type</p>
<ul>
<li>服务器最好把每次响应的数据是什么内容类型都告诉客户端，而且要正确的告诉</li>
<li>不同的资源对应的 Content-Type 是不一样，具体参照：<a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a></li>
<li>对于文本类型的数据，最好都加上编码，目的是为了防止中文解析乱码问题</li>
</ul>
</li>
<li><p>它通过网络发送文件</p>
<ul>
<li>发送的并不是文件，本质上来讲发送是文件的内容</li>
<li>当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理</li>
</ul>
</li>
<li><p>它是一个模块系统</p>
</li>
<li><p>Express Web 开发框架</p>
<ul>
<li><code>npm install express</code></li>
</ul>
</li>
</ul>
<h3 id="5-ip地址和端口号"><a href="#5-ip地址和端口号" class="headerlink" title="5.ip地址和端口号"></a>5.ip地址和端口号</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200729181121523.png" alt="image-20200729181121523"></p>
<h3 id="6-服务器黑盒子"><a href="#6-服务器黑盒子" class="headerlink" title="6.服务器黑盒子"></a>6.服务器黑盒子</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200729181209875.png" alt="image-20200729181209875"></p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="1-什么是模块化"><a href="#1-什么是模块化" class="headerlink" title="1.什么是模块化"></a>1.什么是模块化</h3><ol>
<li>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元</li>
<li>编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块</li>
<li>把代码进行模块化拆分的好处<ul>
<li>提高了代码的复用性</li>
<li>提高了代码的可维护性</li>
<li>可以实现按需加载</li>
</ul>
</li>
</ol>
<h3 id="2-模块化相关的概念"><a href="#2-模块化相关的概念" class="headerlink" title="2.模块化相关的概念"></a>2.模块化相关的概念</h3><ol>
<li>模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则，例如：</li>
</ol>
<ul>
<li>使用什么样的语法格式来引用模块</li>
<li>在模块中使用什么样的语法格式向外暴露成员</li>
</ul>
<ol start="2">
<li><p>模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己</p>
</li>
<li><p>Node 中的模块化</p>
</li>
</ol>
<h3 id="3-Node-中模块的-3-个大类"><a href="#3-Node-中模块的-3-个大类" class="headerlink" title="3.Node 中模块的 3 个大类"></a>3.Node 中模块的 3 个大类</h3><p>Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是：</p>
<ol>
<li>内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）</li>
<li>自定义模块（用户创建的每个 .js 文件，都是自定 义模块）</li>
<li>第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）</li>
</ol>
<h3 id="4-使用-require-方法加载模块"><a href="#4-使用-require-方法加载模块" class="headerlink" title="4.使用 require 方法加载模块"></a>4.使用 require 方法加载模块</h3><p>使用强大的 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 加载内置的 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 加载用户的自定义模块</span></span><br><span class="line"><span class="keyword">const</span> custom = <span class="built_in">require</span>(<span class="string">&#x27;./custom.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 加载第三方模块，(使用第三方模块，下面会进行讲解)</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>注意事项 1： 使用 require() 方法加载其他模块时，会执行被加载模块中的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载模块.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./被加载的模块.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被加载模块.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我会被打印&#x27;</span>)</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>注意事项2： 在使用 require 加载用户自定义模块期间，可以省略 .js 后缀名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载模块.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./被加载的模块&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意事项3：require优先从缓存加载</p>
<ul>
<li>require优先从缓存加载，当有三个文档a,b,main.js。main.js加载b,而a加载的是b,所以这里不会重复加载，可以拿到其中的接口对象（require(‘./a’)），但是不会重复执行里面的代码，这样做的目的是为了避免重复加载，提高模块加载效率。</li>
</ul>
<h3 id="5-exports接口导出模块"><a href="#5-exports接口导出模块" class="headerlink" title="5.exports接口导出模块"></a>5.exports接口导出模块</h3><p>使用exports接口对象用来导出模块中的成员</p>
<ul>
<li>node中模块作用域，默认文件中所有的成员只在当前文件模块有效</li>
<li>对于希望可以被其他模块访问的成员，我们就需要把这些公开的成员都挂载到<code>exports</code>接口对象中就可以了</li>
<li>导出多个成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.a=<span class="number">123</span></span><br><span class="line"><span class="built_in">exports</span>.b=<span class="string">&#x27;dsf&#x27;</span></span><br><span class="line"><span class="built_in">exports</span>.function()&#123;&#125;</span><br><span class="line"><span class="built_in">exports</span>.d=&#123;</span><br><span class="line">    foo:<span class="string">&#x27;dsaf&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>导出单个成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以下情况会覆盖</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">//后者会覆盖前者</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以这样导出多个：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;,</span><br><span class="line">  str: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意导出的形式决定了引入的形式</p>
</blockquote>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ul>
<li><p>加载 <code>http</code> 核心模块 </p>
<ul>
<li><pre><code class="javascript">var http=require(&#39;http&#39;)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 使用&#96; http.createServer() &#96;方法创建一个 Web 服务器</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96; javascript</span><br><span class="line">    var server &#x3D; http.createServer()</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数</p>
<ul>
<li><pre><code class="javascript">server.on(&#39;request&#39;, function (req,res) &#123;
  console.log(&#39;收到客户端的请求了&#39;)
&#125;)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- request 请求事件处理函数，需要接收两个参数：</span><br><span class="line"></span><br><span class="line">  Request 请求对象</span><br><span class="line"></span><br><span class="line">  ​    请求对象可以用来获取客户端的一些请求信息，例如请求路径</span><br><span class="line"></span><br><span class="line">    Response 响应对象</span><br><span class="line"></span><br><span class="line">  ​    响应对象可以用来给客户端发送响应消息</span><br><span class="line"></span><br><span class="line">- 告诉客户端，我的话说完了，你可以呈递给用户了</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96; javascript</span><br><span class="line">  response.end(data)</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>请求路径 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">req.url <span class="comment">//获取到的是端口号之后的那一部分路径</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>响应</p>
<p>一个请求对应一个响应，如果在一个请求的过程中，已经结束响应了，则不能重复发送响应。</p>
<p>没有请求就没有响应。</p>
<p>响应内容只能是二进制数据或者字符串</p>
<ul>
<li>数字</li>
<li>对象</li>
<li>数组</li>
<li>布尔值</li>
</ul>
</li>
</ul>
</li>
<li><p>绑定端口号，启动服务器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置请求头：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.writeHead(<span class="number">200</span>,&#123;<span class="string">&quot;content-Type&quot;</span>:<span class="string">&quot;text/plain;charset&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 加载 http 核心模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 使用 http.createServer() 方法创建一个 Web 服务器</span></span><br><span class="line"><span class="comment">//    返回一个 Server 实例</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"><span class="comment">// 3. 服务器要干嘛？</span></span><br><span class="line"><span class="comment">//    提供服务：对 数据的服务</span></span><br><span class="line"><span class="comment">//    发请求</span></span><br><span class="line"><span class="comment">//    接收请求</span></span><br><span class="line"><span class="comment">//    处理请求</span></span><br><span class="line"><span class="comment">//    给个反馈（发送响应）</span></span><br><span class="line"><span class="comment">//    注册 request 请求事件</span></span><br><span class="line"><span class="comment">//    当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数</span></span><br><span class="line"><span class="comment">// request 请求事件处理函数，需要接收两个参数：</span></span><br><span class="line"><span class="comment">//    Request 请求对象</span></span><br><span class="line"><span class="comment">//        请求对象可以用来获取客户端的一些请求信息，例如请求路径</span></span><br><span class="line"><span class="comment">//    Response 响应对象</span></span><br><span class="line"><span class="comment">//        响应对象可以用来给客户端发送响应消息</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;收到客户端的请求了&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;收到客户端的请求了，请求路径是：&#x27;</span> + request.url)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;请求我的客户端的地址是：&#x27;</span>, req.socket.remoteAddress, req.socket.remotePort)</span><br><span class="line">  <span class="comment">// response 对象有一个方法：write 可以用来给客户端发送响应数据</span></span><br><span class="line">  <span class="comment">// write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待</span></span><br><span class="line">  response.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  response.write(<span class="string">&#x27; nodejs&#x27;</span>)</span><br><span class="line">  <span class="comment">// 告诉客户端，我的话说完了，你可以呈递给用户了</span></span><br><span class="line">  response.end()</span><br><span class="line"> <span class="comment">// 上面的方式比较麻烦，推荐使用更简单的方式，直接 end 的同时发送响应数据</span></span><br><span class="line">  <span class="comment">// res.end(&#x27;hello nodejs&#x27;)</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 4. 绑定端口号，启动服务器</span></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-客户端的重定向"><a href="#2-客户端的重定向" class="headerlink" title="2.客户端的重定向"></a>2.客户端的重定向</h3><p>前提：服务端已经把数据存储好了，接下来就是让用户重新请求 / 首页，就可以看到最新的留言内容了</p>
<p>步骤：</p>
<ul>
<li>状态码设置为 302 临时重定向<ul>
<li>statusCode</li>
</ul>
</li>
<li>在响应头中通过 Location 告诉客户端往哪儿重定向<ul>
<li>setHeader</li>
</ul>
</li>
</ul>
<p>如果客户端发现收到服务器的响应的状态码是 302 就会自动去响应头中找 Location ，然后对该地址发起新的请求, 所以你就能看到客户端自动跳转了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.statusCode = <span class="number">302</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure>



<h3 id="3-浏览器解析问题"><a href="#3-浏览器解析问题" class="headerlink" title="3.浏览器解析问题"></a>3.浏览器解析问题</h3><ul>
<li><p>浏览器收到 HTML 响应内容之后，就要开始从上到下依次解析，</p>
<p>当在解析的过程中，如果发现：</p>
<p> link</p>
<p> script</p>
<p> img</p>
<p> iframe</p>
<p> video</p>
<p> audio</p>
<p>等带有 src 或者 href（link） 属性标签（具有外链的资源）的时候，浏览器会自动对这些资源发起新的请求。</p>
</li>
<li><p><strong>注意</strong>：在服务端中，文件中的路径就不要去写相对路径了。</p>
<p>因为这个时候所有的资源都是通过 url 标识来获取的</p>
<p>我的服务器开放了 /public/ 目录</p>
<p>所以这里的请求路径都写成：/public/xxx</p>
<p>/ 在这里就是 url 根路径的意思。</p>
<p>浏览器在真正发请求的时候会最终把 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> 拼上</p>
</li>
</ul>
<h2 id="URL模块"><a href="#URL模块" class="headerlink" title="URL模块"></a>URL模块</h2><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h3><blockquote>
<p>我们现在来看一下req里面能够使用的东西。<br>最关键的就是req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。<br>我们比较关心的不是拿到URL，而是识别这个URL。</p>
</blockquote>
<ul>
<li>URL.parse(req.url,true)   将查询信息变为对象</li>
<li>也可以通过：URL.parse(req.url).query 转换 </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="comment">//引入url模块</span></span><br><span class="line"><span class="keyword">var</span> URL = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//不处理小图标（浏览器地址旁边的小图标）</span></span><br><span class="line">    <span class="keyword">if</span>(req.url == <span class="string">&quot;/favicon.ico&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//url.parse()可以将一个完整的URL地址，分为很多部分：</span></span><br><span class="line">    <span class="comment">//host、port、pathname、path、query</span></span><br><span class="line">    <span class="keyword">var</span> pathname = URL.parse(req.url).pathname;</span><br><span class="line">    <span class="comment">//url.parse()如果第二个参数是true，那么就可以将所有的查询变为对象</span></span><br><span class="line">    <span class="comment">//就可以直接打点得到这个参数</span></span><br><span class="line">    <span class="keyword">var</span> query = URL.parse(req.url,<span class="literal">true</span>).query;      </span><br><span class="line">    <span class="keyword">var</span> url = URL.parse(req.url,<span class="literal">true</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(url);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="string">&quot;127.0.0.1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>假设我们访问<a href="http://127.0.0.1:3000/hcd?name=1">http://127.0.0.1:3000/hcd?name=1</a> </p>
<p>则console.log(url)为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="literal">null</span>,</span><br><span class="line">  slashes: <span class="literal">null</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="literal">null</span>,</span><br><span class="line">  port: <span class="literal">null</span>,</span><br><span class="line">  hostname: <span class="literal">null</span>,</span><br><span class="line">  hash: <span class="literal">null</span>,</span><br><span class="line">  search: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  query: &#123;&#125;,   <span class="comment">// URL.parse(req.url,true)28</span></span><br><span class="line">  pathname: <span class="string">&#x27;/hcd?name=1&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/hcd?name=1&#x27;</span>,</span><br><span class="line">  href: <span class="string">&#x27;/hcd?name=1&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-编写一个路由router"><a href="#2-编写一个路由router" class="headerlink" title="2.编写一个路由router"></a>2.编写一个路由router</h3><p>可以通过<code>req.url</code>制作路由<code>router</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//得到url</span></span><br><span class="line">    <span class="keyword">var</span> userurl = req.url;</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;text/html;charset=UTF8&quot;</span>&#125;)</span><br><span class="line">    <span class="comment">//如果请求的地址为&quot;/student&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(userurl == <span class="string">&quot;/student&quot;</span>)&#123;</span><br><span class="line">        res.end(<span class="string">&quot;student&quot;</span>);     </span><br><span class="line">    <span class="comment">//如果请求的地址为&quot;/teacher&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userurl == <span class="string">&quot;/teacher&quot;</span>)&#123;</span><br><span class="line">        res.end(<span class="string">&quot;teacher&quot;</span>);</span><br><span class="line">    <span class="comment">//如果请求的地址没有</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.end(<span class="string">&quot;404&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="string">&quot;127.0.0.1&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="node中的模板"><a href="#node中的模板" class="headerlink" title="node中的模板"></a>node中的模板</h2><h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h3><ul>
<li><p><code>art-template</code> 不仅可以在浏览器使用，也可以在 node 中使用</p>
</li>
<li><p>安装：</p>
<ul>
<li><p><code> npm install art-template</code></p>
</li>
<li><p>该命令在哪执行就会把包下载到哪里。默认会下载到 <code>node_modules </code>目录中</p>
</li>
<li><p><code> node_modules</code>不要改，也不支持改。</p>
</li>
</ul>
</li>
<li><p>在需要使用的文件模块中加载 art-template</p>
<ul>
<li><p>只需要使用 require 方法加载就可以了：require(‘art-template’)</p>
</li>
<li><p>参数中的 art-template 就是你下载的包的名字</p>
</li>
<li><p>也就是说你 <code>isntall</code> 的名字是什么，则你 <code>require</code> 中的就是什么</p>
</li>
</ul>
</li>
<li><p>查文档，使用模板引擎的 <code>API</code></p>
</li>
</ul>
<h3 id="2-data值的使用"><a href="#2-data值的使用" class="headerlink" title="2.data值的使用"></a>2.data值的使用</h3><ul>
<li>默认读取到的 data 是二进制数据</li>
<li>而模板引擎的 render 方法需要接收的是字符串</li>
<li>所以我们在这里需要把 data 二进制数据转为 字符串 才可以给模板引擎使用</li>
</ul>
<h3 id="3-each的辨别"><a href="#3-each的辨别" class="headerlink" title="3.each的辨别"></a>3.each的辨别</h3><ol>
<li>art-template中的each</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是 art-template 模板引擎支持的语法，只能在模板字符串中使用</span></span><br><span class="line">&#123;&#123;each 数组&#125;&#125;</span><br><span class="line">	&lt;li&gt;&#123;&#123; $value &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>jquery中的each</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.each(数组, <span class="function"><span class="keyword">function</span>)</span></span><br><span class="line"><span class="function">// 遍历 <span class="title">jQuery</span> 选择器选择到的伪数组实例对象</span></span><br><span class="line"><span class="function"><span class="title">$</span>(<span class="params"><span class="string">&#x27;div&#x27;</span></span>).<span class="title">each</span>(<span class="params">function</span>)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>EcmaScript 5 中的一个数组遍历函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 是 EcmaScript 5 中的一个数组遍历函数，是 JavaScript 原生支持的遍历方法 可以遍历任何可以被遍历的成员</span></span><br></pre></td></tr></table></figure>



<h3 id="4-渲染"><a href="#4-渲染" class="headerlink" title="4.渲染"></a>4.渲染</h3><ol>
<li>在html文件中写好要渲染的部分</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;大家好，我叫：&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;我今年 &#123;&#123; age &#125;&#125; 岁了&lt;/p&gt;</span><br><span class="line">&lt;h1&gt;我来自 &#123;&#123; province &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;我喜欢：&#123;&#123;each hobbies&#125;&#125; &#123;&#123; $value &#125;&#125; &#123;&#123;<span class="regexp">/each&#125;&#125;&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>其次在node中安装<code>art-template</code>模板引擎，在文件中加载它。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="built_in">require</span>(<span class="string">&#x27;art-template&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后读取<code>html</code>文件，把数据转换为字符串给模板引擎</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;./tpl.html&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件失败了&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认读取到的 data 是二进制数据</span></span><br><span class="line">    <span class="comment">// 而模板引擎的 render 方法需要接收的是字符串</span></span><br><span class="line">    <span class="comment">// 所以我们在这里需要把 data 二进制数据转为 字符串 才可以给模板引擎使用</span></span><br><span class="line">    <span class="keyword">var</span> ret = template.render(data.toString(), &#123;</span><br><span class="line">        name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        province: <span class="string">&#x27;北京市&#x27;</span>,</span><br><span class="line">        hobbies: [</span><br><span class="line">            <span class="string">&#x27;写代码&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;唱歌&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;打游戏&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        title: <span class="string">&#x27;个人信息&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="5-其他模板"><a href="#5-其他模板" class="headerlink" title="5.其他模板"></a>5.其他模板</h3><p><strong>ejs</strong></p>
<h2 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h2><h3 id="1-文件夹操作"><a href="#1-文件夹操作" class="headerlink" title="1.文件夹操作"></a>1.文件夹操作</h3><ol>
<li>创建目录</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.mkdir(path[, options], callback)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>path</strong> - 文件路径。</li>
<li>options 参数可以是：<ul>
<li><strong>recursive</strong> - 是否以递归的方式创建目录，默认为 false。</li>
<li><strong>mode</strong> - 设置目录权限，默认为 0777。</li>
</ul>
</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.mkdir(<span class="string">&#x27;/tmp/a/apple&#x27;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>读取目录 <code>fs.readdir(path, callback)</code></li>
<li>删除目录的语法格式:<code>fs.rmdir(path, callback)</code></li>
</ol>
<h3 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2.文件操作"></a>2.文件操作</h3><ol>
<li>打开文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.open(path, flags[, mode], callback)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>path</strong> - 文件的路径。</li>
<li><strong>flags</strong> - 文件打开的行为。具体值详见下文。</li>
<li><strong>mode</strong> - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：callback(err, fd)。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步打开文件</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;准备打开文件！&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;r+&#x27; 代表以读写模式打开文件。如果文件不存在抛出异常</span></span><br><span class="line">fs.open(<span class="string">&#x27;input.txt&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;文件打开成功！&quot;</span>);     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取文件信息</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.stat(path, callback)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：(err, stats), <strong>stats</strong> 是 fs.stats 对象。</li>
</ul>
<ol start="3">
<li>写入文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>writeFile 直接打开文件默认是 <strong>w</strong> 模式，所以如果文件存在，该方法写入的内容会覆盖旧的文件内容。</p>
</blockquote>
<ul>
<li><strong>file</strong> - 文件名或文件描述符。</li>
<li><strong>data</strong> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</li>
<li><strong>options</strong> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</li>
<li><strong>callback</strong> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li>
</ul>
<ol start="4">
<li>关闭文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>callback</strong> - 回调函数，没有参数</li>
</ul>
<ol start="5">
<li>读取文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;/etc/passwd&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h2><h3 id="1-os模块"><a href="#1-os模块" class="headerlink" title="1.os模块"></a>1.os模块</h3><p><code>os</code>用来获取机器信息的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取当前机器的 CPU 信息</span></span><br><span class="line"><span class="built_in">console</span>.log(os.cpus())</span><br><span class="line"><span class="comment">// memory 内存</span></span><br><span class="line"><span class="built_in">console</span>.log(os.totalmem())</span><br></pre></td></tr></table></figure>



<h3 id="2-path模块"><a href="#2-path模块" class="headerlink" title="2.path模块"></a>2.path模块</h3><p>用来操作路径的</p>
<p><strong>path.extname() 方法返回 path 的扩展名</strong></p>
<p>即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名（见 path.basename()）的第一个字符是 .，则返回一个空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取一个路径中的扩展名部分</span></span><br><span class="line"><span class="comment">// extname extension name</span></span><br><span class="line"><span class="built_in">console</span>.log(path.extname(<span class="string">&#x27;c:/a/b/c/d/hello.txt&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><ul>
<li><p>凡是第三方模块都必须通过 npm 来下载</p>
<p>使用的时候就可以通过 require(‘包名’) 的方式来进行加载才可以使用</p>
<p>不可能有任何一个第三方包和核心模块的名字是一样的</p>
<p>既不是核心模块、也不是路径形式的模块</p>
<ul>
<li><p>先找到当前文件所处目录中的 node_modules 目录</p>
<p>node_modules/art-template</p>
<p>node_modules/art-template/package.json 文件</p>
<p>node_modules/art-template/package.json 文件中的 main 属性 </p>
<p>main 属性中就记录了 art-template 的入口模块</p>
<p>然后加载使用这个第三方包</p>
<p>实际上最终加载的还是文件</p>
</li>
<li><p>如果 package.json 文件不存在或者 main 指定的入口模块是也没有</p>
<p>则 node 会自动找该目录下的 index.js</p>
<p>也就是说 index.js 会作为一个默认备选项 </p>
<p>如果以上所有任何一个条件都不成立，则会进入上一级目录中的 node_modules 目录查找</p>
<p>如果上一级还没有，则继续往上上一级查找</p>
<p>。。。</p>
<p>如果直到当前磁盘根目录还找不到，最后报错：</p>
<p> can not find module xxx</p>
</li>
</ul>
<blockquote>
<p>备注：我们一个项目有且只有一个 node_modules，放在项目根目录中，这样的话项目中所有的子目录中的代码都可以加载到第三方包不会出现有多个 node_modules。</p>
</blockquote>
</li>
</ul>
<h2 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h2><p>原生的http在某些方面表现不足以应对我们的开发需求，所以我就需要使用框架来加快我们的开发效率，框架的目的：提高效率，代码高度统一。</p>
<p>官网：expressjs.com</p>
<h3 id="1-安装："><a href="#1-安装：" class="headerlink" title="1.安装："></a>1.安装：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包的下载安装</span></span><br><span class="line">npm install express</span><br></pre></td></tr></table></figure>

<ul>
<li><p>package.json</p>
<p>我们建议每一个项目都要有一个<code>package.json</code>文件（包描述文件，就像说明书一样），给人踏实的感觉。</p>
<p>这个文件可以通过<code>npm init</code>or <code>npm init --y</code>的方式来自动初始化。</p>
</li>
<li><p>“dependencies”选项</p>
<p>对于目前来讲，最有用的是”dependencies”选项，可以来帮我们保存第三方包的依赖信息。如果你的<code>node_modules</code>删除了也不用担心，我们只要执行<code>npm install</code>就会自动把<code>package.json</code>中的<code>dependencies</code>中所有的依赖项都下载回来。</p>
<ul>
<li>建议每个项目的根目录下都有一个package.json文件</li>
<li>建议执行npm install 包名的   时候都加上 <code>--save</code>这个选项，目的是用来保存依赖项信息。</li>
</ul>
</li>
</ul>
<h3 id="2-hello-worrd"><a href="#2-hello-worrd" class="headerlink" title="2.hello worrd"></a>2.hello worrd</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 安装</span></span><br><span class="line"><span class="comment">// 1. 引包</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建你服务器应用程序</span></span><br><span class="line"><span class="comment">//    也就是原来的 http.createServer</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.get(<span class="string">&#x27;/about&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在 Express 中可以直接 req.query 来获取查询字符串参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.query)</span><br><span class="line">  res.send(<span class="string">&#x27;Express! hello world&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 相当于 server.listen</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;app is running at port 3000.&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-基本路由"><a href="#3-基本路由" class="headerlink" title="3.基本路由"></a>3.基本路由</h3><p>路由器—-&gt;路由表</p>
<p>get:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当你以GET方式请求 / 的时候，执行对应处理的处理函数</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>post:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当你以GET方式请求 / 的时候，执行对应处理的处理函数</span></span><br><span class="line">app.post(<span class="string">&#x27;/&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>put:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.put(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Got a PUT request at /user&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>delete:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当以delete方法请求“/user”的时候，执行删除操作。</span></span><br><span class="line">app.delete(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Got a DELETE request at /user&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="4-静态服务"><a href="#4-静态服务" class="headerlink" title="4.静态服务"></a>4.静态服务</h3><p>为了提供诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，请使用 Express 中的 <code>express.static</code> 内置中间件函数。</p>
<p>此函数特征如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">express.static(root, [options])</span><br></pre></td></tr></table></figure>

<p>通过如下代码就可以将 <code>public</code> 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>现在，你就可以访问 <code>public</code> 目录中的所有文件了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;images&#x2F;kitten.jpg</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;css&#x2F;style.css</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;js&#x2F;app.js</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;images&#x2F;bg.png</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;hello.html</span><br></pre></td></tr></table></figure>

<blockquote>
<p> Express 在静态目录查找文件，因此，存放静态文件的目录名不会出现在 URL 中。</p>
</blockquote>
<p>如果要使用多个静态资源目录，请多次调用 <code>express.static</code> 中间件函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line">app.use(express.static(<span class="string">&#x27;files&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h3 id="5-使用成器工具-express-generator创建一个应用的骨架"><a href="#5-使用成器工具-express-generator创建一个应用的骨架" class="headerlink" title="5.使用成器工具 express-generator创建一个应用的骨架"></a>5.使用成器工具 <code>express-generator</code>创建一个应用的骨架</h3><ol>
<li>可以通过 <code>npx</code> （包含在 Node.js 8.2.0 及更高版本中）命令来<strong>运行 Express 应用程序生成器</strong>。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npx express-generator</span><br></pre></td></tr></table></figure>

<p>对于较老的 Node 版本，请通过 npm 将 Express 应用程序生成器安装到全局环境中并执行即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install -g express-generator</span><br><span class="line">$ express</span><br></pre></td></tr></table></figure>

<p><code>-h</code> 参数可以列出所有可用的命令行参数</p>
<ol start="2">
<li><strong>安装所有依赖包</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ cd myapp</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>启动应用</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ DEBUG=name:* npm start</span><br></pre></td></tr></table></figure>

<p>通过生成器创建的应用一般都有如下目录结构：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.js</span><br><span class="line">├── bin</span><br><span class="line">│   └── www</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style.css</span><br><span class="line">├── routes</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views</span><br><span class="line">    ├── error.pug</span><br><span class="line">    ├── index.pug</span><br><span class="line">    └── layout.pug</span><br><span class="line"></span><br><span class="line">7 directories, 9 files</span><br></pre></td></tr></table></figure>



<h3 id="6-expepress中使用art-template"><a href="#6-expepress中使用art-template" class="headerlink" title="6.expepress中使用art-template"></a>6.expepress中使用art-template</h3><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save art-template</span><br><span class="line">npm install --save express-art-template</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.engine(<span class="string">&#x27;html&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;express-art-template&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Express 为 Response 相应对象提供了一个方法：render</span></span><br><span class="line"><span class="comment">// render 方法默认是不可以使用，但是如果配置了模板引擎就可以使用了</span></span><br><span class="line"><span class="comment">// res.render(&#x27;html模板名&#x27;, &#123;模板数据&#125;)--&gt;模板中要修改的数据部分</span></span><br><span class="line"><span class="comment">// req.query 只能拿 get 请求参数</span></span><br><span class="line">   <span class="comment">// console.log(req.query)</span></span><br><span class="line"><span class="comment">// 第一个参数不能写路径，默认会去项目中的 views 目录查找该模板文件</span></span><br><span class="line"><span class="comment">// 也就是说 Express 有一个约定：开发人员把所有的视图文件都放到 views 目录中</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.render(<span class="string">&#x27;index.html&#x27;</span>, &#123;</span><br><span class="line">        comments: comments</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果希望修改默认的<code>views</code>视图渲染存储目录，就可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：第一个参数不能写错</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, render函数的默认路径，即下次的默认路径)</span><br></pre></td></tr></table></figure>

<h3 id="7-获取表单请求体数据"><a href="#7-获取表单请求体数据" class="headerlink" title="7.获取表单请求体数据"></a>7.获取表单请求体数据</h3><h4 id="1-在Express获取表单GET请求体数据"><a href="#1-在Express获取表单GET请求体数据" class="headerlink" title="1.在Express获取表单GET请求体数据"></a>1.在Express获取表单GET请求体数据</h4><p>express内置了一个API,可以直接使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">req.query</span><br></pre></td></tr></table></figure>



<h4 id="2-在Express获取表单POST请求体数据"><a href="#2-在Express获取表单POST请求体数据" class="headerlink" title="2.在Express获取表单POST请求体数据"></a>2.在Express获取表单POST请求体数据</h4><p>在Express中没有内置获取表单post请求体的API,这里我们需要使用一个第三方包：<code>body-parser</code></p>
<p>安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save body-parser</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//1.先引包</span></span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="comment">//配置body-parser</span></span><br><span class="line"><span class="comment">//只要加入这个配置，则在req请求对象上会多出来一个属性：body</span></span><br><span class="line"><span class="comment">//也就是说你就可以直接通过req.body来获取表单post请求体数据了</span></span><br><span class="line"><span class="comment">// parse application/x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// parse application/json</span></span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">  res.write(<span class="string">&#x27;you posted:\n&#x27;</span>)</span><br><span class="line">  <span class="comment">//可以通过req.body来获取表单post请求体数据</span></span><br><span class="line">  res.end(<span class="built_in">JSON</span>.stringify(req.body, <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-path路径绝对化"><a href="#8-path路径绝对化" class="headerlink" title="8.path路径绝对化"></a>8.path路径绝对化</h3><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/path.html">参考文件</a></p>
<ul>
<li>path.basename<ul>
<li>获取一个路径的文件名</li>
</ul>
</li>
<li>path.dirname<ul>
<li>获取一个路径中的目录部分。</li>
</ul>
</li>
<li>path.extname<ul>
<li>获取一个路径中的扩展名部分。</li>
</ul>
</li>
<li>path.parse<ul>
<li>把一个路径转化为对象<ul>
<li>root 根路径</li>
<li>dir 目录</li>
<li>base 包含后缀名的文件名</li>
<li>ext  后缀名</li>
<li>name 不包括后缀名的文件</li>
</ul>
</li>
</ul>
</li>
<li>path.join<ul>
<li>当需要路径拼接的时候，推荐使用这个方法</li>
</ul>
</li>
<li>path.isAbsolute<ul>
<li>判断一个路径是否为绝对路径</li>
</ul>
</li>
</ul>
<h2 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h2><p>中间件的本质就是一个请求的处理方法，我们把用户从请求到响应的整个过程分发到多个中间件中去处理，这样做的目的是提高代码的灵活性，动态可扩展的。</p>
<blockquote>
<p>同一个请求所经过的中间件都是同一个请求对象和响应对象。</p>
</blockquote>
<p><strong>中间件本身是一个方法，该方法接收三个参数：</strong>(Request,Response,next)</p>
<ul>
<li>Request 请求对象</li>
<li>Response 响应对象</li>
<li>next   下一个中间件</li>
</ul>
<blockquote>
<p><strong>当一个请求进入一个中间件之后，如果不调用 next 则会停留在当前中间件，</strong>所以 next 是一个方法，用来调用下一个中间件的</p>
</blockquote>
<h3 id="1-应用程序级别中间件"><a href="#1-应用程序级别中间件" class="headerlink" title="1.应用程序级别中间件"></a>1.应用程序级别中间件</h3><p>万能匹配（不关心请求路径和请求方法）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>只要是以‘/xxx’开头的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/b&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-路由级别中间件"><a href="#2-路由级别中间件" class="headerlink" title="2.路由级别中间件"></a>2.路由级别中间件</h3><p>get:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/abc&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>post:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;/ 2&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>put:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.put(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Got a  PUT request at /user&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-错误处理中间件"><a href="#3-错误处理中间件" class="headerlink" title="3.错误处理中间件"></a>3.错误处理中间件</h3><blockquote>
<p>err,req, res, next 四个参数必须写全</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err,req, res, next</span>) </span>&#123; <span class="comment">//四个参数必须写全</span></span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;err.stack&#x27;</span>)</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">&#x27;something broke!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在发生错误的时候，调用next传递错误信息；next(err)</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;.d/sa./d.sa/.dsa&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// return res.status(500).send(&#x27;Server Error&#x27;)</span></span><br><span class="line">      <span class="comment">// 当调用 next 的时候，如果传递了参数，则直接往后找到带有 四个参数的应用程序级别中间件</span></span><br><span class="line">      <span class="comment">// 当发生错误的时候，我们可以调用 next 传递错误对象</span></span><br><span class="line">      <span class="comment">// 然后就会被全局错误处理中间件匹配到并处理之</span></span><br><span class="line">      next(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="4-第三方中间件"><a href="#4-第三方中间件" class="headerlink" title="4.第三方中间件"></a>4.第三方中间件</h3><p>[<a href="http://expressjs.com/en/resources/middleware.html]">http://expressjs.com/en/resources/middleware.html]</a>: </p>
<ul>
<li><a href="http://expressjs.com/en/resources/middleware/body-parser.html">body-parser</a> </li>
<li><a href="http://expressjs.com/en/resources/middleware/compression.html">compression</a> </li>
<li><a href="http://expressjs.com/en/resources/middleware/cookie-parser.html">cookie-parser</a> </li>
<li><a href="http://expressjs.com/en/resources/middleware/morgan.html">morgan</a> </li>
<li><a href="http://expressjs.com/en/resources/middleware/response-time.html">response-time</a> </li>
<li><a href="http://expressjs.com/en/resources/middleware/serve-static.html">serve-static</a> </li>
<li><a href="http://expressjs.com/en/resources/middleware/session.html">session</a> </li>
<li><a href="http://expressjs.com/en/resources/middleware/cors.html">cors</a> </li>
</ul>
<blockquote>
<p>内置中间件：<a href="http://expressjs.com/en/4x/api.html#express.static">express.static</a> 、<a href="http://expressjs.com/en/4x/api.html#express.json">express.json</a> 、<a href="http://expressjs.com/en/4x/api.html#express.urlencoded">express.urlencoded</a></p>
</blockquote>
<h2 id="node中的非模块成员"><a href="#node中的非模块成员" class="headerlink" title="node中的非模块成员"></a>node中的非模块成员</h2><p>在每个模块中，除了<code>exports``require</code>等模块相关API之外，还有两个特殊的成员：</p>
<ul>
<li><code>__dirname</code><strong>动态的获取</strong>可以用来获取当前文件模块所属目录的绝对路径</li>
<li><code>__filename</code><strong>动态获取</strong>可以用来获 取当前文件的绝对路径</li>
<li><code>__dirname</code>和<code>__filename</code>是不受执行node命令所属路径</li>
</ul>
<p>在文件操作的过程中，使用相对路径是不可靠的，因为在node中的文件操作路径被设计为相对于执行node命令所处的路径（不是bug，人家这样设计是有使用场景的）。</p>
<p>所以为了解决这一问题，需要把相对路径改为绝对路径。即使用<code>__dirname</code><strong>动态的获取</strong>绝对路径，此过程推荐使用<code>path.join()</code>来辅助拼接。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.join(__dirname, <span class="string">&#x27;文件名&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>**以后文件操作中使用的相对路径都统一转化为  动态的绝对路径  **</p>
<blockquote>
<p>补充：模块中的路径标识和这里的路径没关系，不受影响（相对于文件模块）。</p>
</blockquote>
<h2 id="koa2"><a href="#koa2" class="headerlink" title="koa2"></a>koa2</h2><p>koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架，也是目前流行的基于Node.js的Web开发框架,号称下一代web框架。 更小、更快速、更灵活、极简、开放开源的 web 开发框架。</p>
<p><a href="https://www.itying.com/koa/">API</a></p>
<h3 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h3><ul>
<li>首先</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd code  //进入code文件夹</span><br><span class="line">mkdir koa2 //创建koa2文件夹</span><br><span class="line">cd koa2  //进入koa2文件夹</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化生产package.json 文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<ul>
<li>生成package.json后，安装koa包，我们这里使用npm来进行安装</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install koa -D</span><br></pre></td></tr></table></figure>



<p>koa2也有像Express一样的应用生成器，通过应用koa脚手架生成工具 可以快速创建一个基于koa2的应用的骨架。</p>
<p>通过如下命令安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install koa-generator -g</span><br></pre></td></tr></table></figure>

<p>安装所有依赖包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> koa_demo </span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>启动这个应用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DEBUG=myapp npm star</span><br><span class="line">// 或者 npm start</span><br></pre></td></tr></table></figure>

<h3 id="2-HelloKoa2"><a href="#2-HelloKoa2" class="headerlink" title="2.HelloKoa2"></a>2.<strong>HelloKoa2</strong></h3><p>在根目录下新建index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置koa中间件</span></span><br><span class="line">app.use( <span class="keyword">async</span> ( ctx ) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">&#x27;hello koa2&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start-quick is starting at port 3000&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ctx是koa自带的对象，Koa Context 将 node 的 <code>request</code> 和 <code>response</code> 对象封装到单个对象中，<em>每个</em> 请求都将创建一个 <code>Context</code>，并在中间件中作为接收器引用，或者 <code>ctx</code> 标识符</p>
</blockquote>
<p>编写完成后在命令行中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure>

<p>然后在浏览器中输入：<a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> 就可以看到结果了。</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>定义：</p>
<ul>
<li>中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件。</li>
<li>express中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处理请求-响应循环流程中的中间件，一般被命名为 next 的变量。在Koa中中间件和express有点类似。</li>
</ul>
<p>功能：</p>
<ul>
<li>执行任何代码。</li>
<li>修改请求和响应对象。</li>
<li>终结请求-响应循环。</li>
<li>调用堆栈中的下一个中间件。</li>
</ul>
<p><strong>Koa应用中间件：</strong></p>
<ul>
<li>应用级中间件</li>
<li>路由级中间件</li>
<li>错误处理中间件</li>
<li>第三方中间件</li>
</ul>
<p>Koa中间件的执行顺序：</p>
<p><a href="https://www.itying.com/koa/data/news/image/20180406/20180406134220_35560.png">https://www.itying.com/koa/data/news/image/20180406/20180406134220_35560.png</a></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200816105004618.png" alt="image-20200816105004618"></p>
<h3 id="3-get请求"><a href="#3-get请求" class="headerlink" title="3.get请求"></a>3.get请求</h3><blockquote>
<p>获得GET请求的方式有两种，一种是从request中获得，一种是一直从上下文中获得。获得的格式也有两种：query和querystring。</p>
</blockquote>
<h4 id="query和querystring区别"><a href="#query和querystring区别" class="headerlink" title="query和querystring区别"></a><strong>query和querystring区别</strong></h4><p><strong>在koa2中GET请求通过request接收</strong>，但是接收的方法有两种：query和querystring。</p>
<ul>
<li>query：返回的是格式化好的参数对象。</li>
<li>querystring：返回的是请求字符串。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> url =ctx.url;</span><br><span class="line">    <span class="keyword">let</span> request =ctx.request;</span><br><span class="line">    <span class="keyword">let</span> req_query = request.query;</span><br><span class="line">    <span class="keyword">let</span> req_querystring = request.querystring;</span><br><span class="line"></span><br><span class="line">    ctx.body=&#123;</span><br><span class="line">        url,</span><br><span class="line">        req_query,</span><br><span class="line">        req_querystring</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>编写好后，在终端中使用node demo1.js启动服务。启动一切正常可在浏览器中使用[<a href="http://127.0.0.1:3000/?user=jspang&amp;age=18%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E3%80%82%E6%88%91%E4%BB%AC%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%B2JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BE%88%E6%83%B3%E5%90%8E%E7%AB%AF%E4%BC%A0%E7%BB%99%E6%88%91%E4%BB%AC%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%82">http://127.0.0.1:3000?user=jspang&amp;age=18来进行访问。我们在网页中可以得到一串JSON字符串，这是不是很想后端传给我们的接口。</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;url&quot;</span>:<span class="string">&quot;/?user=jspang&amp;age=18&quot;</span>,<span class="string">&quot;req_query&quot;</span>:&#123;<span class="string">&quot;user&quot;</span>:<span class="string">&quot;jspang&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>&#125;,<span class="string">&quot;req_querystring&quot;</span>:<span class="string">&quot;user=jspang&amp;age=18&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接从ctx中获取GET请求"><a href="#直接从ctx中获取GET请求" class="headerlink" title="直接从ctx中获取GET请求"></a>直接从ctx中获取GET请求</h4><p>除了在ctx.request中获取Get请求外，还可以直接在ctx中得到GET请求。ctx中也分为query和querystring。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> url =ctx.url;</span><br><span class="line">    <span class="comment">//从request中获取GET请求</span></span><br><span class="line">    <span class="keyword">let</span> request =ctx.request;</span><br><span class="line">    <span class="keyword">let</span> req_query = request.query;</span><br><span class="line">    <span class="keyword">let</span> req_querystring = request.querystring;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从上下文中直接获取</span></span><br><span class="line">    <span class="keyword">let</span> ctx_query = ctx.query;</span><br><span class="line">    <span class="keyword">let</span> ctx_querystring = ctx.querystring;</span><br><span class="line">    ctx.body=&#123;</span><br><span class="line">        url,</span><br><span class="line">        req_query,</span><br><span class="line">        req_querystring,</span><br><span class="line">        ctx_query,</span><br><span class="line">        ctx_querystring</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-post请求"><a href="#4-post请求" class="headerlink" title="4.post请求"></a>4.post请求</h3><p> 对于POST请求的处理，Koa2没有封装方便的获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req来获取。 </p>
<h4 id="获取Post请求的步骤："><a href="#获取Post请求的步骤：" class="headerlink" title="获取Post请求的步骤："></a><strong>获取Post请求的步骤：</strong></h4><ol>
<li>解析上下文ctx中的原生node.js对象req。——–字符串</li>
<li>将POST表单数据解析成query string-字符串.(例如:user=jspang&amp;age=18)</li>
<li>将字符串转换成JSON格式。</li>
</ol>
<p><strong>ctx.request和ctx.req的区别</strong></p>
<ul>
<li>ctx.request:是Koa2中context经过封装的请求对象，它用起来更直观和简单。</li>
<li>ctx.req:是context提供的node.js原生HTTP请求对象。这个虽然不那么直观，但是可以得到更多的内容，适合我们深度编程。</li>
</ul>
<p><strong>ctx.method 得到请求类型</strong></p>
<p>Koa2中提供了ctx.method属性，可以轻松的得到请求的类型，然后根据请求类型编写不同的相应方法，这在工作中非常常用。我们先来作个小例子，根据请求类型获得不同的页面内容。GET请求时得到表单填写页面，POST请求时，得到POST处理页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line">app.use(async(ctx)&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;当请求时GET请求时，显示表单让用户填写</span><br><span class="line">    if(ctx.url&#x3D;&#x3D;&#x3D;&#39;&#x2F;&#39; &amp;&amp; ctx.method &#x3D;&#x3D;&#x3D; &#39;GET&#39;)&#123;</span><br><span class="line">        let html &#x3D;&#96;</span><br><span class="line">            &lt;h1&gt;Koa2 request post demo&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;form method&#x3D;&quot;POST&quot;  action&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">                &lt;p&gt;userName&lt;&#x2F;p&gt;</span><br><span class="line">                &lt;input name&#x3D;&quot;userName&quot; &#x2F;&gt; &lt;br&#x2F;&gt;</span><br><span class="line">                &lt;p&gt;age&lt;&#x2F;p&gt;</span><br><span class="line">                &lt;input name&#x3D;&quot;age&quot; &#x2F;&gt; &lt;br&#x2F;&gt;</span><br><span class="line">                &lt;p&gt;webSite&lt;&#x2F;p&gt;</span><br><span class="line">                &lt;input name&#x3D;&#39;webSite&#39; &#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">                &lt;button type&#x3D;&quot;submit&quot;&gt;submit&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;form&gt;</span><br><span class="line">        &#96;;</span><br><span class="line">        ctx.body &#x3D;html;</span><br><span class="line">    &#x2F;&#x2F;当请求时POST请求时</span><br><span class="line">    &#125;else if(ctx.url&#x3D;&#x3D;&#x3D;&#39;&#x2F;&#39; &amp;&amp; ctx.method &#x3D;&#x3D;&#x3D; &#39;POST&#39;)&#123;</span><br><span class="line">        ctx.body&#x3D;&#39;接收到请求&#39;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;其它请求显示404页面</span><br><span class="line">        ctx.body&#x3D;&#39;&lt;h1&gt;404!&lt;&#x2F;h1&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000,()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;[demo] server is starting at port 3000&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>写好这段代码后你可以用node命令执行它，然后再浏览器中输入<a href="http://127.0.0.1:3000进行查看，第一次进入时给我们展现的是一个表单页面，我们点击提交后可以看到服务器接收到了我们的信息，但我们并没有做出任何处理。当我们输入一个其他的地址时，它会提示404错误。">http://127.0.0.1:3000进行查看，第一次进入时给我们展现的是一个表单页面，我们点击提交后可以看到服务器接收到了我们的信息，但我们并没有做出任何处理。当我们输入一个其他的地址时，它会提示404错误。</a></p>
<h3 id="5-koa-router"><a href="#5-koa-router" class="headerlink" title="5.koa-router"></a>5.koa-router</h3><blockquote>
<p>路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p>
<p>Koa中的路由和Express有所不同，在Express中直接引入Express就可以配置路由，但是在Koa中我们需要安装对应的koa-router路由模块来实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save koa-router</span><br></pre></td></tr></table></figure>

<p>基础的使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> Router();</span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    ctx.body=<span class="string">&quot;Hello koa&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">&#x27;/news&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;新闻page&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启用路由</span></span><br><span class="line">app.use(router.routes);</span><br><span class="line"><span class="comment">// 遵循get请求方式</span></span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>







<h3 id="6-koa-cookie"><a href="#6-koa-cookie" class="headerlink" title="6.koa-cookie"></a>6.koa-cookie</h3><p><strong>1、Koa中设置Cookie的值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.cookies.set(name, value, [options])</span><br></pre></td></tr></table></figure>

<p><strong>通过 options 设置 cookie name 的 value :</strong></p>
<table>
<thead>
<tr>
<th>options名称</th>
<th>options值</th>
</tr>
</thead>
<tbody><tr>
<td>maxAge</td>
<td>一个数字表示从 Date.now() 得到的毫秒数</td>
</tr>
<tr>
<td>expires cookie</td>
<td>过期的 Date 数值</td>
</tr>
<tr>
<td>path cookie</td>
<td>路径, 默认是’/‘</td>
</tr>
<tr>
<td>domain cookie</td>
<td>域名</td>
</tr>
<tr>
<td>secure</td>
<td>安全 cookie   默认false，设置成true表示只有 https可以访问</td>
</tr>
<tr>
<td>httpOnly</td>
<td>是否只是服务器可访问 cookie, 默认是 true</td>
</tr>
<tr>
<td>overwrite</td>
<td>布尔值，表示是否覆盖以前设置的同名的 cookie (默认是 false)</td>
</tr>
<tr>
<td>Cookie</td>
<td>（不管路径或域）是否在设置此Cookie 时从 Set-Cookie 标头中过滤掉。</td>
</tr>
</tbody></table>
<p><strong>2、Koa中获取Cookie的值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.cookies.get(<span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3、Koa中设置中文Cookie</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Buffer(<span class="string">&#x27;hello, world!&#x27;</span>).toString(<span class="string">&#x27;base64&#x27;</span>));<span class="comment">// 转换成base64字符串：aGVsbG8sIHdvcmxkIQ==</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Buffer(<span class="string">&#x27;aGVsbG8sIHdvcmxkIQ==&#x27;</span>, <span class="string">&#x27;base64&#x27;</span>).toString());<span class="comment">// 还原base64字符串：hello, world!</span></span><br></pre></td></tr></table></figure>

<h3 id="7-koa-session"><a href="#7-koa-session" class="headerlink" title="7.koa-session"></a>7.koa-session</h3><p><strong>1.安装</strong> <strong>koa-session</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install koa-session --save</span><br></pre></td></tr></table></figure>

<p><strong>2.引入express-session</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&#x27;koa-session&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3.设置官方文档提供的中间件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.keys = [<span class="string">&#x27;some secret hurr&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> CONFIG = &#123;</span><br><span class="line">   key: <span class="string">&#x27;koa:sess&#x27;</span>,   <span class="comment">//cookie key (default is koa:sess)</span></span><br><span class="line">   maxAge: <span class="number">86400000</span>,  <span class="comment">// cookie的过期时间 maxAge in ms (default is 1 days)</span></span><br><span class="line">   overwrite: <span class="literal">true</span>,  <span class="comment">//是否可以overwrite    (默认default true)</span></span><br><span class="line">   httpOnly: <span class="literal">true</span>, <span class="comment">//cookie是否只有服务器端可以访问 httpOnly or not (default true)</span></span><br><span class="line">   signed: <span class="literal">true</span>,   <span class="comment">//签名默认true</span></span><br><span class="line">   rolling: <span class="literal">false</span>,  <span class="comment">//在每次请求时强行设置cookie，这将重置cookie过期时间（默认：false）</span></span><br><span class="line">   renew: <span class="literal">false</span>,  <span class="comment">//(boolean) renew session when session is nearly expired,</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启用</span></span><br><span class="line">app.use(session(CONFIG, app));</span><br></pre></td></tr></table></figure>

<p><strong>4.使用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">设置值 ctx.session.username = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">     获取值 ctx.session.username</span><br></pre></td></tr></table></figure>

<h3 id="8-koa模板初始（ejs）"><a href="#8-koa模板初始（ejs）" class="headerlink" title="8.koa模板初始（ejs）"></a>8.koa模板初始（ejs）</h3><p>开发中不可能把所有的html代码全部写在JS里，这显然不现实，也没办法完成大型web开发。必须借用模板机制来帮助我们开发。</p>
<p><strong>1.安装中间件</strong></p>
<p>在koa2中使用模板机制必须依靠中间件，我们这里选择koa-views中间件，先使用npm来进行安装。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cnpm install --save koa-views</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意是koa-views 而不是  koa-view</p>
</blockquote>
<p><strong>2.安装ejs模板引擎</strong></p>
<p>ejs是个著名并强大的模板引擎，可以单独安装。很多开源软件都采用了ejs模板引擎。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install --save ejs</span><br></pre></td></tr></table></figure>

<p><strong>3.编写模板</strong> </p>
<p>安装好ejs模板引擎后，就可以编写模板了，为了模板统一管理，我们新建一个view的文件夹，并在它下面新建index.ejs文件。<code>注意后缀名是ejs</code></p>
<p>views/index.ejs</p>
<p>在文件中使用<code>&lt;%= 变量名 %&gt;</code>进行赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;http://jspang.com/wp-admin/post.php?post=2760&amp;action=edit#</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;EJS Welcome to &lt;%= title %&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>4.编写koa文件</strong></p>
<p>在js文件中配置并渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="comment">//首先引入 koa-views</span></span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">&#x27;koa-views&#x27;</span>)</span><br><span class="line"><span class="comment">//引入node自带路径管理</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模板引擎，在views中有两个参数：参数1:路径，参数2：extension: &#x27;ejs&#x27;</span></span><br><span class="line">app.use(views(path.join(__dirname, <span class="string">&#x27;./view&#x27;</span>), &#123;</span><br><span class="line">  extension: <span class="string">&#x27;ejs&#x27;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.use( <span class="keyword">async</span> ( ctx ) =&gt; &#123;</span><br><span class="line">  <span class="comment">//命名变量</span></span><br><span class="line">  <span class="keyword">let</span> title = <span class="string">&#x27;hello koa2&#x27;</span></span><br><span class="line">  <span class="comment">//渲染index.ejs文件，并把变量传过去</span></span><br><span class="line">  <span class="keyword">await</span> ctx.render(<span class="string">&#x27;index&#x27;</span> , &#123;title&#125; )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>底层实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app=express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tem=&#123;</span><br><span class="line">    message:<span class="string">&quot;我是中间部分&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line">http.createServer(app).listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Server is listening port 3000&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//挂载静态资源处理中间件</span></span><br><span class="line">app.use(express.static(__dirname+<span class="string">&quot;/public&quot;</span>));</span><br><span class="line"><span class="comment">//设置模板视图的目录</span></span><br><span class="line">app.set(<span class="string">&quot;views&quot;</span>,<span class="string">&quot;./public/views&quot;</span>);</span><br><span class="line"><span class="comment">//设置是否启用视图编译缓存，启用将加快服务器执行效率</span></span><br><span class="line">app.set(<span class="string">&quot;view cache&quot;</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//设置模板引擎的格式即运用何种模板引擎</span></span><br><span class="line">app.set(<span class="string">&quot;view engine&quot;</span>,<span class="string">&quot;ejs&quot;</span>);</span><br><span class="line"><span class="comment">//设置路由</span></span><br><span class="line">app.get(<span class="string">&quot;/ejs&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.render(<span class="string">&quot;ejs1&quot;</span>,&#123;<span class="attr">title</span>:tem.message&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>EJS常用标签</p>
<ul>
<li>&lt;% %&gt;流程控制标签</li>
<li>&lt;%= %&gt;输出标签（原文输出HTML标签）</li>
<li>&lt;%- %&gt;输出标签（HTML会被浏览器解析）</li>
<li>&lt;%# %&gt;注释标签</li>
<li>% 对标记进行转义</li>
<li>-%&gt;去掉没用的空格</li>
</ul>
<p>函数</p>
<blockquote>
<p>render(src,data,[option]) 函数</p>
<p>option 为配置项</p>
</blockquote>
<h3 id="9-koa-static静态资源中间件"><a href="#9-koa-static静态资源中间件" class="headerlink" title="9.koa-static静态资源中间件"></a>9.koa-static静态资源中间件</h3><blockquote>
<p>koa-static主要是用于访问静态资源</p>
</blockquote>
<p>一个http请求访问web服务静态资源，一般响应结果有三种情况</p>
<ul>
<li>访问文本，例如js，css，png，jpg，gif</li>
<li>访问静态目录</li>
<li>找不到资源，抛出404错误</li>
</ul>
<p><strong>Koa 中koa-static中间件的使用</strong></p>
<p><strong>1、安装 koa-static</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save koa-static</span><br></pre></td></tr></table></figure>

<p><strong>2、引入配置中间件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>); </span><br><span class="line">app.use(<span class="keyword">static</span>(</span><br><span class="line">    path.join( __dirname,  <span class="string">&#x27;public&#x27;</span>)  <span class="comment">//public即是静态资源存放的地方。使用绝对位置</span></span><br><span class="line">)) </span><br></pre></td></tr></table></figure>

<p><strong>3、koa中间件即可解析public静态资源</strong></p>
<h3 id="10-koa-bodyparser"><a href="#10-koa-bodyparser" class="headerlink" title="10.koa-bodyparser"></a>10.koa-bodyparser</h3><blockquote>
<p>koa-bodyparser用于 Koa post提交数据的一个模块</p>
</blockquote>
<p>原理：对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文（ctx）的formData数据解析到ctx.request.body中。</p>
<p><strong>1、安装 koa-bodyparser</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save koa-bodyparser</span><br></pre></td></tr></table></figure>

<p><strong>2、安装</strong> <strong>koa-bodyparser</strong> <strong>引入配置中间件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(bodyParser());</span><br><span class="line"> </span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123; </span><br><span class="line">  ctx.body = ctx.request.body;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>3、通过**</strong>ctx.request.body 获取post提交的数据**</p>
<ul>
<li>ctx.request.body 获取post提交的数据</li>
</ul>
<h3 id="生词表"><a href="#生词表" class="headerlink" title="生词表"></a>生词表</h3><p>router.prefix(‘/users’)   设置父路径。</p>
<p>ctx: res,req的合体</p>
<p>ctx.body = {}  返回内容</p>
<p>next()下一个中间键</p>
<h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p><strong>介绍</strong></p>
<p>session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而session保存在服务器上。</p>
<p><strong>Session的工作流程</strong></p>
<p>当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)。 客户的信息都保存在session中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CONFIG = &#123;</span><br><span class="line">   key: <span class="string">&#x27;koa:sess&#x27;</span>,   <span class="comment">//cookie key (default is koa:sess)</span></span><br><span class="line">   maxAge: <span class="number">86400000</span>,  <span class="comment">// cookie的过期时间 maxAge in ms (default is 1 days)</span></span><br><span class="line">   overwrite: <span class="literal">true</span>,  <span class="comment">//是否可以overwrite    (默认default true)</span></span><br><span class="line">   httpOnly: <span class="literal">true</span>, <span class="comment">//cookie是否只有服务器端可以访问 httpOnly or not (default true)</span></span><br><span class="line">   signed: <span class="literal">true</span>,   <span class="comment">//签名默认true</span></span><br><span class="line">   rolling: <span class="literal">false</span>,  <span class="comment">//在每次请求时强行设置cookie，这将重置cookie过期时间（默认：false）</span></span><br><span class="line">   renew: <span class="literal">false</span>,  <span class="comment">//(boolean) renew session when session is nearly expired,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在node中使用Session</p>
<ul>
<li><p>安装:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install express-session</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：<em>注意：一定要在app.use(router)之前</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(session(&#123;</span><br><span class="line">    secret: <span class="string">&#x27;xww&#x27;</span>, <span class="comment">//配置加密字符串   为了增加安全性</span></span><br><span class="line">    resave: <span class="literal">false</span>,</span><br><span class="line">    saveUninitialized: <span class="literal">true</span> <span class="comment">//无论你是否使用Session，我们都默认会给你一把钥匙 值为false时不会给钥匙</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：</p>
<ul>
<li><p>配置好插件之后，通过req.session来访问和设置Session成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加Session数据：</span></span><br><span class="line">req.session.foo=<span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="comment">//访问Session数据：</span></span><br><span class="line">req.session.foo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认session数据是内存存储的，服务器一旦重启，真正的生产环境会把session进行持久化存储。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p><strong>COOKIE</strong> <strong>简介</strong></p>
<p>cookie 是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一个域名的时候共享数据。</p>
<p>● HTTP是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何关系的。</p>
<p>● Cookie是一个简单到爆的想法：当访问一个页面的时候，服务器在下行HTTP报文中，命令浏览器存储一个字符串; 浏览器再访问同一个域的时候，将把这个字符串携带到上行HTTP请求中。第一次访问一个服务器，不可能携带cookie。 必须是服务器得到这次请求，在下行响应报头中，携带cookie信息，此后每一次浏览器往这个服务器发出的请求，都会携带这个cookie。</p>
<p><strong>选项：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">maxAge              一个数字表示从 <span class="built_in">Date</span>.now() 得到的毫秒数</span><br><span class="line">expires cookie      过期的 <span class="built_in">Date</span></span><br><span class="line">path cookie         路径, 默认是<span class="string">&#x27;/&#x27;</span></span><br><span class="line">domain cookie       域名</span><br><span class="line">secure             安全 cookie   默认<span class="literal">false</span>，设置成<span class="literal">true</span>表示只有 https可以访问</span><br><span class="line">httpOnly           是否只是服务器可访问 cookie, 默认是 <span class="literal">true</span></span><br><span class="line">overwrite          一个布尔值，表示是否覆盖以前设置的同名的 cookie (默认是 <span class="literal">false</span>). 如果是 <span class="literal">true</span>, 在同一个请求中设置相同名称的所有 Cookie（不管路径或域）是否在设置此Cookie 时从 <span class="built_in">Set</span>-Cookie 标头中过滤掉。</span><br></pre></td></tr></table></figure>

<p>cookie与session<strong>的区别：</strong></p>
<ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>  考虑到安全应当使用session。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>  考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
</ol>
<h2 id="dirname-和-filename"><a href="#dirname-和-filename" class="headerlink" title="__dirname 和 __filename"></a>__dirname 和 __filename</h2><ul>
<li><p><strong>动态的</strong> 获取当前文件或者文件所处目录的<strong>绝对路径</strong></p>
</li>
<li><p>用来解决文件操作路劲的相对路径问题</p>
</li>
<li><p>因为在文件操作中，相对路径相对于执行 <code>node</code> 命令所处的目录</p>
</li>
<li><p>所以为了尽量避免这个问题，都建议文件操作的相对路劲都转为：<strong>动态的绝对路径</strong></p>
</li>
<li><p><strong>方式</strong>：<code>path.join(__dirname, &#39;文件名&#39;)</code></p>
<blockquote>
<p>在模块中的相对路径和文件操作路径不同，注重文件操作中文件的动态获取。</p>
</blockquote>
</li>
</ul>
<h2 id="node中的日志"><a href="#node中的日志" class="headerlink" title="node中的日志"></a>node中的日志</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>日志：用于记录上线之后的一些信息，因为在上线之后可能会产生bug，可以通过查看日志来查询bug。也可以通过查看日志来查询每天的访问的各种信息，例如：访问的浏览器  系统等。那么对于日志的<strong>开发需要处理那些方面</strong>呢，总结概述为下面的三个方面：</p>
<p>  <strong>1.nodejs文件操作，nodejs stream<br>  2.日志功能开发和使用<br>  3.日志文件拆分，日志内容分析</strong></p>
<p>为何<strong>日志存在文件之中</strong></p>
<p><strong>1.文件中的内容可以转到各个服务器上去计算运行，不需要配置。<br>2.日志中的内容只是一条一条的信息，本身对内存性能上的要求并不是太高<br>3.不存在mysql中的原因是，mysql是硬盘数据库，里面存放的是各表之间的某种关联关系，如果要将日志中内容放在其他服务器进行分析，使用MySQL则需要在服务器中对mysql进行配置以及保证各服务器上的数据库必须保证一致<br>4.不存在redis当中是因为redis是内存数据库，日志会随着时间的推移而变得越来越多因此，如果使用redis是非常的不划算的。因为redis中的内存是非常宝贵的，日志对于性能的要求不太高，因此不需要。</strong></p>
<h3 id="2-日志的类型"><a href="#2-日志的类型" class="headerlink" title="2.日志的类型"></a>2.日志的类型</h3><ol>
<li>访问日志 <code>access log</code> （server端最重要的日志）</li>
<li>自定义日志（包括自定义事件、错误记录等）</li>
</ol>
<h3 id="3-日志与流的使用"><a href="#3-日志与流的使用" class="headerlink" title="3.日志与流的使用"></a>3.日志与流的使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写日志</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeLog</span>(<span class="params">writeStream, log</span>) </span>&#123;</span><br><span class="line">    writeStream.write(log + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个写日志流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWrite</span>(<span class="params">flieName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> filepath = path.join(__dirname, <span class="string">&#x27;/logs&#x27;</span>, flieName)</span><br><span class="line">    <span class="keyword">let</span> writeStream = fs.createWriteStream(filepath, &#123;</span><br><span class="line">        flags: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">        encoding: <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> writeStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写访问日志</span></span><br><span class="line"><span class="keyword">const</span> accessWriteStream = createWrite(<span class="string">&#x27;access.log&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">access</span>(<span class="params">log</span>) </span>&#123;</span><br><span class="line">    writeLog(accessWriteStream, log)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    access</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-日志拆分"><a href="#4-日志拆分" class="headerlink" title="4.日志拆分"></a>4.日志拆分</h3><blockquote>
<p> 由于日志内容会慢慢积累，放在一个文件中不好处理，所以对日志文件要进行拆分处理。一般按时间划分日志文件。</p>
</blockquote>
<p>实现方式：linux的crontab命令，定时任务</p>
<p>1.设置定时任务，格式：<code> * * * * * command</code></p>
<ul>
<li>第一个<code>*</code>代表分钟</li>
<li>第二个<code>*</code>代表分小时</li>
<li>第三个<code>*</code>代表是多少号</li>
<li>第四个<code>*</code>代表是月份</li>
<li>第五个<code>*</code>代表星期几</li>
<li>command  linux的命令</li>
</ul>
<p>2.将access.log拷贝并且重新命名为<code>2019-02-10.access.log</code>的格式。</p>
<p>3.清空access.log文件，继续积累日志。</p>
<h3 id="5-日志分析"><a href="#5-日志分析" class="headerlink" title="5.日志分析"></a>5.日志分析</h3><p>何为日志分析呢？  例如 在<code>access.log</code>日志，分析chrome的占比</p>
<ul>
<li><p>日志是按照行存储的，一行就是一条日志。</p>
</li>
<li><p>使用nodejs的readline可以读取文件一整行的内容（使用Stream,效率更高）。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件名</span></span><br><span class="line"><span class="keyword">const</span> flieName = path.join(__dirname, <span class="string">&#x27;/logs/access.log&#x27;</span>)</span><br><span class="line">    <span class="comment">// 创建 read Stream</span></span><br><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(flieName)</span><br><span class="line">    <span class="comment">// 创建 readline 对象</span></span><br><span class="line"><span class="keyword">const</span> rl = readline.createInterface(&#123;</span><br><span class="line">    input: readStream</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chromeNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐行读取</span></span><br><span class="line">rl.on(<span class="string">&#x27;line&#x27;</span>, <span class="function">(<span class="params">lineDate</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lineDate) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">let</span> arr = lineDate.split(<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">2</span>] &amp;&amp; arr[<span class="number">2</span>].indexOf(<span class="string">&#x27;Chrome&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            chromeNum++</span><br><span class="line">        &#125;</span><br><span class="line">        sum++</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 监听读取完成</span></span><br><span class="line">rl.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;chrome 占比：&#x27;</span> + (chromeNum / sum).toFixed(<span class="number">4</span>) * <span class="number">100</span> + <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="6-插件morgan"><a href="#6-插件morgan" class="headerlink" title="6.插件morgan"></a>6.插件morgan</h3><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><p><code>npm i morgan --save</code></p>
<h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><p>​          logger(format,options)</p>
<h4 id="format-（string-function）打印方式，可以是预定义打印方式的名称，或格式化字符串，或格式化入口的回调方法"><a href="#format-（string-function）打印方式，可以是预定义打印方式的名称，或格式化字符串，或格式化入口的回调方法" class="headerlink" title="format:（string/function）打印方式，可以是预定义打印方式的名称，或格式化字符串，或格式化入口的回调方法"></a>format:（string/function）打印方式，可以是预定义打印方式的名称，或格式化字符串，或格式化入口的回调方法</h4><ul>
<li>使用预定义打印方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">morgan(<span class="string">&#x27;tiny&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用格式化字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">morgan(<span class="string">&#x27;:method :url :status :res[content-length] - :response-time ms&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用格式化回调方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">morgan(function (tokens, req, res) &#123;</span><br><span class="line">  return [</span><br><span class="line">    tokens.method(req, res),</span><br><span class="line">    tokens.url(req, res),</span><br><span class="line">    tokens.status(req, res),</span><br><span class="line">    tokens.res(req, res, &#39;content-length&#39;), &#39;-&#39;,</span><br><span class="line">    tokens[&#39;response-time&#39;](req, res), &#39;ms&#39;</span><br><span class="line">  ].join(&#39; &#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="options：（object）日志打印参数配置"><a href="#options：（object）日志打印参数配置" class="headerlink" title="options：（object）日志打印参数配置"></a>options：（object）日志打印参数配置</h4><ul>
<li>immediate: 请求到达时打印</li>
<li>skip: 设置忽略打印的日志</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">morgan(<span class="string">&#x27;combined&#x27;</span>, &#123;</span><br><span class="line">  skip: <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; <span class="keyword">return</span> res.statusCode &lt; <span class="number">400</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>stream: 输出流，默认控制台输出</li>
<li>Predefined Formats: 预定义打印格式</li>
</ul>
<h4 id="预定义格式"><a href="#预定义格式" class="headerlink" title="预定义格式"></a><strong>预定义格式</strong></h4><p>combined: 标准Apache组合日志输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:remote-addr - :remote-user [:date[clf]] &quot;:method :url HTTP&#x2F;:http-version&quot; :status :res[content-length] &quot;:referrer&quot; &quot;:user-agent&quot;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>common: 标准Apache公共日志输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:remote-addr - :remote-user [:date[clf]] <span class="string">&quot;:method :url HTTP/:http-version&quot;</span> :status :res[content-length]</span><br></pre></td></tr></table></figure>

<p>dev: 根据返回的状态码彩色输出日志</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:method :url :status :response-time ms - :res[content-length]</span><br></pre></td></tr></table></figure>

<p>short: 简洁输出，带响应时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms</span><br></pre></td></tr></table></figure>

<p>tiny: 控制台输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">:method :url :status :res[content-length] - :response-time ms</span><br></pre></td></tr></table></figure>

<p>token 自定义格式输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">morgan.token(<span class="string">&#x27;type&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; <span class="keyword">return</span> req.headers[<span class="string">&#x27;content-type&#x27;</span>] &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="设置项"><a href="#设置项" class="headerlink" title="设置项"></a>设置项</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:date[format] 日期格式</span><br><span class="line"></span><br><span class="line">+ clf: “10&#x2F;Oct&#x2F;2000:13:55:36 +0000”</span><br><span class="line">+ iso: “2000-10-10T13:55:36.000Z”</span><br><span class="line">+ web “Tue, 10 Oct 2000 13:55:36 GMT”</span><br><span class="line"></span><br><span class="line">:http-version http版本</span><br><span class="line"></span><br><span class="line">:method 请求类型</span><br><span class="line"></span><br><span class="line">:referrer 请求的引用头</span><br><span class="line"></span><br><span class="line">:remote-addr 远程请求地址</span><br><span class="line"></span><br><span class="line">:remote-user 远程用户</span><br><span class="line"></span><br><span class="line">:req[header] 请求头信息 &#39;-&#39;分隔</span><br><span class="line"></span><br><span class="line">:response-time[digits] 请求响应时间</span><br><span class="line"></span><br><span class="line">:status 响应状态码</span><br><span class="line"></span><br><span class="line">:url 访问地址</span><br><span class="line"></span><br><span class="line">:user-agent 浏览器信息</span><br></pre></td></tr></table></figure>



<p>生产配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;morgan&#x27;</span>)</span><br><span class="line"><span class="comment">// 配置morgan,输出日志</span></span><br><span class="line"><span class="comment">// 环境</span></span><br><span class="line"><span class="keyword">const</span> ENV = process.env.NODE_ENV;</span><br><span class="line"><span class="keyword">if</span> (ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    app.use(logger(<span class="string">&#x27;dev&#x27;</span>))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileName = path.join(__dirname, <span class="string">&#x27;./logs/access.log&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> writeStream = fs.createWriteStream(fileName, &#123;</span><br><span class="line">        flags: <span class="string">&quot;a&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    app.use(logger(<span class="string">&#x27;combined&#x27;</span>, &#123;</span><br><span class="line">        stream: writeStream</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="node流（stream）"><a href="#node流（stream）" class="headerlink" title="node流（stream）"></a>node流（stream）</h2><p>对 于之前的<strong>I/O读取有以下的几个缺点</strong>：</p>
<ol>
<li><p>IO包括 “网络IO”和“文件IO” 两者都有一个共性在输入与读取文件的时候，都是将IO操作中的数据读取完之后，才进行下一步的操作，很显然这样的处理方式是非常的不可取的。</p>
</li>
<li><p>相比于CPU计算和内存的读写，IO操作的速度就非常的慢了。</p>
</li>
</ol>
<p>因此针对于上面文件的不足，在此就引入<strong>stream</strong>流的思想来进行优化。<strong>stream由三个部分组成 resource  pipe  deststream的思想就是缓冲思想，将文件初始中的数据先通过pipe给dest，然后就这样一直传送数据，最后直至到文件传输完成，即可完成文件传送过程，这也就是去提高IO操作效率的方法</strong></p>
<ul>
<li>标准的输入与输出通过process来进行管理process.stdin.pipe(process.stdout)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将req  res以stream的方式连接</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.method === <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">        req.pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用stream进行文件的copy,实现部分的代码如下：</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileName1 = path.resolve(__dirname, <span class="string">&#x27;data.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fileName2 = path.resolve(__dirname, <span class="string">&#x27;data-bak.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个读文件与一个写文件</span></span><br><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(fileName1);</span><br><span class="line"><span class="keyword">const</span> writeStream = fs.createWriteStream(fileName2);</span><br><span class="line"></span><br><span class="line">readStream.pipe(writeStream);</span><br><span class="line"></span><br><span class="line">readStream.on(<span class="string">&#x27;data&#x27;</span> , <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk.toString());</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">readStream.on(<span class="string">&#x27;end&#x27;</span>,<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;copy done&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件中的内容读入，并通过res返回，具体的实现代码如下</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fileName1 = path.resolve(__dirname, <span class="string">&#x27;data.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(fileName1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.method === <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">        readStream.pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fs,createWriteStream(filename,[option])    // 创建一个容器，用来放流出容器</p>
</blockquote>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>几种常见的安全问题，通过web server 层做一些预防</p>
<ul>
<li><p>sql 注入：窃取数据库内容</p>
<ul>
<li>使用escape,防止sql注入。</li>
<li>对敏感变量进行过滤—&gt;  escape(username)</li>
</ul>
</li>
<li><p>XSS 攻击：窃取前端的 cookie 内容</p>
<ul>
<li>安装xss工具<code>npm install xss --sava</code></li>
<li>引入xss</li>
<li>将敏感变量用xss()函数包裹字符化。 </li>
</ul>
</li>
<li><p>密码加密：保障用户信息安全</p>
<ul>
<li>使用node内部提供的加密库<code>crypto</code></li>
<li>自定义一个密钥（string）</li>
<li>使用MD5进行加密</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>) <span class="comment">// 加密的库</span></span><br><span class="line"><span class="comment">// 先制作一个密钥</span></span><br><span class="line"><span class="keyword">const</span> SECRET_KEY = <span class="string">&#x27;XwW_2037.&#x27;</span></span><br><span class="line"><span class="comment">// md5 加密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">md5</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> md5.update(content).digest(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加密函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genPassword</span>(<span class="params">password</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = <span class="string">`password = <span class="subst">$&#123;password&#125;</span>&amp;key = <span class="subst">$&#123;SECRET_KEY&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> md5(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(genPassword(<span class="number">123</span>))  <span class="comment">// 559ef855497b5b7718f2c84a07cfe8a7</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><blockquote>
<p>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>
</blockquote>
<h3 id="安装：-1"><a href="#安装：-1" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 全局安装</span><br><span class="line">npm i -g pm2</span><br></pre></td></tr></table></figure>

<p>安装完成后会自动创建目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$HOME&#x2F;.pm2   will contain all PM2 related files</span><br><span class="line">$HOME&#x2F;.pm2&#x2F;logs   will contain all applications logs</span><br><span class="line">$HOME&#x2F;.pm2&#x2F;pids   will contain all applications pids</span><br><span class="line">$HOME&#x2F;.pm2&#x2F;pm2.log   PM2 logs</span><br><span class="line">$HOME&#x2F;.pm2&#x2F;pm2.pid   PM2 pid</span><br><span class="line">$HOME&#x2F;.pm2&#x2F;rpc.sock    Socket file for remote commands</span><br><span class="line">$HOME&#x2F;.pm2&#x2F;pub.sock  Socket file for publishable events</span><br><span class="line">$HOME&#x2F;.pm2&#x2F;conf.js     PM2 Configuration</span><br></pre></td></tr></table></figure>

<h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>参数说明：</p>
<ul>
<li><code>--watch</code>：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。</li>
<li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果<code>-i 0</code>或者<code>-i max</code>，则根据当前机器核数确定实例数目。</li>
<li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如<code>--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</code></li>
<li><code>-n --name</code>：应用的名称。查看应用信息的时候可以用到。</li>
<li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径。</li>
<li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径。</li>
<li><code>--interpreter &lt;interpreter&gt;</code>：the interpreter pm2 should use for executing app (bash, python…)。比如你用的coffee script来编写应用。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ npm install pm2 -g     # 命令行安装 pm2 </span><br><span class="line">$ pm2 start app.js -i 4  # 后台运行pm2，启动4个app.js </span><br><span class="line">                         # 也可以把&#x27;max&#x27; 参数传递给 start</span><br><span class="line">                         # 正确的进程数目依赖于Cpu的核心数目</span><br><span class="line">$ pm2 start app.js --name my-api # 命名进程</span><br><span class="line">$ pm2 list               # 显示所有进程状态</span><br><span class="line">$ pm2 monit              # 监视所有进程</span><br><span class="line">$ pm2 logs               # 显示所有进程日志</span><br><span class="line">$ pm2 stop all           # 停止所有进程</span><br><span class="line">$ pm2 restart all        # 重启所有进程</span><br><span class="line">$ pm2 reload all         # 0 秒停机重载进程 (用于 NETWORKED 进程)</span><br><span class="line">$ pm2 stop 0             # 停止指定的进程</span><br><span class="line">$ pm2 restart 0          # 重启指定的进程</span><br><span class="line">$ pm2 startup            # 产生 init 脚本 保持进程活着</span><br><span class="line">$ pm2 web                # 运行健壮的 computer API endpoint (http://localhost:9615)</span><br><span class="line">$ pm2 delete 0           # 杀死指定的进程</span><br><span class="line">$ pm2 delete all         # 杀死全部进程</span><br></pre></td></tr></table></figure>



<p>完整命令行参数列表：<a href="http://pm2.keymetrics.io/docs/usage/quick-start/#options">地址</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pm2 <span class="built_in">start</span> app.js -<span class="literal">-watch</span> <span class="literal">-i</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h5 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pm2 restart app.js</span><br></pre></td></tr></table></figure>

<h5 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h5><p>停止特定的应用。可以先通过<code>pm2 list</code>获取应用的名字（–name指定的）或者进程id。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pm2 stop app_name|app_id</span><br></pre></td></tr></table></figure>

<p>如果要停止所有应用，可以</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pm2 stop all</span><br></pre></td></tr></table></figure>

<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>类似<code>pm2 stop</code>，如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pm2 stop app_name|app_id</span><br><span class="line">pm2 stop all</span><br></pre></td></tr></table></figure>

<h5 id="查看进程状态"><a href="#查看进程状态" class="headerlink" title="查看进程状态"></a>查看进程状态</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pm2 list</span><br></pre></td></tr></table></figure>

<h5 id="查看某个进程的信息"><a href="#查看某个进程的信息" class="headerlink" title="查看某个进程的信息"></a>查看某个进程的信息</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ94wb7tioqZ</span> <span class="type">pids</span>]<span class="comment"># pm2 describe 0</span></span><br><span class="line">Describing <span class="keyword">process</span> with id <span class="number">0</span> - name oc<span class="literal">-server</span></span><br><span class="line">┌───────────────────┬──────────────────────────────────────────────────────────────┐</span><br><span class="line">│ status            │ online                                                       │</span><br><span class="line">│ name              │ oc<span class="literal">-server</span>                                                    │</span><br><span class="line">│ id                │ <span class="number">0</span>                                                            │</span><br><span class="line">│ path              │ /<span class="keyword">data</span>/file/qiquan/over_the_counter/server/bin/www            │</span><br><span class="line">│ args              │                                                              │</span><br><span class="line">│ exec cwd          │ /<span class="keyword">data</span>/file/qiquan/over_the_counter/server                    │</span><br><span class="line">│ error log path    │ /<span class="keyword">data</span>/file/qiquan/over_the_counter/server/logs/app<span class="literal">-err</span><span class="literal">-0</span>.log │</span><br><span class="line">│ out log path      │ /<span class="keyword">data</span>/file/qiquan/over_the_counter/server/logs/app<span class="literal">-out</span><span class="literal">-0</span>.log │</span><br><span class="line">│ pid path          │ /root/.pm2/pids/oc<span class="literal">-server</span><span class="literal">-0</span>.pid                              │</span><br><span class="line">│ mode              │ fork_mode                                                    │</span><br><span class="line">│ node v8 arguments │                                                              │</span><br><span class="line">│ watch &amp; reload    │                                                             │</span><br><span class="line">│ interpreter       │ node                                                         │</span><br><span class="line">│ restarts          │ <span class="number">293</span>                                                          │</span><br><span class="line">│ unstable restarts │ <span class="number">0</span>                                                            │</span><br><span class="line">│ uptime            │ <span class="number">87</span>m                                                          │</span><br><span class="line">│ created at        │ <span class="number">2016</span><span class="literal">-08</span><span class="literal">-26T08</span>:<span class="number">13</span>:<span class="number">43.705</span>Z                                     │</span><br><span class="line">└───────────────────┴──────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>



<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h4><ul>
<li>配置文件里的设置项，跟命令行参数基本是一一对应的。</li>
<li>可以选择<code>yaml</code>或者<code>json</code>文件，就看个人洗好了。</li>
<li><code>json</code>格式的配置文件，pm2当作普通的js文件来处理，所以可以在里面添加注释或者编写代码，这对于动态调整配置很有好处。</li>
<li>如果启动的时候指定了配置文件，那么命令行参数会被忽略。（个别参数除外，比如–env）</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>举个简单例子，完整配置说明请参考<a href="http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/">官方文档</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>        : <span class="string">&quot;fis-receiver&quot;</span>,  <span class="comment">// 应用名称</span></span><br><span class="line">  <span class="string">&quot;script&quot;</span>      : <span class="string">&quot;./bin/www&quot;</span>,  <span class="comment">// 实际启动脚本</span></span><br><span class="line">  <span class="string">&quot;cwd&quot;</span>         : <span class="string">&quot;./&quot;</span>,  <span class="comment">// 当前工作路径</span></span><br><span class="line">  <span class="string">&quot;watch&quot;</span>: [  <span class="comment">// 监控变化的目录，一旦变化，自动重启</span></span><br><span class="line">    <span class="string">&quot;bin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;routers&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;ignore_watch&quot;</span> : [  <span class="comment">// 从监控目录中排除</span></span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span>, </span><br><span class="line">    <span class="string">&quot;logs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;public&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;watch_options&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;followSymlinks&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;error_file&quot;</span> : <span class="string">&quot;./logs/app-err.log&quot;</span>,  <span class="comment">// 错误日志路径</span></span><br><span class="line">  <span class="string">&quot;out_file&quot;</span>   : <span class="string">&quot;./logs/app-out.log&quot;</span>,  <span class="comment">// 普通日志路径</span></span><br><span class="line">  <span class="string">&quot;log_date_format&quot;</span>: <span class="string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>, <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;NODE_ENV&quot;</span>: <span class="string">&quot;production&quot;</span>  <span class="comment">// 环境参数，当前指定为生产环境</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;instances&quot;</span>: <span class="number">4</span>,   <span class="comment">// 4核处理器，对应四个进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动的时候设置package.json：<code>&quot;prd&quot;:&quot;cross-env NODE_ENV=production pm2 start pm2.conf.json&quot;</code></p>
<h3 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h3><p>前面已经提到了，这里贴命令行，更多点击<a href="http://pm2.keymetrics.io/docs/usage/watch-and-restart/#auto-restart-apps-on-file-change">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --watch</span><br></pre></td></tr></table></figure>

<p>这里是监控整个项目的文件，如果只想监听指定文件和目录，建议通过配置文件的<code>watch</code>、<code>ignore_watch</code>字段来设置</p>
<h3 id="环境切换"><a href="#环境切换" class="headerlink" title="环境切换"></a>环境切换</h3><blockquote>
<p>在实际项目开发中，我们的应用经常需要在多个环境下部署，比如开发环境、测试环境、生产环境等。在不同环境下，有时候配置项会有差异，比如链接的数据库地址不同等。</p>
<p>对于这种场景，pm2也是可以很好支持的。首先通过在配置文件中通过<code>env_xx</code>来声明不同环境的配置，然后在启动应用时，通过<code>--env</code>参数指定运行的环境。</p>
</blockquote>
<h4 id="环境配置声明"><a href="#环境配置声明" class="headerlink" title="环境配置声明"></a>环境配置声明</h4><p>首先，在配置文件中，通过<code>env</code>选项声明多个环境配置。简单说明下：</p>
<ul>
<li><code>env</code>为默认的环境配置（生产环境），<code>env_dev</code>、<code>env_test</code>则分别是开发、测试环境。可以看到，不同环境下的<code>NODE_ENV</code>、<code>REMOTE_ADDR</code>字段的值是不同的。</li>
<li>在应用中，可以通过<code>process.env.REMOTE_ADDR</code>等来读取配置中声明的变量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;NODE_ENV&quot;</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="string">&quot;REMOTE_ADDR&quot;</span>: <span class="string">&quot;http://www.example.com/&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;env_dev&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;NODE_ENV&quot;</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="string">&quot;REMOTE_ADDR&quot;</span>: <span class="string">&quot;http://wdev.example.com/&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;env_test&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;NODE_ENV&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;REMOTE_ADDR&quot;</span>: <span class="string">&quot;http://wtest.example.com/&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动指明环境"><a href="#启动指明环境" class="headerlink" title="启动指明环境"></a>启动指明环境</h4><p>假设通过下面启动脚本（开发环境），那么，此时<code>process.env.REMOTE_ADDR</code>的值就是相应的 <a href="http://wdev.example.com/">http://wdev.example.com/</a> ，可以自己试验下。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pm2 <span class="built_in">start</span> app.js -<span class="literal">-env</span> dev</span><br></pre></td></tr></table></figure>

<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>命令如下，表示开启三个进程。如果<code>-i 0</code>，则会根据机器当前核数自动开启尽可能多的进程。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pm2 <span class="built_in">start</span> app.js <span class="literal">-i</span> <span class="number">3</span> <span class="comment"># 开启三个进程</span></span><br><span class="line">pm2 <span class="built_in">start</span> app.js <span class="literal">-i</span> max <span class="comment"># 根据机器CPU核数，开启对应数目的进程 </span></span><br></pre></td></tr></table></figure>

<p><strong>服务进程数</strong></p>
<p>至于要启动几个进程，可以通过服务器的内核数进行确定，几个内核就启动几个服务。指令如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看物理CPU个数</span></span><br><span class="line">cat /proc/cpuinfo<span class="params">| grep &quot;physical id&quot; |</span> sort<span class="params">| uniq |</span> wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个物理CPU中core的个数(即核数)</span></span><br><span class="line">cat /proc/cpuinfo<span class="params">| grep &quot;cpu cores&quot;|</span> uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看逻辑CPU的个数</span></span><br><span class="line">cat /proc/cpuinfo<span class="params">| grep &quot;processor&quot;|</span> wc -l</span><br></pre></td></tr></table></figure>



<p>作者：狐尼克朱迪<br>链接：<a href="https://www.jianshu.com/p/225b9284cfb8">https://www.jianshu.com/p/225b9284cfb8</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>参考文档：<a href="http://pm2.keymetrics.io/docs/usage/cluster-mode/#automatic-load-balancing">点击查看</a></p>
<h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p>除了可以打开日志文件查看日志外，还可以通过<code>pm2 logs</code>来查看实时日志。这点对于线上问题排查非常重要。</p>
<p>比如某个node服务突然异常重启了，那么可以通过pm2提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 logs</span><br></pre></td></tr></table></figure>

<h3 id="指令tab补全"><a href="#指令tab补全" class="headerlink" title="指令tab补全"></a>指令tab补全</h3><p>运行<code>pm2 --help</code>，可以看到<code>pm2</code>支持的子命令还是蛮多的，这个时候，自动完成的功能就很重要了。</p>
<p>运行如下命令。恭喜，已经能够通过tab自动补全了。细节可参考<a href="http://pm2.keymetrics.io/docs/usage/auto-completion/">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 completion install</span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>

<h3 id="开机自动启动"><a href="#开机自动启动" class="headerlink" title="开机自动启动"></a>开机自动启动</h3><p>可以通过<code>pm2 startup</code>来实现开机自启动。细节可<a href="http://pm2.keymetrics.io/docs/usage/startup/">参考</a>。大致流程如下</p>
<ol>
<li>通过<code>pm2 save</code>保存当前进程状态。</li>
<li>通过<code>pm2 startup [platform]</code>生成开机自启动的命令。（记得查看控制台输出）</li>
<li>将步骤2生成的命令，粘贴到控制台进行，搞定</li>
</ol>
<h3 id="监控-monitor"><a href="#监控-monitor" class="headerlink" title="监控(monitor)"></a>监控(monitor)</h3><p>运行如下命令，查看当前通过pm2运行的进程的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 monit</span><br></pre></td></tr></table></figure>

<p>看到类似输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@oneday-dev0 server]# pm2 monit</span><br><span class="line">⌬ PM2 monitoring (To go further check out https:&#x2F;&#x2F;app.keymetrics.io) </span><br><span class="line">                                       [                              ] 0 %</span><br><span class="line">⌬ PM2 monitoring (To go further check o[|||||||||||||||               ] 196.285 MB  </span><br><span class="line"></span><br><span class="line"> ● fis-receiver                        [                              ] 0 %</span><br><span class="line">[1] [fork_mode]                        [|||||                         ] 65.773 MB  </span><br><span class="line"></span><br><span class="line"> ● www                                 [                              ] 0 %</span><br><span class="line">[2] [fork_mode]                        [|||||                         ] 74.426 MB  </span><br><span class="line"></span><br><span class="line"> ● oc-server                           [                              ] 0 %</span><br><span class="line">[3] [fork_mode]                        [||||                          ] 57.801 MB  </span><br><span class="line"></span><br><span class="line"> ● pm2-http-interface                  [                              ] stopped</span><br><span class="line">[4] [fork_mode]                        [                              ] 0 B   </span><br><span class="line"></span><br><span class="line"> ● start-production</span><br><span class="line">[5] [fork_mode]</span><br></pre></td></tr></table></figure>

<h3 id="内存使用超过上限自动重启"><a href="#内存使用超过上限自动重启" class="headerlink" title="内存使用超过上限自动重启"></a>内存使用超过上限自动重启</h3><p>如果想要你的应用，在超过使用内存上限后自动重启，那么可以加上<code>--max-memory-restart</code>参数。（有对应的配置项）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pm2 <span class="built_in">start</span> big<span class="literal">-array</span>.js -<span class="literal">-max</span><span class="literal">-memory</span><span class="literal">-restart</span> <span class="number">20</span>M</span><br></pre></td></tr></table></figure>

<h3 id="更新pm2"><a href="#更新pm2" class="headerlink" title="更新pm2"></a>更新pm2</h3><p>官方文档：<a href="http://pm2.keymetrics.io/docs/usage/update-pm2/#updating-pm2">http://pm2.keymetrics.io/docs/usage/update-pm2/#updating-pm2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pm2 save # 记得保存进程状态</span><br><span class="line">$ npm install pm2 -g</span><br><span class="line">$ pm2 update</span><br></pre></td></tr></table></figure>

<h3 id="pm2-nginx"><a href="#pm2-nginx" class="headerlink" title="pm2 + nginx"></a>pm2 + nginx</h3><p>无非就是在nginx上做个反向代理配置，直接贴配置。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> my_nodejs_upstream &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:3001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> my_nodejs_server;</span><br><span class="line">    <span class="attribute">root</span> /home/www/project_root;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    	<span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    	<span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">    	<span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">    	<span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    	<span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    	<span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    	<span class="attribute">proxy_max_temp_file_size</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="attribute">proxy_pass</span> http://my_nodejs_upstream/;</span><br><span class="line">    	<span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">    	<span class="attribute">proxy_read_timeout</span> <span class="number">240s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><ol>
<li>nvm,nodejs版本管理工具，可切换多个nodejs版本</li>
<li>mac os ,使用brew install nvm</li>
<li>windows， 在GitHub中搜索nvm-windows,有下载地址</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nvm list   <span class="comment">// 查已安装nodejs版本</span></span><br><span class="line">nvm install v10<span class="number">.15</span><span class="number">.0</span>    <span class="comment">//安装nodejs v10.15.0版本</span></span><br><span class="line">nvm use --<span class="keyword">delete</span>-prefix 版本号</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul>
<li>web server 最常用的缓存数据库，数据库放在内存中</li>
<li>相比于mysql,访问速度快（内存的速度要远远高于硬盘的）</li>
<li>但是成本高，可存储的数据量更小（内存的硬伤）</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200613170655276.png" alt="image-20200613170655276"></p>
<blockquote>
<p>这里的redis好比数据库，就是将session,单独的存储在这里，解决了进程频繁访问，数据量增多给进程带来的问题，同时也解决了，多进程的问题，所有的进程都可以访问redis中的session</p>
</blockquote>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200613171409575.png" alt="image-20200613171409575"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200613171546347.png" alt="image-20200613171546347"></p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><ol>
<li><p>安装：<a href="https://www.runoob.com/redis/redis-install.html">https://www.runoob.com/redis/redis-install.html</a></p>
</li>
<li><p>打开一个 <strong>cmd</strong> 窗口 使用 cd 命令切换目录到 <strong>C:\redis</strong> 运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br><span class="line">// 或者</span><br><span class="line">redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>双击<code>redis-cli.exe</code></p>
</li>
<li><p>nodejs连接redis</p>
<ol>
<li>安装：<code>npm i redis</code></li>
<li>引入：<code>const redis = require(&#39;redis&#39;)</code></li>
<li>创建客户端：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> redisClient = redis.createClient(<span class="number">6379</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>)</span><br><span class="line">redisClient.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>,log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加</span></span><br><span class="line">redisClient.set(<span class="string">&#x27;myname&#x27;</span>,<span class="string">&#x27;zhangsan&#x27;</span>,redis.print)  <span class="comment">//redis.print将添加的展示出来</span></span><br><span class="line">redisClient.get(<span class="string">&#x27;myname&#x27;</span>,(err, <span class="function"><span class="params">val</span> =&gt;</span> &#123;    <span class="comment">// val就是获取的值</span></span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;val&#x27;</span>,val)</span><br><span class="line">    <span class="comment">//退出</span></span><br><span class="line">    redisClient.quit() </span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>redis</p>
<p><code>npm i redis connect-redis --save</code></p>
<p>redis与session的连接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">const</span> Sessions = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> RedisStore = <span class="built_in">require</span>(<span class="string">&#x27;connect-redis&#x27;</span>)(Sessions)</span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="keyword">const</span> redisClient = <span class="built_in">require</span>(<span class="string">&#x27;./db/redis&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> sessionStore = <span class="keyword">new</span> RedisStore(&#123;</span><br><span class="line">    client: redisClient</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 与session连接</span></span><br><span class="line">app.use(Sessions(&#123; <span class="comment">// 设置session</span></span><br><span class="line">    secret: <span class="string">&#x27;XwW2037.&#x27;</span>, <span class="comment">// 相当于密钥</span></span><br><span class="line">    cookie: &#123;</span><br><span class="line">        path: <span class="string">&#x27;/&#x27;</span>, <span class="comment">// 根目录</span></span><br><span class="line">        httpOnly: <span class="literal">true</span>, <span class="comment">// 前端无法访问</span></span><br><span class="line">        maxAge: <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> <span class="comment">// 失效时间</span></span><br><span class="line">    &#125;,</span><br><span class="line">    store: sessionStore   <span class="comment">// 连接</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>特点：占有内存少，并发能力强，他专为性能优化而开发。</p>
<ul>
<li>高性能的web服务器开源免费</li>
<li>一般用于做静态服务，负载均衡，动静分离</li>
<li>以及反向代理</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200614104017778.png" alt="image-20200614104017778"></p>
<ul>
<li>下载：<a href="https://www.cnblogs.com/chen1005/p/10520812.html">https://www.cnblogs.com/chen1005/p/10520812.html</a></li>
</ul>
<h4 id="1-正向代理"><a href="#1-正向代理" class="headerlink" title="1.正向代理"></a>1.正向代理</h4><blockquote>
<p>在浏览器中配置代理服务器，通过代理服务器访问局域网外的internet.</p>
</blockquote>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200817111232641.png" alt="image-20200817111232641"></p>
<h4 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2.反向代理"></a>2.反向代理</h4><blockquote>
<p>我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p>
</blockquote>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200817112247843.png" alt="image-20200817112247843"></p>
<h4 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3.负载均衡"></a>3.负载均衡</h4><blockquote>
<p>单个服务器解决不了多重并发访问，我们可以通过增加服务器的数量，然后将请求分发到多个服务器上，<strong>将原来的请求集中到单个服务器上的情况改为将请求分发到多个服务器上</strong>，将负载分发到不同的服务器，也就是我们所说的负载均衡。</p>
</blockquote>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200817113612376.png" alt="image-20200817113612376"></p>
<h4 id="4-动静分离"><a href="#4-动静分离" class="headerlink" title="4.动静分离"></a>4.动静分离</h4><blockquote>
<p>为了加快网页的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p>
</blockquote>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200817114558756.png" alt="image-20200817114558756"></p>
<ul>
<li>在 nginx.conf中做配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  4; &#x2F;&#x2F;本机处理器</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       8080;   &#x2F;&#x2F; 监听的服务器端口号</span><br><span class="line">        server_name  localhost;  &#x2F;&#x2F;服务器名称</span><br><span class="line">        &#x2F;&#x2F; 反向代理配置, 注意冒号问题</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">	        proxy_pass http:&#x2F;&#x2F;localhost:8001;</span><br><span class="line">	    &#125;</span><br><span class="line">	    location &#x2F;api &#123;</span><br><span class="line">	       proxy_pass http:&#x2F;&#x2F;localhost:8000;</span><br><span class="line">	       proxy_set_header Host $host;</span><br><span class="line">	     &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基本的命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// nginx命令：启动nginx</span><br><span class="line">C:/nginx-0.8.53&gt;nginx.exe  或者</span><br><span class="line">C:/nginx-0.8.53&gt;start nginx</span><br><span class="line"></span><br><span class="line">// nginx命令：停止nginx的命令主要有两种，即</span><br><span class="line">C:/nginx-0.8.53&gt;nginx -s stop  或者</span><br><span class="line">C:/nginx-0.8.53&gt;nginx -s quit</span><br><span class="line">// nginx停止命令stop与quit参数的区别在于stop是快速停止nginx，可能并不保存相关信息，quit是完整有序的停止nginx，并保存相关信息。</span><br><span class="line"></span><br><span class="line">// 重载nginx命令</span><br><span class="line">nginx -s reopen</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606110014073.png" alt="image-20200606110014073"></p>
]]></content>
      <tags>
        <tag>nodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript基础知识</title>
    <url>/2020/09/10/3JS/</url>
    <content><![CDATA[<h1 id="javascript基础"><a href="#javascript基础" class="headerlink" title="javascript基础"></a>javascript基础</h1><h2 id="JS概述"><a href="#JS概述" class="headerlink" title="JS概述"></a>JS概述</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><ol>
<li>验证表单（以前的网速慢）</li>
<li>页面特效（PC端的网页效果）<a id="more"></a></li>
<li>移动端（移动web和app）</li>
<li>异步和服务器交互（AJAX）</li>
<li>服务端开发（nodejs）</li>
</ol>
<h3 id="2-解析执行与编译执行"><a href="#2-解析执行与编译执行" class="headerlink" title="2.解析执行与编译执行"></a>2.解析执行与编译执行</h3><p>编译执行：把代码编译成CPU认识的语言(文件)，然后整体的执行。</p>
<p>解析执行：一行一行解析，解析一行执行一行。</p>
<h3 id="3-脚本调用策略"><a href="#3-脚本调用策略" class="headerlink" title="3.脚本调用策略"></a>3.脚本调用策略</h3><p>要让脚本调用的时机符合预期，需要解决一系列的问题。这里看似简单，实际大有文章。最常见的问题就是：HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">文档对象模型</a> DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。</p>
<p>上述的脚本阻塞问题实际有两种解决方案 —— <code>async</code> 和 <code>defer</code></p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>浏览器遇到 <code>async</code> 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，<code>async</code> 是最理想的选择。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>三者的调用顺序是不确定的。<code>jquery.js</code> 可能在 <code>script2</code> 和 <code>script3</code> 之前或之后调用，如果这样，后两个脚本中依赖 <code>jquery</code> 的函数将产生错误，因为脚本运行时 <code>jquery</code> 尚未加载。</p>
<p>解决这一问题可使用 <code>defer</code> 属性，脚本将按照在页面中出现的顺序加载和运行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/script3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加 <code>defer</code> 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 <code>jquery.js</code>必定加载于 <code>script2.js</code> 和 <code>script3.js</code> 之前，同时 <code>script2.js</code> 必定加载于 <code>script3.js</code>之前。</p>
<h4 id="脚本调用策略小结："><a href="#脚本调用策略小结：" class="headerlink" title="脚本调用策略小结："></a>脚本调用策略小结：</h4><ul>
<li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li>
<li>如果脚本无需等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li>
</ul>
<h3 id="4-js组成"><a href="#4-js组成" class="headerlink" title="4.js组成"></a>4.js组成</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS  &#x3D;  ECMAScript  +  DOM  +  BOM + 高级</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ECMAScript（前身为欧洲计算机制造商协会）</p>
<ul>
<li>JavaScript的语法规范</li>
</ul>
</li>
<li><p>DOM（Document Object Model 的简称）</p>
<ul>
<li>JavaScript操作网页上元素的API</li>
</ul>
</li>
<li><p>BOM（Browser Object Model 的简称）</p>
<ul>
<li>JavaScript操作浏览器部分功能的API</li>
</ul>
</li>
</ul>
<h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5.变量"></a>5.变量</h3><h4 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1.命名规则"></a>1.命名规则</h4><p>驼峰命名规则：getElementById/matherAndFather/aaaOrBbbAndCcc</p>
<p>遵从规则：</p>
<p>1.变量命名必须以字母或是下标符号”_”或者”$”为开头。</p>
<p>2.变量名长度不能超过255个字符。</p>
<p>3.变量名中不允许使用空格，首个字不能为数字。</p>
<p>4.不用使用脚本语言中保留的关键字及保留符号作为变量名。</p>
<p>5.变量名区分大小写。(javascript是区分大小写的语言)</p>
<p>6.汉语可以作为变量名。但是不建议使用！！！（low）</p>
<h4 id="2-定义变量"><a href="#2-定义变量" class="headerlink" title="2.定义变量"></a>2.定义变量</h4><ol>
<li>var es6之前用的定义变量</li>
<li>let  es6变量，let声明的变量只在它所在的代码块有效。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>let特性：<ul>
<li>不存在变量提升</li>
<li>暂时性死区</li>
<li>不允许重复声明</li>
<li>块级作用域</li>
</ul>
</li>
</ul>
<ol start="3">
<li>const  es6常量定义，声明一个只读的常量。一旦声明，常量的值就不能改变。</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1-数据类型划分"><a href="#1-数据类型划分" class="headerlink" title="1.数据类型划分"></a>1.数据类型划分</h3><ul>
<li>使用关键字typeof,  typeof name  或者  typeof(name)</li>
<li>typeof 运算符： 只能识别<strong>值类型</strong>的变量，对于引用类型的值，只能大概识别</li>
<li>值类型<ul>
<li>String（字符串）     Number（数字）  Boolean（布尔）    undefined（未定义）   null（空）</li>
</ul>
</li>
<li>引用类型<ul>
<li>Object、function、Array、Date、RegExp、Error</li>
</ul>
</li>
</ul>
<h3 id="2-值类型"><a href="#2-值类型" class="headerlink" title="2.值类型"></a>2.值类型</h3><h4 id="2-1-undefined"><a href="#2-1-undefined" class="headerlink" title="2.1.undefined"></a>2.1.undefined</h4><ol>
<li>定义：使用var声明变量但为初始化</li>
<li>区分空对象指针与尚未定义的变量：对未初始化的变量及未声明的变量使用typeof运算符均会返回undefined</li>
</ol>
<h4 id="2-2-null"><a href="#2-2-null" class="headerlink" title="2.2.null"></a>2.2.null</h4><ol>
<li>定义：逻辑上null表示一个空对象的指针，使用typeof检测时会返回object</li>
<li>undefined与null的关系<ul>
<li>undefined派生于null,因此在使用“==”进行比较时会返回true</li>
<li>没有必要将变量显示声明为undefined</li>
<li>声明空对象时应该将其赋值为null</li>
</ul>
</li>
</ol>
<h4 id="2-3-boolean"><a href="#2-3-boolean" class="headerlink" title="2.3.boolean"></a>2.3.boolean</h4><ol>
<li>true为真，false为假</li>
<li>使用Boolean()进行转换<ul>
<li>转换为true<ul>
<li>任何非空字符串</li>
<li>任何非零数值</li>
<li>任何非空对象</li>
</ul>
</li>
<li>转换为false<ul>
<li>空字符串</li>
<li>0以及NaN</li>
<li>null及undefined</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-4-字符串"><a href="#2-4-字符串" class="headerlink" title="2.4.字符串"></a>2.4.字符串</h4><ol>
<li><h5 id="定义方式：用引号时，可单可双，唯独不可一单一双。可用-length看有几个字符。"><a href="#定义方式：用引号时，可单可双，唯独不可一单一双。可用-length看有几个字符。" class="headerlink" title="定义方式：用引号时，可单可双，唯独不可一单一双。可用.length看有几个字符。"></a>定义方式：用引号时，可单可双，唯独不可一单一双。可用.length看有几个字符。</h5></li>
<li><h5 id="转译：无法输出的字符，使用转译字符输出，例如：-‘’-‘-等。"><a href="#转译：无法输出的字符，使用转译字符输出，例如：-‘’-‘-等。" class="headerlink" title="转译：无法输出的字符，使用转译字符输出，例如：/    ‘’     ‘      //等。"></a>转译：无法输出的字符，使用转译字符输出，例如：/    ‘’     ‘      //等。</h5></li>
<li><h5 id="字符串的连接，使用“-”字符连接，可以是字符变量"><a href="#字符串的连接，使用“-”字符连接，可以是字符变量" class="headerlink" title="字符串的连接，使用“+”字符连接，可以是字符变量"></a>字符串的连接，使用“+”字符连接，可以是字符变量</h5></li>
<li><h5 id="转换：toString"><a href="#转换：toString" class="headerlink" title="转换：toString()"></a>转换：toString()</h5></li>
<li><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li>string.length  获取字符串的长度</li>
<li>string[i]   检索值为i对应的特定字符串字符</li>
<li>string.indexOf(‘zilla’)     在字符串中查找子字符串并提取它,当在主字符串中找不到子字符串（在本例中为“vanilla”）时将返回 <code>-1</code>。</li>
<li>slice(0,3)    提取字符串中0到3位置的字符，如果只有一个值，表示从当前值的位置截取剩下的所有</li>
<li>toLowerCase()       字符串转换为小写</li>
<li>toUpperCase()        字符串转换为大写</li>
<li>replace(‘要被替换下的字符串’,’要被替换上的字符串’)    它不会自动更新子串的值，需要重新赋值一下</li>
</ul>
</li>
<li><h5 id="ES6提供的新方法"><a href="#ES6提供的新方法" class="headerlink" title="ES6提供的新方法"></a>ES6提供的新方法</h5><ol>
<li><code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。在作用上，正好与下面的<code>codePointAt()</code>方法相反。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>ES6 还为原生的 String 对象，提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span></span><br><span class="line"><span class="comment">// 实际返回 &quot;Hi\\n5!&quot;，显示的是转义后的结果 &quot;Hi\n5!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 实际返回 &quot;Hi\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\u000A!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要<code>4</code>个字节储存。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt()</code>方法无法读取整个字符，<code>charCodeAt()</code>方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span></span><br><span class="line">s.charCodeAt(<span class="number">2</span>).toString(<span class="number">16</span>)  <span class="comment">// &quot;61&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x61</span>)    <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>includes(), startsWith(), endsWith()确定一个字符串是否包含在另一个字符串中</p>
</li>
</ol>
<ul>
<li><p>**includes()**：返回布尔值，表示是否找到了参数字符串。</p>
</li>
<li><p>**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</li>
<li><p>**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
</blockquote>
<p>​          5. <code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>) <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.repeat(<span class="number">2</span>) <span class="comment">// &quot;hellohello&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">0</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">2.9</span>) <span class="comment">// &quot;nana&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="string">&#x27;3&#x27;</span>) <span class="comment">// &quot;nanana&quot;</span></span><br></pre></td></tr></table></figure>

<p>​         6. 字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p>
<p>​     <code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000001&quot;</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000012&quot;</span></span><br><span class="line"><span class="string">&#x27;123456&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000123456&quot;</span></span><br></pre></td></tr></table></figure>

<p>另一个用途是提示字符串格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-MM-12&quot;</span></span><br><span class="line"><span class="string">&#x27;09-12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-09-12&quot;</span></span><br></pre></td></tr></table></figure>

<p>​        7.  <a href="https://github.com/tc39/proposal-string-left-right-trim">ES2019</a> 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.trimStart() <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">f.trimLeft()  <span class="comment">//&quot;abc   &quot;</span></span><br><span class="line">s.trimEnd()   <span class="comment">// &quot;  abc&quot;</span></span><br><span class="line">f.trimRight() <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，<code>trimStart()</code>只消除头部的空格，保留尾部的空格。<code>trimEnd()</code>也是类似行为。除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p>
</blockquote>
<ol start="7">
<li><h5 id="字符串的遍历"><a href="#字符串的遍历" class="headerlink" title="字符串的遍历"></a>字符串的遍历</h5></li>
</ol>
<p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li><h5 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h5></li>
</ol>
<p><a href="https://github.com/tc39/proposal-well-formed-stringify">ES2019</a> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="comment">// &quot;&quot;\\uD834&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\uDF06\uD834&#x27;</span>) <span class="comment">// &quot;&quot;\\udf06\\ud834&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5></li>
</ol>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。如果不想要，使用<code>trim()</code>方法消除他</p>
</li>
<li><p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>
</li>
<li><p>可调用函数</p>
</li>
</ol>
</blockquote>
<p><strong>模板编译</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<code>&lt;%...%&gt;</code>放置 JavaScript 代码，使用<code>&lt;%= ... %&gt;</code>输出 JavaScript 表达式。</p>
<p><strong>标签模板</strong></p>
<ul>
<li>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能</li>
<li>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</li>
<li>如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数</li>
</ul>
<p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sender = <span class="string">&#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-5-Number"><a href="#2-5-Number" class="headerlink" title="2.5.Number"></a>2.5.Number</h4><ul>
<li><strong>整数</strong> 就是整数,例如 10, 400, 或者 -5.</li>
<li><strong>浮点数</strong> (浮点) 有小数点或小数位，例如 12.5，和 56.7786543。</li>
<li><strong>双精度</strong>双精度是一种特定类型的浮点数，它们具有比标准浮点数更高的精度（这意味着它们精确到更大的小数位数）。</li>
</ul>
<p>甚至有不同类型的数字系统！ 十进制是基数10（意味着它在每列使用0-9），但是我们也有这样的东西：</p>
<ul>
<li><p><strong>二进制</strong> — 计算机的最基础语言; 0s and 1s</p>
</li>
<li><p><strong>八进制</strong> — 基数8，每列使用0-7</p>
</li>
<li><p><strong>十六进制</strong> — 基数16，每列使用0-9，然后使用a-f。 在CSS中设置颜色时，可能会遇到这些数字。</p>
<p>数制转换：</p>
</li>
</ul>
<ol>
<li>Number()</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200623154300455.png" alt="image-20200623154300455"></p>
<ol start="2">
<li>parseInt()</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200623155743706.png" alt="image-20200623155743706"></p>
<ol start="3">
<li>parseFloat()</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200623162117442.png" alt="image-20200623162117442"></p>
<ol start="4">
<li>toFixed()　将一个数字转换为包含指定小数位数的字符串。</li>
<li>valueOf()　　　　返回一个Number对象的原始值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let num &#x3D; 2.13456;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; -2.13456;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; 0;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; 0&#x2F;0;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; &#39;ab&#39;;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">num &#x3D; &#39;12&#39;;</span><br><span class="line">console.log(num.valueOf());</span><br><span class="line">&gt; 2.13456</span><br><span class="line">&gt; -2.13456</span><br><span class="line">&gt; 0</span><br><span class="line">&gt; NaN</span><br><span class="line">&gt; &quot;ab&quot;</span><br><span class="line">&gt; &quot;12&quot;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>toLocaleString()　　将一个数字转换为本地数字格式的字符串。</li>
<li>toExponential()　　用于将数字转化为指数形式</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2.13456</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential());</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">num = <span class="number">2123.1345</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">&gt; <span class="string">&quot;2.13456e+0&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;2e+0&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;2.13e+0&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;2.13456000e+0&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;2.1231345e+3&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Number.isInteger()    判断是否是整数。返回true 或者 false</li>
<li>Number.isNaN()   判断一个数字是不是<code>NaN</code>。 返回true 或者 false</li>
<li><code>Number.isFinite()</code>用于判断一个数字是否是有限数字。返回true 或者 false</li>
<li>isSafeInteger()该方法用于判断一个数字是否是一个安全数，那么问题来了，啥叫安全数：一个数字可以表示为IEEE-754双精度数，即从<code>(253−1) (2^&#123;53&#125;-1)(2的53−1)到−(253−1) -(2^&#123;53&#125;-1)−(2的53 −1)</code>。</li>
</ol>
<p><strong>Math对象</strong></p>
<ul>
<li><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p>
</li>
<li><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回<code>+1</code>；</li>
<li>参数为负数，返回<code>-1</code>；</li>
<li>参数为 0，返回<code>0</code>；</li>
<li>参数为-0，返回<code>-0</code>;</li>
<li>其他值，返回<code>NaN</code>。</li>
</ul>
</li>
<li><p><code>Math.cbrt()</code>方法用于计算一个数的立方根。</p>
</li>
<li><p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p>
</li>
</ul>
<p><strong>NaN</strong></p>
<ol>
<li><p>NaN 非数值（Not a Number的简写）</p>
<ul>
<li>console.log(“abc”/18); //结果是NaN</li>
<li>undefined和任何数值计算为NaN;</li>
<li>NaN 与任何值都不相等，包括 NaN 本身</li>
</ul>
</li>
<li><pre><code>Number.isNaN`，你可以检测你传递的值是否为 *数字值* 并且是否等价于 `NaN
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. isNaN() :任何不能被转换为数值的值都会导致这个函数返回 true </span><br><span class="line"></span><br><span class="line">&gt; （isNaN译为是否符合一个标准，什么标准呢？不是一个数字的标	 准，如果符合了那么就不是一个数字，不符合就是一个数字）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">isNaN(NaN);&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">isNaN(“blue”); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">isNaN(123); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ol>
<h4 id="2-6-object"><a href="#2-6-object" class="headerlink" title="2.6.object()"></a>2.6.object()</h4><ol>
<li><p>定义:一组数据或者功能的集合</p>
</li>
<li><p>声明：var o = {}</p>
</li>
<li><p>属性与方法</p>
<ul>
<li>constructor 保存用于创建当前对象的函数</li>
<li>hasOwnProperty(propertyName)   检测给定属性值在当前对象实例中是否存在</li>
<li>isPrototypeOf(object)   检测传入的对象是否是另一个对象的原型</li>
<li>prototypeIsEnumerable(propertyName)    检测给定属性是否能用for-in语句枚举</li>
<li>toLocaleString()   返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString()   返回的对象的字符串的表示</li>
<li>valueOf()   返回对象的字符串、数值或者布尔值表示；通常与toString()的值相同</li>
<li>Object.seal()  功能将对象密封起来，<strong>返回密封后的对象</strong>，阻止添加新属性并将所有现有属性标记为不可配置（不可增加删除）。属性值可以改变。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal">MDN</a></li>
<li>Object.freeze() 方法可以<strong>冻结</strong>一个对象。不能对属性进行添加，修改，删除，此外，冻结一个对象后该对象的原型也不能被修改。  它仅 对对象进行 浅 冻结，意味着只有 对象中的 直接 属性被冻结 像案例中的 address，address 中的属性没有被冻结，仍然可以被修改。     <code>freeze()</code> 返回和传入的参数相同的对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">MDN</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	name: <span class="string">&quot;Lydia Hallie&quot;</span>,</span><br><span class="line">	address: &#123;</span><br><span class="line">		street: <span class="string">&quot;100 Main St&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(person);</span><br><span class="line">person.address.street = <span class="string">&quot;101 Main St&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>es6新增方法</p>
<ol>
<li><code>Object.is()</code>比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>Object.assign(target,source1,source2..)</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<p>2.如果该参数不是对象，则会先转成对象，然后返回。</p>
<p>3.只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。即浅拷贝。</p>
<p>4.用途：为对象添加属性和方法；合并多个对象；克隆对象；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  someMethod(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li><p>Object.getOwnPropertyDescriptors()</p>
<ul>
<li><p>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
</li>
<li><p>引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p>
</li>
<li><p><code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p>
</li>
</ul>
</li>
<li><p>__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</p>
<ul>
<li><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。<ul>
<li>正常操作他的时候，使用用<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</li>
</ul>
</li>
<li><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。<code>Object.setPrototypeOf(object, prototype)</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Object.getPrototypeOf()</code>读取一个对象的原型对象</li>
</ul>
</li>
<li><p>Object.keys()，Object.values()，Object.entries()</p>
<ul>
<li><code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</li>
<li><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</li>
<li><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对<strong>数组</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h4 id="2-7-Symbol"><a href="#2-7-Symbol" class="headerlink" title="2.7.Symbol"></a>2.7.Symbol</h4><ol>
<li>作用：保证每个属性的名字都是独一无二的</li>
<li>它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</li>
<li><code>Symbol</code>函数可以接受一个字符串作为参数</li>
<li>每个Symbol的值都是独一无二的，也就是说，不管是否有参数，参数是否相等 ，他们的值永远是<strong>不等的</strong></li>
<li>Symbol 值不能与其他类型的值进行运算，会报错。</li>
<li>Symbol 值可以显式转为字符串、布尔值，数值不能转换。</li>
<li>ES9：Symbol.prototype.description可以返回他的描述<code>const sym = Symbol(&#39;foo&#39;);sym.description // &quot;foo&quot;</code></li>
<li>Symbol 值作为对象属性名时，不能用点运算符。</li>
<li>使用Symbol值定义属性时，Symbol 值必须放在方括号之中</li>
<li>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</li>
<li><code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>

<ol start="12">
<li><code>Symbol.for(参数：要重用的名)</code>方法重新使用同一个Symbol的值，if参数不存在，会新建一个7</li>
<li>Symbol.keyFor()<code>方法返回一个已登记的 Symbol 类型值的</code>key，也就是可以再次使用的值</li>
</ol>
<h4 id="2-8数组"><a href="#2-8数组" class="headerlink" title="2.8数组"></a>2.8数组</h4><p>数组是一个包含了多个值的对象。数组对象可以存储在变量中，并且能用和其他任何类型的值完全相同的方式处理，区别在于我们可以单独访问列表中的每个值，并使用列表执行一些有用和高效的操作，如循环 - 它对数组中的每个元素都执行相同的操作。 </p>
<ol>
<li>，数组中的每个项目都是一个字符串，但请记住，您可以将任何类型的元素存储在数组中 - 字符串，数字，对象，另一个变量，甚至另一个数组。 您也可以混合和匹配项目类型 - 它们并不都是数字，字符串等。尝试下面这些：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sequence = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>];</span><br><span class="line"><span class="keyword">let</span> random = [<span class="string">&#x27;tree&#x27;</span>, <span class="number">795</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>数组提供的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myData = <span class="string">&#x27;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>slice()方法，是提取字符串的某个部分,返回的是被提取的某个部分。slice(start,end),对于数组对象来说，表示以start起,end结束的一段元素,</p>
</li>
<li><p>当只有start一个参数时,表示以start下标开始至结尾的元素,</p>
<ul>
<li>若start为负,则表示从尾部开始,</li>
<li>若start为0,则表示克隆一个数组（<strong>浅拷贝</strong>）</li>
</ul>
</li>
<li><p>splice()方法用于插入,删除或替换数组的元素,返回的是新的数组</p>
<ul>
<li>splice(start,deleteCount,[item1],[item2]),表示从start位置开始删除deleteCount个元素,并且可以在这个位置插入n个元素。</li>
</ul>
</li>
<li><p>当start,deleteCount均为0时,表示从前面开始插入元素,</p>
<ul>
<li>当只有start一个参数时,如果start为正，就是删除从start开始删除至最后一个元素,</li>
<li>如果start为负，就是从数组尾部开始删除元素</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>split(‘,’)     将数组中的每一项，按某个符号分割为字符串</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myArray &#x3D; myData.split(&#39;,&#39;);</span><br><span class="line">result:[&quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">- maArray.length,数组长度。maArray[0]  检索数组下标为0的值</span><br><span class="line">   - join(&#39;,&#39;)   将数组根据分隔符，转化为字符串</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p> let myNewString = myArray.join(‘,’);<br> result:”Manchester,London,Liverpool,Birmingham,Leeds,Carlisle”</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">   - 要在数组末尾添加或删除一个项目，我们可以使用 [&#96;push()&#96;](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Array&#x2F;push) 和 [&#96;pop()&#96;](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Array&#x2F;pop)。</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;js</span><br><span class="line">&#x2F;&#x2F;当方法调用完成时，将返回数组的新长度。 如果要将新数组长度存储在变量中</span><br><span class="line">   myArray.push(&#39;Cardiff&#39;);</span><br><span class="line">   result:[&quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;, &quot;push方法&quot;]</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;从数组中删除最后一个元素的话直接使用 pop() 就可以，将返回已删除的项目</span><br><span class="line">   myArray.pop();</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift"><code>unshift()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift"><code>shift()</code></a> 从功能上与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a> 完全相同，只是它们分别作用于数组的开始，而不是结尾。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将项目添加到第一个，返回数组的新长度</span></span><br><span class="line">myArray.unshift(<span class="string">&#x27;Edinburgh&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除其中的第一个 ，返回的也是删除项</span></span><br><span class="line"><span class="keyword">let</span> removedItem = myArray.shift();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>扩展运算符：是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">     </span><br></pre></td></tr></table></figure>

<p>console.log(…[1, 2, 3])<br>// 1 2 3</p>
<p>console.log(1, …[2, 3, 4], 5)<br>// 1 2 3 4 5</p>
<p>[…document.querySelectorAll(‘div’)]<br>// [<div>, <div>, <div>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"> 该运算符主要用于函数调用。</span><br><span class="line">   </span><br><span class="line"> &#96;&#96;&#96;javascript</span><br><span class="line"> function push(array, ...items) &#123;</span><br><span class="line">   array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>function add(x, y) {<br>  return x + y;<br>}</p>
<p>const numbers = [4, 38];<br>add(…numbers) // 42</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     </span><br><span class="line">   apply函数的取代</span><br><span class="line">     </span><br><span class="line">   &#96;&#96;&#96;javascript</span><br><span class="line">&#x2F;&#x2F; ES5 的写法</span><br><span class="line">   Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ES6 的写法</span><br><span class="line">   Math.max(...[14, 3, 77])</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 等同于</span><br><span class="line">   Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure>

<p>赋值数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure>

<p><strong>合并数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">   <span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">   <span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">   <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ES6 的合并数组</span></span><br><span class="line">   [...arr1, ...arr2, ...arr3]</span><br><span class="line">   <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p><strong>与解构赋值结合</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">   rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</span></span><br><span class="line">   <span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串</strong></p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>

<p><strong>实现了 Iterator 接口的对象</strong></p>
<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure>

<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">     length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// TypeError: Cannot spread non-iterable object.</span></span><br><span class="line">   <span class="keyword">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</p>
<p><strong>Map 和 Set 结构，Generator 函数</strong></p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line"> ]);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> [...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"> length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>

<p>   上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p>   <code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line">   <span class="built_in">Array</span>.of(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line">   <span class="built_in">Array</span>.of(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line">   <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<ul>
<li>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="built_in">this</span>.length)</span><br></pre></td></tr></table></figure>

<p>它接受三个参数。</p>
<ul>
<li><p>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</p>
</li>
<li><p>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</p>
</li>
<li><p>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</p>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<ul>
<li>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后<strong>返回该成员</strong>。如果没有符合条件的成员，则返回<code>undefined</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">   &#125;) <span class="comment">// 10</span></span><br><span class="line">   <span class="comment">// value当前的值</span></span><br><span class="line">   <span class="comment">// index当前的位置</span></span><br><span class="line">   <span class="comment">// arr原数组 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<blockquote>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].find(f, person);</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><ul>
<li>fill方法使用给定值，填充一个数组</li>
</ul>
<p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<ul>
<li><p>对于前端项目开发过程中偶尔会出现层叠数据结构的数组，我们需要将多层级数组转换为一级数组（即：提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。</p>
</li>
<li><pre><code class="text">语法：let newArray = arr.flat(depth)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - **depth （可选参数）指定要提取嵌套数组的结构深度，默认值为 1。**</span><br><span class="line"></span><br><span class="line">## 面向对象</span><br><span class="line"></span><br><span class="line">### 1.定义</span><br><span class="line"></span><br><span class="line">1. OOP 的基本思想是：在程序里，我们通过使用对象去构建现实世界的模型，并对象把原本很难（或不可）能被使用的功能，简单化并提供出来，以供访问。</span><br><span class="line">2. 对象可以包含相关的数据和代码，这些数据和代码用于表示 你所建造的模型是什么样子，以及拥有什么样的行为或功能。对象包（object package，或者叫命名空间 namespace）存储（官方用语：**封装**）着对象的数据（常常还包括函数），使数据的组织和访问变得更容易了；对象也常用作 数据存储体（data stores），用于在网络上运输数据，十分便捷。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20200625111920033](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200625111920033.png)</span><br><span class="line"></span><br><span class="line">### 2.特性：</span><br><span class="line"></span><br><span class="line">1. 封装性</span><br><span class="line">2. 多元化</span><br><span class="line">3. 继承性</span><br><span class="line"></span><br><span class="line">### 3.创建方式</span><br><span class="line"></span><br><span class="line">1. 创建一个对象</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name : [&#39;Bob&#39;, &#39;Smith&#39;],</span><br><span class="line">  age : 32,</span><br><span class="line">  gender : &#39;male&#39;,</span><br><span class="line">  interests : [&#39;music&#39;, &#39;skiing&#39;],</span><br><span class="line">  bio : function() &#123;</span><br><span class="line">    alert(this.name[0] + &#39; &#39; + this.name[1] + &#39; is &#39; + this.age + &#39; years old. He likes &#39; + this.interests[0] + &#39; and &#39; + this.interests[1] + &#39;.&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting: function() &#123;</span><br><span class="line">    alert(&#39;Hi! I\&#39;m &#39; + this.name[0] + &#39;.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>JavaScript 用一种称为<strong>构建函数</strong>的特殊函数来定义对象和它们的特征。<strong>构建函数</strong>提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = &#123;</span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: first,</span><br><span class="line">    <span class="string">&#x27;last&#x27;</span>: last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.gender = gender;</span><br><span class="line">  <span class="built_in">this</span>.interests = interests;</span><br><span class="line">  <span class="built_in">this</span>.bio = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name.first + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.name.last + <span class="string">&#x27; is &#x27;</span> + <span class="built_in">this</span>.age + <span class="string">&#x27; years old. He likes &#x27;</span> + <span class="built_in">this</span>.interests[<span class="number">0</span>] + <span class="string">&#x27; and &#x27;</span> + <span class="built_in">this</span>.interests[<span class="number">1</span>] + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="built_in">this</span>.name.first + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;male&#x27;</span>, [<span class="string">&#x27;music&#x27;</span>, <span class="string">&#x27;skiing&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>首先, 您能使用<code>Object()</code>构造函数来创建一个新对象。 是的， 一般对象都有构造函数，它创建了一个空的对象。</p>
<ol>
<li><p>尝试在您浏览器中的Javascript控制台中输入以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样就在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person1</span><br></pre></td></tr></table></figure>

<p>变量中存储了一个空对象。然后, 可以根据需要, 使用点或括号表示法向此对象添加属性和方法；试试这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person1.name = <span class="string">&#x27;Chris&#x27;</span>;</span><br><span class="line">person1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">38</span>;</span><br><span class="line">person1.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以将对象文本传递给Object() 构造函数作为参数， 以便用属性/方法填充它。请尝试以下操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">  name : <span class="string">&#x27;Chris&#x27;</span>,</span><br><span class="line">  age : <span class="number">38</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>JavaScript有个内嵌的方法create(), 它允许您基于现有对象创建新的对象。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1);</span><br><span class="line">person2.name</span><br><span class="line">person2.greeting()</span><br></pre></td></tr></table></figure>



<h3 id="4-对象的表示方式"><a href="#4-对象的表示方式" class="headerlink" title="4.对象的表示方式"></a>4.对象的表示方式</h3><ol>
<li>点表示法：使用了点表示法(dot notation)来访问对象的属性和方法。对象的名字表现为一个命名空间(namespace)，它必须写在第一位——当你想访问对象内部的属性或方法时，然后是一个点(.)，紧接着是你想要访问的项目，标识可以是简单属性的名字(name)，或者是数组属性的一个子元素，又或者是对象的方法调用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.age</span><br><span class="line">person.interests[<span class="number">1</span>]</span><br><span class="line">person.bio()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>括号表示法：这看起来很像访问一个数组的元素，从根本上来说是一回事儿，你使用了关联了值的名字，而不是索引去选择元素。难怪对象有时被称之为关联数组(associative array)了——对象做了字符串到值的映射，而数组做的是数字到值的映射。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.age</span><br><span class="line">person.name.first</span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line">person[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">person[<span class="string">&#x27;name&#x27;</span>][<span class="string">&#x27;first&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="5-设置新建对象成员"><a href="#5-设置新建对象成员" class="headerlink" title="5.设置新建对象成员"></a>5.设置新建对象成员</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.age = <span class="number">45</span></span><br><span class="line">person[<span class="string">&#x27;name&#x27;</span>][<span class="string">&#x27;last&#x27;</span>] = <span class="string">&#x27;Cratchit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置成员并不意味着你只能更新已经存在的属性的值，你完全可以创建新的成员，如下：</span></span><br><span class="line">person[<span class="string">&#x27;eyes&#x27;</span>] = <span class="string">&#x27;hazel&#x27;</span></span><br><span class="line">person.farewell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">&quot;Bye everybody!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-this的含义"><a href="#6-this的含义" class="headerlink" title="6.this的含义"></a>6.<code>this</code>的含义</h3><p>1.指向：关键字”this”指向了当前代码运行时的对象( 原文：the current object the code is being written inside )——这里即指person对象</p>
<p>2.”this”是非常有用的——它保证了当代码的上下文(context)改变时变量的值的正确性（比如：不同的person对象拥有不同的name这个属性，很明显greeting这个方法需要使用的是它们自己的name）。</p>
<h3 id="7-constructor属性"><a href="#7-constructor属性" class="headerlink" title="7.constructor属性"></a>7.constructor属性</h3><p>每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。</p>
<ol>
<li>可以在 <code>constructor</code> 属性的末尾添加一对圆括号（括号中包含所需的参数），从而用这个构造器创建另一个对象实例。毕竟构造器是一个函数，故可以通过圆括号调用；只需在前面添加 <code>new</code> 关键字，便能将此函数作为构造器使用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person3 = <span class="keyword">new</span> person1.constructor(<span class="string">&#x27;Karen&#x27;</span>, <span class="string">&#x27;Stephenson&#x27;</span>, <span class="number">26</span>, <span class="string">&#x27;female&#x27;</span>, [<span class="string">&#x27;playing drums&#x27;</span>, <span class="string">&#x27;mountain climbing&#x27;</span>]);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>获得某个对象实例的构造器的名字</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instanceName.constructor.name</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改构造器的原型</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性与方法定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tammi&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;neutral&#x27;</span>, [<span class="string">&#x27;music&#x27;</span>, <span class="string">&#x27;skiing&#x27;</span>, <span class="string">&#x27;kickboxing&#x27;</span>]);</span><br><span class="line">Person.prototype.farewell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name.first + <span class="string">&#x27; has left the building. Bye for now!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 <code>farewell()</code> 方法<em>仍然</em>可用于 <code>person1</code> 对象实例——旧有对象实例的可用功能被自动更新了。这证明了先前描述的原型链模型。</p>
<ul>
<li>这种继承模型下，上游对象的方法不会复制到下游的对象实例中；</li>
<li>下游对象本身虽然没有定义这些方法，但浏览器会通过上溯原型链、从上游对象中找到它们。</li>
</ul>
<blockquote>
<p>一般在构造器（函数体）中定义属性，在prototype属性上定义方法。使得代码更具有可读性。</p>
</blockquote>
<h3 id="8-原型的继承"><a href="#8-原型的继承" class="headerlink" title="8.原型的继承"></a>8.原型的继承</h3><ol>
<li>定义：继承的对象函数并不是通过复制而来，而是通过原型链继承。</li>
<li>继承：使用<code>call(this,参数1,参数2,...)</code>函数。改变<code>this</code>指向，以重新指定您调用的函数里所有“<code>this</code>”指向的对象。</li>
</ol>
<blockquote>
<p>如果继承的构造函数,不从传入的参数中获取其属性值，则不需要在<code>call()</code>中为其指定其他参数,只需指明<code>this</code>。</p>
</blockquote>
<ol start="3">
<li>每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性。</li>
<li><code>prototype</code>本身就是定义在<code>Function</code>对象下的属性</li>
<li>当我们输入类似<code>var person1=new Person(...)</code>来构造对象时，JavaScript实际上参考的是<code>Person.prototype</code>指向的对象来生成<code>person1</code>。</li>
<li>Person===Person.prototype.constructor</li>
</ol>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ol>
<li>JSON 是用于将结构化数据表示为JavaScript对象的标准格式，通常用于在网站上表示和传输数据。</li>
<li>认识：是一种按照JavaScript对象语法的数据格式；是基于 JavaScript 语法，但它独立于JavaScript。</li>
<li>JSON可以作为一个对象或者字符串存在，使用对象用于解读 JSON 中的数据，使用字符串用于通过网络传输 JSON 数据</li>
<li>JSON还是一种数组，因为数组对象也是一种合法的 JSON 对象。</li>
<li>一个 JSON 对象可以被储存在它自己的文件中，这基本上就是一个文本文件，扩展名为 <code>.json</code></li>
<li>JSON结构： JSON 数据——&gt;字符串，数字，数组，布尔还有其它的字面值对象。这允许您构造出一个对象树。</li>
</ol>
<blockquote>
<ul>
<li>JSON 是一种纯数据格式，它只包含属性，没有方法。</li>
<li>JSON 要求有两头的 { } 来使其合法。最安全的写法是有两边的括号，而不是一边。</li>
<li>在 JSON 中，只有字符串才能用作属性。</li>
<li>甚至一个错位的逗号或分号就可以导致  JSON 文件出错</li>
</ul>
</blockquote>
<ol start="7">
<li>请求加载<code>JSON</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requestURL = <span class="string">&#x27;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> request = XMLHttpRequest();</span><br><span class="line"><span class="comment">//请求</span></span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, requestURL);</span><br><span class="line"><span class="comment">//responseType 为 JSON，让服务器将知道我们想要返回一个 JSON 对象，然后发送请求</span></span><br><span class="line">request.responseType = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line">request.send();</span><br><span class="line"><span class="comment">//响应来自服务器返回的数据</span></span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> superHeroes = request.response;</span><br><span class="line">  <span class="keyword">var</span> superHeroes = <span class="built_in">JSON</span>.parse(superHeroesText);</span><br><span class="line">  populateHeader(superHeroes);</span><br><span class="line">  showHeroes(superHeroes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>对象和文本间的转换</li>
</ol>
<ul>
<li><code>parse()</code>: 以文本字符串形式接受JSON对象作为参数，并返回相应的对象。。</li>
<li><code>stringify()</code>: 接收一个对象作为参数，返回一个对应的JSON字符串。</li>
</ul>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h3><ol>
<li><p>何为异步：通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的<strong>结果</strong>，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕.</p>
</li>
<li><p>定义：在程序解析运行的时候，在做一件事的同时，还能做别的事，比如，你排队买饭的时候可以刷微博等等。同步是需要等待的，存在堵塞的情况。</p>
</li>
<li><p>何时需要异步</p>
</li>
</ol>
<ul>
<li>在可能发生等待的情况</li>
<li>等待过程中不能像alert一样阻塞程序运行</li>
<li>因此，所有的”等待的情况”都需要异步</li>
</ul>
<ol start="4">
<li>前端使用异步的场景</li>
</ol>
<ul>
<li>定时任务：<code>setTimeout</code>,<code>setInverval</code></li>
<li>网络请求：<code>ajax</code>请求，动态<img>加载</li>
<li>事件绑定</li>
</ul>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><ol>
<li>定义：在执行代码的时候，一个单线程一次只能干一件事情。</li>
<li>JavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（<strong>main thread</strong>）。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Task A --&gt; Task B --&gt; Task C</span><br></pre></td></tr></table></figure>


<pre><code>    &lt;script&gt;
        console.log(100)
            // 异步：在可能发生等待的情况
        setTimeout(function() &#123;
            console.log(200)
        &#125;)
    // alert(200) //同步有堵塞
    console.log(300)</code></pre>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200530195614893.png" alt="image-20200530195614893"></p>
<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><h4 id="callbacks回调函数"><a href="#callbacks回调函数" class="headerlink" title="callbacks回调函数"></a>callbacks回调函数</h4><p>当我们把回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去——回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAsset</span>(<span class="params">url, type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.responseType = type;</span><br><span class="line"></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayImage</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadAsset(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>, displayImage);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行过程：创建 <code>displayImage()</code> 函数，简单的把blob传递给它，生成objectURL，然后再生成一个image元素，把objectURL作为image的源地址，最后显示这张图片。 然后，我们创建 <code>loadAsset()</code>函数，把URL，type，和回调函数同时都作为参数</p>
</blockquote>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promises 是新派的异步代码，现代的web APIs经常用到。 <code>fetch()</code> API就是一个很好的例子, 它基本上就是一个现代版的，更高效的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;products.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  products = json;</span><br><span class="line">  initialize();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Fetch problem: &#x27;</span> + err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a><strong>过程解析</strong></h5><ul>
<li>两个 <code>then()</code> 块。两者都包含一个回调函数，如果前一个操作成功，该函数将运行，并且每个回调都接收前一个成功操作的结果作为输入，因此您可以继续对它执行其他操作。每个 <code>.then()</code>块返回另一个promise，这意味着可以将多个<code>.then()</code>块链接到另一个块上，这样就可以依次执行多个异步操作。</li>
<li>如果其中任何一个<code>then()</code>块失败，则在末尾运行<code>catch()</code>块——与同步<code>try...catch</code>类似，<code>catch()</code>提供了一个错误对象，可用来报告发生的错误类型。但是请注意，同步<code>try...catch</code>不能与promise一起工作，尽管它可以与<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await">async/await</a>一起工作。</li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol>
<li>创建promise时，它既不是成功也不是失败状态。这个状态叫作<strong>pending</strong>（待定）。</li>
<li>当promise返回时，称为 resolved（已解决）.<ol>
<li>一个成功<strong>resolved</strong>的promise称为<strong>fullfilled</strong>（<strong>实现</strong>）。它返回一个值，可以通过将<code>.then()</code>块链接到promise链的末尾来访问该值。<code> .then()</code>块中的执行程序函数将包含promise的返回值。</li>
<li>一个不成功<strong>resolved</strong>的promise被称为<strong>rejected</strong>（<strong>拒绝</strong>）了。它返回一个原因（<strong>reason</strong>），一条错误消息，说明为什么拒绝promise。可以通过将<code>.catch()</code>块链接到promise链的末尾来访问此原因。</li>
</ol>
</li>
</ol>
<h5 id="then"><a href="#then" class="headerlink" title="then"></a>then</h5><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数,</p>
<ul>
<li>参数一：<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，</li>
<li>参数二：第二个参数（可选）是<code>rejected</code>状态的回调函数。</li>
<li>返回值：<code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</li>
</ul>
<h5 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h5><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的<strong>回调函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;/posts.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;/post/1.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>
</blockquote>
<p>Promise 内部的错误不会影响到 Promise 外部的代码。浏览器不会检测到。不过Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.on(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h5 id="all"><a href="#all" class="headerlink" title="all"></a>all</h5><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all()</a>静态方法完成此操作。这将一个promises数组作为输入参数，并返回一个新的Promise对象，只有当数组中的所有promise都满足时才会满足</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([a, b, c]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果它们都实现，那么链接的.then()块的执行器函数将被传递一个包含所有这些结果作为参数的数组。如果传递给Promise.all()的任何一个promise被拒绝，整个块将拒绝。</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个返回promise的函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchAndDecode</span>(<span class="params">url, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;blob&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.blob();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.text();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将返回的promises存储在变量中</span></span><br><span class="line"><span class="keyword">let</span> coffee = fetchAndDecode(<span class="string">&#x27;coffee.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tea = fetchAndDecode(<span class="string">&#x27;tea.jpg&#x27;</span>, <span class="string">&#x27;blob&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> description = fetchAndDecode(<span class="string">&#x27;description.txt&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise.all()代码块</span></span><br><span class="line"><span class="built_in">Promise</span>.all([coffee, tea, description]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(values);</span><br><span class="line">    <span class="keyword">let</span> objectURL1 = URL.createObjectURL(values[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> objectURL2 = URL.createObjectURL(values[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> descText = values[<span class="number">2</span>];</span><br><span class="line">	<span class="comment">// Display the images in &lt;img&gt; elements</span></span><br><span class="line">    <span class="keyword">let</span> image1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> image2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    image1.src = objectURL1;</span><br><span class="line">    image2.src = objectURL2;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image1);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image2);</span><br><span class="line">    <span class="comment">// Display the text in a paragraph</span></span><br><span class="line">    <span class="keyword">let</span> para = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    para.textContent = descText;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(para);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
</blockquote>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<ul>
<li><code>finally</code>方法的回调函数不接受任何参数</li>
<li><code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li>
<li><code>finally</code>本质上是<code>then</code>方法的特例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>例子：服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>

<p>在最近的现代浏览器中，<code>.finally()</code> 方法可用，它可以链接到常规promise链的末尾，允许您减少代码重复并更优雅地执行操作。上面的代码现在可以写成如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  doSomething(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  returnError(e);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  runFinalCode();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="race"><a href="#race" class="headerlink" title="race"></a>race</h5><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">&#x27;/resource-that-may-take-a-while&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;request timeout&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<h5 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h5><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  fetch(<span class="string">&#x27;/api-1&#x27;</span>),</span><br><span class="line">  fetch(<span class="string">&#x27;/api-2&#x27;</span>),</span><br><span class="line">  fetch(<span class="string">&#x27;/api-3&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line">removeLoadingIndicator();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p>
</blockquote>
<ul>
<li>该方法返回的新的 Promise 实例</li>
<li>一旦结束，状态总是<code>fulfilled</code></li>
<li>状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断所有异步操作是否都结束</li>
</ul>
<h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><code>Promise.resolve</code>方法的参数分成四种情况</p>
<ul>
<li><p>参数是一个 Promise 实例</p>
<ul>
<li>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</li>
</ul>
</li>
<li><p>参数是一个thenable对象</p>
<ul>
<li><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p>
</li>
</ul>
</li>
<li><p><strong>参数不是具有<code>then</code>方法的对象，或根本就不是对象</strong></p>
<ul>
<li><p>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>不带有任何参数</strong></p>
<ul>
<li><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</li>
<li>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</li>
</ul>
</li>
</ul>
<h5 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h5><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<h5 id="构建自定义promise"><a href="#构建自定义promise" class="headerlink" title="构建自定义promise"></a>构建自定义promise</h5><p>可以使用<code>Promise()</code> 构造函数构建自己的promise。您希望这样做的主要情况是，当您获得基于非基于promise的旧式异步API的代码时，您希望实现这一点。当您需要使用现有的旧项目代码，库或框架以及基于现代promise的代码时，这会派上用场。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用promise包装一个setTimeout()调用 - 这会在两秒后运行一个函数</span></span><br><span class="line"><span class="keyword">let</span> timeoutPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  resolve()和reject()是您调用以实现或拒绝新创建的promise的函数。</span></span><br></pre></td></tr></table></figure>

<p>调用此promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">timeoutPromise</span><br><span class="line">.then(<span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">   alert(message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>拒绝一个自定义promise</p>
<p>我们可以创建一个<code>reject()</code> 方法拒绝promise - 就像<code>resolve()</code>一样，这需要一个值，但在这种情况下，它是拒绝的原因，即将传递给<code>.catch()</code>的错误块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">message, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (message === <span class="string">&#x27;&#x27;</span> || <span class="keyword">typeof</span> message !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      reject(<span class="string">&#x27;Message is empty or not a string&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval &lt; <span class="number">0</span> || <span class="keyword">typeof</span> interval !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      reject(<span class="string">&#x27;Interval is negative or not a number&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(message);</span><br><span class="line">      &#125;, interval);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">timeoutPromise(<span class="string">&#x27;Hello there!&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line">.then(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">   alert(message);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span> + e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h4><p>像promise这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。</p>
<h4 id="Promise与callback对比"><a href="#Promise与callback对比" class="headerlink" title="Promise与callback对比"></a>Promise与callback对比</h4><p>promises与旧式callbacks有一些相似之处。它们本质上是一个返回的对象，您可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。</p>
<p>而，<code>Promise</code>是专门为异步操作而设计的，与旧式回调相比具有许多优点:</p>
<ul>
<li>您可以使用多个then()操作将多个异步操作链接在一起，并将其中一个操作的结果作为输入传递给下一个操作。这种链接方式对回调来说要难得多，会使回调以混乱的“末日金字塔”告终。 (也称为<a href="http://callbackhell.com/">回调地狱</a>)。</li>
<li><code>Promise</code>总是严格按照它们放置在事件队列中的顺序调用。</li>
<li>错误处理要好得多——所有的错误都由块末尾的一个.catch()块处理，而不是在“金字塔”的每一层单独处理。</li>
</ul>
<h3 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h3><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h4><ol>
<li><p>定义：在指定的时间后执行一段代码.</p>
</li>
<li><p>参数：<code>let myGreeting = setTimeout(val1, val2, val3);</code></p>
<ul>
<li>val1 要运行的函数，或者函数引用。</li>
<li>val2 表示在执行代码之前等待的时间间隔（以毫秒为单位，1000ms = 1s）的数字。如果指定值为0，函数会在主线程序完成后，立即运行。</li>
<li>val3 更多的参数：在指定函数运行时，希望传递给函数的值.</li>
</ul>
</li>
<li><p>val1 函数的命名，可以是匿名函数，也可以是具名函数（可以引用，响应）。</p>
</li>
<li><p>返回值：返回一个<strong>标志符</strong>变量用来引用这个间隔，可以稍后用来取消这个超时任务。</p>
</li>
<li><p>清除超时：调用<code>clearTimeout()</code>，将<code>setTimeout()</code>调用的<strong>标识符</strong>作为参数传递给它，从而在超时运行之前取消。或要取消上面的超时</p>
</li>
</ol>
<h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h4><ol>
<li>定义：以固定的时间间隔，重复运行一段代码.</li>
<li>返回值：返回一个确定的值，稍后你可以用它来取消间隔任务。</li>
<li>清除: 将返回值作为参数传递给<code>clearInterval</code>()</li>
<li>参数同setTimeout一样。</li>
</ol>
<h4 id="setTimeout-和-setInterval-注意点"><a href="#setTimeout-和-setInterval-注意点" class="headerlink" title="setTimeout() 和 setInterval() 注意点"></a>setTimeout() 和 setInterval() 注意点</h4><ol>
<li>递归的setTimeout也可以用它来重复运行相同的代码。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用setInterval()</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>递归setTimeout()和setInterval()有何不同</li>
</ol>
<ul>
<li>递归 setTimeout() 保证执行之间的延迟相同</li>
<li>使用 <code>setInterval()</code> 的示例有些不同。 我们选择的<strong>间隔包括执行我们想要运行的代码所花费的时间</strong>。假设为100毫秒，代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒</li>
<li>当递归使用 <code>setTimeout()</code> 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。</li>
</ul>
<ol start="3">
<li><p>立即超时</p>
<p>使用0用作setTimeout()的回调函数会立刻执行，但是在主线程代码运行之后执行。</p>
</li>
</ol>
<h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame()</a></h4><ol>
<li>定义：setInterval()的现代版本;在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在适当的帧率下运行，而不管它在什么环境中运行.</li>
<li>它是针对<code>setInterval()</code> 遇到的问题创建的，比如 <code>setInterval()</code>并不是针对设备优化的帧率运行，有时会丢帧。还有即使该选项卡不是活动的选项卡或动画滚出页面等问题 </li>
<li>函数参数：该方法将重新加载页面之前要调用的回调函数作为参数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// Drawing code goes here</span></span><br><span class="line">   requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>应用：定义一个函数，在其中更新动画 (例如，移动精灵，更新乐谱，刷新数据等)，然后调用它来开始这个过程。在函数的末尾，以 <code>requestAnimationFrame()</code> 传递的函数作为参数进行调用，这指示浏览器在下一次显示重新绘制时再次调用该函数。然后这个操作连续运行， 因为<code>requestAnimationFrame()</code> 是递归调用的。</li>
<li>时间戳：传递给 <code>requestAnimationFrame()</code> 函数的实际回调也可以被赋予一个参数（一个时间戳值），表示自 <code>requestAnimationFrame()</code> 开始运行以来的时间。这是很有用的，因为它允许您在特定的时间以恒定的速度运行，而不管您的设备有多快或多慢。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!startTime) &#123;</span><br><span class="line">         startTime = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        rotateCount = (timestamp - startTime) / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// If rotateCount gets over 359, set it to &#x27;remainder of dividing by 360&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(rotateCount &gt; <span class="number">359</span>) &#123;</span><br><span class="line">          rotateCount %= <span class="number">360</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set the rotation of the div to be equal to rotateCount degrees</span></span><br><span class="line">        spinner.style.transform = <span class="string">&#x27;rotate(&#x27;</span> + rotateCount + <span class="string">&#x27;deg)&#x27;</span>;</span><br><span class="line">        <span class="comment">// Call the next frame in the animation</span></span><br><span class="line">        rAF = requestAnimationFrame(draw);</span><br><span class="line">      &#125;</span><br><span class="line">      draw();</span><br></pre></td></tr></table></figure>

<h3 id="async-await的基本要素"><a href="#async-await的基本要素" class="headerlink" title="async/await的基本要素"></a>async/await的基本要素</h3><ol>
<li>认识：它是promises的语法糖，使得异步代码更易于编写和后续阅读。它们使异步代码看起来更像是旧式同步代码。</li>
<li>async关键词：使用<code>async</code>关键字，您可以将它放在函数声明之前，将其转换为<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async function</a>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br><span class="line"><span class="comment">// 调用该函数会返回一个promise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异步函数表达式</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line">hello();</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> () =&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 要实际使用promise实现时返回的值，因为它返回了一个promise，我们可以使用.then()块</span></span><br><span class="line">hello().then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>await关键词：与async关键词联合使用，放在任何基于异步声明的函数之前</p>
<p>作用：暂停代码在该行上执行，直到promise完成，然后返回结果值。与此同时，其他正在等待执行机会的代码就有可能如愿执行了。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> greeting = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hello().then(alert);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>示例：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch()</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于<code>async</code>关键字将函数转换为promise，因此您可以重构代码以使用<code>promises</code>和<code>await</code>的混合方法，将函数的后半部分放入新块中以使其更灵活：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> response.blob();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch().then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>执行过程：在方法调用前添加的await关键字，然后把结果赋给变量。 await关键字使JavaScript运行时暂停此行上的代码，允许其他代码在此期间执行，直到异步函数调用返回其结果。一旦完成，您的代码将继续从下一行开始执行</li>
</ol>
<h2 id="JS中的可枚举属性"><a href="#JS中的可枚举属性" class="headerlink" title="JS中的可枚举属性"></a>JS中的可枚举属性</h2><p>概念：</p>
<p>可枚举性（enumerable）用来控制所描述的属性，是否将被包括在for…in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。</p>
<ul>
<li>for..in循环</li>
<li>Object.keys方法</li>
<li>JSON.stringify方法 </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line">o.c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;d&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">4</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">o.d</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> o ) <span class="built_in">console</span>.log( o[key] ); </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Object</span>.keys(o)  <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>至于<code>for...in</code>循环和<code>Object.keys</code>方法的区别，在于前者包括对象继承<code>的</code>属性，而后者只包括对象<code>本身的</code>属性</li>
<li>如果需要获取对象自身的所有属性，不管enumerable的值，可以使用<code>Object.getOwnPropertyNames</code>方法</li>
<li>自定义js对象属性默认的enumerable为true，除非用Object.defineProperty函数更改属性特性的值</li>
<li>js封装的基本类型对象的属性的enumberable为false，如Object，Number，Array等，具体比如一个js数组的length属性就是不可枚举的</li>
</ol>
</blockquote>
<h1 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h1><h2 id="什么是API"><a href="#什么是API" class="headerlink" title="什么是API"></a>什么是API</h2><p>应用程序接口（API）是基于编程语言构建的结构，使开发人员更容易地创建复杂的功能。它们抽象了复杂的代码，并提供一些简单的接口规则直接使用。</p>
<h2 id="常见的浏览器API"><a href="#常见的浏览器API" class="headerlink" title="常见的浏览器API"></a>常见的浏览器API</h2><ul>
<li>操作文档的API内置于浏览器中。最明显的例子是DOM（文档对象模型）API，它允许您操作HTML和CSS — 创建、移除以及修改HTML，动态地将新样式应用到您的页面，等等。</li>
<li><strong>从服务器获取数据的API</strong> 用于更新网页的一小部分是相当好用的。这个看似很小的细节能对网站的性能和行为产生巨大的影响 — 如果您只是更新一个股票列表或者一些可用的新故事而不需要从服务器重新加载整个页面将使网站或应用程序感觉更加敏感和“活泼”。使这成为可能的API包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a>。您也可能会遇到描述这种技术的术语<strong>Ajax</strong>。</li>
<li><strong>用于绘制和操作图形的API</strong>目前已被浏览器广泛支持 — 最流行的是允许您以编程方式更新包含在HTML <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas">``</a> 元素中的像素数据以创建2D和3D场景的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a>。</li>
<li><strong>音频和视频API</strong>例如<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API">Web Audio API</a>和<a href="https://developer.mozilla.org/zh-CN/docs/MDN/Doc_status/API/WebRTC">WebRTC</a>允许您使用多媒体来做一些非常有趣的事情</li>
<li><strong>设备API</strong></li>
<li><strong>客户端存储API</strong>在Web浏览器中的使用变得越来越普遍 - 如果您想创建一个应用程序来保存页面加载之间的状态，甚至让设备在处于脱机状态时可用，那么在客户端存储数据将会是非常有用的。例如使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API">Web Storage API</a>的简单的键 - 值存储以及使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB API</a>的更复杂的表格数据存储。</li>
</ul>
<h2 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200701164451220.png" alt="image-20200701164451220"></p>
<h4 id="ECMAScript-JavaScript的核心"><a href="#ECMAScript-JavaScript的核心" class="headerlink" title="ECMAScript - JavaScript的核心"></a>ECMAScript - JavaScript的核心</h4><p>定义了javascript的语法规范</p>
<p>JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关</p>
<h4 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM - 浏览器对象模型"></a>BOM - 浏览器对象模型</h4><p>一套操作浏览器功能的API</p>
<p>通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等</p>
<h4 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM - 文档对象模型"></a>DOM - 文档对象模型</h4><p>一套操作页面元素的API</p>
<p>DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象</p>
<h3 id="BOM的顶级对象window"><a href="#BOM的顶级对象window" class="headerlink" title="BOM的顶级对象window"></a>BOM的顶级对象window</h3><p>window是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window<br>注意：window下一个特殊的属性 window.name </p>
<p>当window这个对象名被占用了，可以使用<code>Top</code></p>
<h3 id="系统的对话框"><a href="#系统的对话框" class="headerlink" title="系统的对话框"></a>系统的对话框</h3><ul>
<li>alert()  //提示框</li>
<li>prompt()  //输入对话框</li>
<li>confirm()   //对话框返回参数，确定是true，取消是false</li>
</ul>
<h3 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h3><ul>
<li>onload</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当页面加载完成执行</span></span><br><span class="line">  <span class="comment">// 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>onunload —-  在谷歌里面不支持</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当用户退出页面时执行</span></span><br><span class="line">  <span class="comment">//用户关闭页面时候弹出的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setTimeout-和clearTimeout"><a href="#setTimeout-和clearTimeout" class="headerlink" title="setTimeout()和clearTimeout()"></a>setTimeout()和clearTimeout()</h4><p>在指定的毫秒数到达之后执行指定的函数，只执行一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个定时器，1000毫秒后执行，返回定时器的标识，即返回的值timerId是定时器的id值</span></span><br><span class="line"><span class="keyword">var</span> timerId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);<span class="comment">//1秒执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器的执行，需要把定时器的id值传给取消定时器</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br></pre></td></tr></table></figure>

<h4 id="setInterval-和clearInterval"><a href="#setInterval-和clearInterval" class="headerlink" title="setInterval()和clearInterval()"></a>setInterval()和clearInterval()</h4><p>定时调用的函数，可以按照给定的时间(单位毫秒)周期调用函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个定时器，每隔1秒调用一次</span></span><br><span class="line"><span class="keyword">var</span> timerId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(date.toLocaleTimeString());</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器的执行</span></span><br><span class="line"><span class="built_in">clearInterval</span>(timerId);</span><br></pre></td></tr></table></figure>

<h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location 对象存储了当前文档位置（URL）相关的信息，简单地说就是网页地址字符串。使用 window 对象的 location 属性可以访问。</p>
<p>location 对象定义了 8 个属性，其中 7 个属性可以获取当前 URL 的各部分信息，另一个属性（href）包含了完整的 URL 信息</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>统一资源定位符 (Uniform Resource Locator, URL)</p>
<p>URL的组成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheme:&#x2F;&#x2F;host:port&#x2F;path?query#fragment</span><br><span class="line">scheme:通信协议</span><br><span class="line">	常用的http,ftp,maito等</span><br><span class="line">	</span><br><span class="line">host:主机</span><br><span class="line">	服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。</span><br><span class="line">port:端口号</span><br><span class="line">	整数，可选，省略时使用方案的默认端口，如http的默认端口为80。</span><br><span class="line">path:路径</span><br><span class="line">	由零或多个&#39;&#x2F;&#39;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。</span><br><span class="line">query:查询</span><br><span class="line">	可选，用于给动态网页传递参数，可有多个参数，用&#39;&amp;&#39;符号隔开，每个参数的名和值用&#39;&#x3D;&#39;符号隔开。例如：name&#x3D;zs</span><br><span class="line">fragment:信息片断</span><br><span class="line">	字符串，锚点.</span><br></pre></td></tr></table></figure>

<h4 id="location成员"><a href="#location成员" class="headerlink" title="location成员"></a>location成员</h4><p>成员</p>
<ul>
<li>assign()：与href一样，但是他是一个方法</li>
<li>reload()：重新加载—刷新</li>
<li>replace()：与assign功能一致，但是不存在历史记录</li>
<li>hash：得到是<code>#</code>之后的内容</li>
<li>host：主机名及端口号</li>
<li>hostname：主机名</li>
<li>port：端口号</li>
<li>pathname：文件的相对路径</li>
<li>protocol：协议</li>
<li>search：搜索的内容</li>
<li><strong><em>href</em></strong>：设置跳转的页面地址(属性)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">http:<span class="comment">//www.xmg.com:8080/index.html?id=666&amp;psd=123#xxx   </span></span><br><span class="line"></span><br><span class="line">- location.hash  <span class="comment">//哈希值 其实就是锚点     ==&gt; #xxx</span></span><br><span class="line">- location.host  <span class="comment">//服务器 服务器名+端口号  =&gt; www.xmg.com:8080</span></span><br><span class="line">- location.hostname <span class="comment">//服务器名            =&gt;  www.xmg.com</span></span><br><span class="line">- location.pathname <span class="comment">//路径名             =&gt; index.html</span></span><br><span class="line">- location.port <span class="comment">//端口                   =&gt; 8080</span></span><br><span class="line">- location.protocol <span class="comment">//协议               =&gt; http </span></span><br><span class="line">- location.search <span class="comment">//参数                 =&gt; ?id=666&amp;psd=123</span></span><br></pre></td></tr></table></figure>



<p>解析URL中的query，并返回对象的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQuery</span>(<span class="params">queryStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> query = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (queryStr.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = queryStr.indexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    queryStr = queryStr.substr(index + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> array = queryStr.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> tmpArr = array[i].split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (tmpArr.length === <span class="number">2</span>) &#123;</span><br><span class="line">        query[tmpArr[<span class="number">0</span>]] = tmpArr[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getQuery(location.search));</span><br><span class="line"><span class="built_in">console</span>.log(getQuery(location.href));</span><br></pre></td></tr></table></figure>

<h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><ul>
<li>back()</li>
<li>forward()</li>
<li>go()              //go(-1)后退，go(1)前进</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后退：</span></span><br><span class="line">history.back();</span><br><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//前进：</span></span><br><span class="line">history.forward();</span><br><span class="line">history.go(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><ul>
<li>navigator.userAgent</li>
</ul>
<p>通过userAgent可以判断用户浏览器的类型</p>
<ul>
<li>navigator.platform</li>
</ul>
<p>通过platform可以判断浏览器所在的系统平台类型.</p>
<h3 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(screen.width);<span class="comment">//屏幕的宽度 </span></span><br><span class="line"><span class="built_in">console</span>.log(screen.height);<span class="comment">//屏幕的高度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.availWidth);<span class="comment">//浏览器可占用的宽度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.availHeight);<span class="comment">//浏览器可占用的高度</span></span><br><span class="line">offset系列 (重要)</span><br></pre></td></tr></table></figure>



<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="DOM的概念"><a href="#DOM的概念" class="headerlink" title="DOM的概念"></a>DOM的概念</h3><p>文档对象模型（Document Object Model，简称DOM），是<a href="http://baike.baidu.com/item/W3C">W3C</a>组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。Document Object Model的历史可以追溯至1990年代后期微软与<a href="http://baike.baidu.com/item/Netscape">Netscape</a>的“浏览器大战”，双方为了在<a href="http://baike.baidu.com/item/JavaScript">JavaScript</a>与<a href="http://baike.baidu.com/item/JScript">JScript</a>一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有<a href="http://baike.baidu.com/item/VBScript">VBScript</a>、<a href="http://baike.baidu.com/item/ActiveX">ActiveX</a>、以及微软自家的<a href="http://baike.baidu.com/item/DHTML">DHTML</a>格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。</p>
<p>DOM又称为文档树模型</p>
<p>![1497154623955](F:/视频教程/HTML/webapi/ziyuan/02-JavaScript-WEB-API-第1天/01教学资料/02-Web API/media/1497154623955.png)</p>
<ul>
<li>文档(document)：一个网页可以称为文档</li>
<li>节点(node)：网页中的所有内容都是节点（标签、属性、文本、注释等）</li>
<li>元素(Element)：网页中的标签</li>
<li>属性(attribute)：标签的属性</li>
</ul>
<h3 id="DOM经常进行的操作"><a href="#DOM经常进行的操作" class="headerlink" title="DOM经常进行的操作"></a>DOM经常进行的操作</h3><ul>
<li>获取元素</li>
<li>动态创建元素</li>
<li>对元素进行操作(设置其属性或调用其方法)</li>
<li>事件(什么时机做相应的操作)</li>
</ul>
<h3 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h3><ol>
<li>根据id获取元素</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);</span><br><span class="line"><span class="comment">// 获取到的数据类型 HTMLDivElement，对象都是有类型的</span></span><br><span class="line"><span class="comment">// 第一个方法: getElementById()</span></span><br><span class="line"><span class="comment">// 作用 : 根据 id值  , 获取元素</span></span><br><span class="line"><span class="comment">// 参数 : 字符串 id值</span></span><br><span class="line"><span class="comment">// 返回值 :  一个对象</span></span><br><span class="line"><span class="comment">// 注意点 : element </span></span><br><span class="line"><span class="comment">// 方法 : 1个</span></span><br><span class="line"><span class="comment">// document.getElementById();</span></span><br></pre></td></tr></table></figure>

<p><strong>获取到的数据类型有：</strong></p>
<p>  HTMLDivElement &lt;– HTMLElement &lt;– Element  &lt;– Node  &lt;– EventTarget</p>
<p><strong>关于<code>console.log</code>和<code>console.dir</code>的区别</strong></p>
<ul>
<li><code>console.log</code>打印一个元素的时候，是以标签的形式进行展示的</li>
<li><code>console.dir</code>打印一个元素的时候，是以对象的形式进行展示的</li>
</ul>
<ol start="2">
<li>根据标签名获取元素</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> div = divs[i];</span><br><span class="line">  <span class="built_in">console</span>.log(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个方法: getElementsByTagName()</span></span><br><span class="line"><span class="comment">// 作用 : 根据 标签名 , 获取元素</span></span><br><span class="line"><span class="comment">// 参数 : 字符串 标签名 </span></span><br><span class="line"><span class="comment">// 返回值 : 数组 (一般使用的话 都是遍历) </span></span><br><span class="line"><span class="comment">// 注意点 : elements </span></span><br><span class="line"><span class="comment">// 方法 :  2个</span></span><br><span class="line"><span class="comment">// document.getElementsByTagName() </span></span><br><span class="line"><span class="comment">// element.getElementsByTagName()</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据name获取元素</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inputs = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;hobby&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; inputs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> input = inputs[i];</span><br><span class="line">  <span class="built_in">console</span>.log(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>根据类名获取元素</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mains = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mains.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> main = mains[i];</span><br><span class="line">  <span class="built_in">console</span>.log(main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>根据选择器获取元素</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#text&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boxes = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; boxes.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> box = boxes[i];</span><br><span class="line">  <span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>总结</p>
<p>​           getElementsByTagName()<br>​         getElementsByName()<br>​      getElementsByClassName()    这三种方式获取到的是数组，使用的时候，需要按下标</p>
</li>
</ul>
<p>​         getElementById()   获取单个元素或节点<br>​      querySelector()    返回符合条件的第一个<br>​    querySelectorAll()   返回符合条件的全部</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>   事件：触发-响应机制</p>
<p>   Event接口表示在DOM中发生的任何事件，一些是用户生成的（例如鼠标或键盘事件），而其他由API生成。</p>
<h3 id="1-事件三要素"><a href="#1-事件三要素" class="headerlink" title="1.事件三要素"></a>1.事件三要素</h3><ul>
<li>事件源:  触发(被)事件的元素</li>
<li>事件类型: 事件的触发方式(例如鼠标点击或键盘点击)</li>
<li>事件处理程序:  事件触发后要执行的代码(函数形式)</li>
</ul>
<h3 id="2-事件的三个阶段"><a href="#2-事件的三个阶段" class="headerlink" title="2.事件的三个阶段"></a>2.事件的三个阶段</h3><ol>
<li><p>捕获阶段  :  从外向里</p>
</li>
<li><p>当前目标阶段：最开始选择的那个</p>
</li>
<li><p>冒泡阶段 ：从里向外 </p>
<p>事件对象（e）.eventPhase属性可以查看事件触发时所处的阶段如果这个属性值是：</p>
<ul>
<li><p>1———-&gt;  捕获阶段</p>
</li>
<li><p>2———–&gt; 目标阶段</p>
</li>
<li><p>3———–&gt; 冒泡</p>
</li>
</ul>
<p>一般默认是冒泡，很少使用捕获</p>
</li>
</ol>
<h3 id="3-事件的基本使用"><a href="#3-事件的基本使用" class="headerlink" title="3.事件的基本使用"></a>3.事件的基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;代码会在box被点击后执行&#x27;</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-获取事件对象"><a href="#4-获取事件对象" class="headerlink" title="4.获取事件对象"></a>4.获取事件对象</h3><p><strong>现代浏览器获取 : (掌握)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给一个形参即可</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//event就是事件对象，里面包含了事件触发时的一些信息。</span></span><br><span class="line">    <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>低版本浏览器 (ie678): (了解)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//IE678通过window.event获取事件对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>兼容</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//只要用到了事件对象，就要记得处理浏览器兼容性</span></span><br><span class="line">    event = event || <span class="built_in">window</span>.event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-事件对象的常用属性"><a href="#5-事件对象的常用属性" class="headerlink" title="5.事件对象的常用属性"></a>5.事件对象的常用属性</h3><blockquote>
<p>事件对象中有很多很多的属性，但是很多属性并不常用。我们经常用到的是鼠标位置信息 和键盘码 相关的信息。</p>
</blockquote>
<ol>
<li><strong>鼠标位置信息的相关属性</strong><ul>
<li>clientX与clientY： 相对于浏览器可视区左上角的位置 （常用）光标相对于可视区左上角的水平位置和垂直位置。</li>
<li>pageX与pageY：相对于网页内容左上角的位置光标相对于网页（文档document）左上角的水平位置与垂直位置</li>
<li>screenX与screenY：相对于屏幕左上角的位置光标相对于屏幕左上角的水平位置与垂直位置。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取事件对象</span></span><br><span class="line">    <span class="comment">//clientX  clientY  :获取的是鼠标在可视区的位置</span></span><br><span class="line">    <span class="comment">//pageX    pageY    :获取的是鼠标在整个页面中的位置： 包括scrollTop</span></span><br><span class="line">    <span class="comment">//screenX scrennY   ：获取在屏幕中的位置</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.clientX, e.clientY);</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageX, e.pageY);</span><br><span class="line">    <span class="built_in">console</span>.log(e.screenX, e.screenY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>记录了键盘码的属性</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">事件学习:</span><br><span class="line">onkeydown : 键盘按下</span><br><span class="line">onkeyup : 键盘抬起</span><br><span class="line">适用于<span class="built_in">document</span>和input等等</span><br><span class="line">event.keyCode:键盘按下的那个键的键盘码</span><br></pre></td></tr></table></figure>

<h3 id="6-注册事件的方式"><a href="#6-注册事件的方式" class="headerlink" title="6.注册事件的方式"></a>6.注册事件的方式</h3><p>1.on + 事件名称</p>
<blockquote>
<p>onclick、onmouseover这种on+事件名称的方式注册事件几乎所有的浏览器都支持。</p>
</blockquote>
<p><strong>注册事件：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">box.onclick = function()&#123;</span><br><span class="line">    //事件处理程序    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>移除事件：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">box.onclick = null; </span><br></pre></td></tr></table></figure>

<p><strong>缺点：</strong></p>
<p>同一个元素同一类型的事件，只能注册一个，如果注册了多个，会出现覆盖问题</p>
<p>2.<strong>addEventListener</strong></p>
<blockquote>
<p>现代浏览器支持的注册事件的新方式，这种方式注册的事件不会出现覆盖问题。存在兼容性问题</p>
</blockquote>
<p><strong>addEventListener的语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数：事件的类型：click mouseover</span></span><br><span class="line"><span class="comment">//第二个参数：函数，监听者，每次点击，这个函数就执行。</span></span><br><span class="line">element.addEventListener(type, func);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">111</span>); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>removeEventListen的语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数：参数类型</span></span><br><span class="line"><span class="comment">//第二个参数：要移除的那个函数</span></span><br><span class="line">element.removeEventListener(type, func);</span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,fn);</span><br><span class="line"><span class="comment">// 注意 : 如果想让注册的事件能移除，不能用匿名函数。</span></span><br></pre></td></tr></table></figure>

<p>低版本浏览器兼容问题</p>
<blockquote>
<p>IE678不支持addEventListener与removeEventListen两个方法，但是支持attachEvent与detachEvent</p>
</blockquote>
<p>attachEvent的用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//type:事件类型   需要加上on   onclick  onmouseenter</span></span><br><span class="line"><span class="comment">//func:需要执行的那个事件</span></span><br><span class="line">attachEvent(type, func)</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码:</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>detachEvent的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;type:事件类型   需要加上on   onclick  onmouseenter</span><br><span class="line">&#x2F;&#x2F;func:需要执行的那个事件</span><br><span class="line">detachEvent(type, func)</span><br><span class="line">兼容性封装（了解）</span><br><span class="line">&#x2F;&#x2F;添加事件</span><br><span class="line">function addEvent(element, type, fn)&#123;</span><br><span class="line">    &#x2F;&#x2F;能力检测</span><br><span class="line">    if(element.addEventListener)&#123;</span><br><span class="line">        element.addEventListener(type, fn, false);</span><br><span class="line">    &#125;else if(element.attachEvent)&#123;</span><br><span class="line">        element.attachEvent(&quot;on&quot;+type, fn);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果都不行，那就用on方式</span><br><span class="line">        element[&quot;on&quot;+type] &#x3D; fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除事件</span><br><span class="line">function removeEvent(element, type, fn) &#123;</span><br><span class="line">    if(element.removeEventListener)&#123;</span><br><span class="line">        element.removeEventListener(type, fn, false);</span><br><span class="line">    &#125;else if(element.detachEvent)&#123;</span><br><span class="line">        element.detachEvent(&quot;on&quot;+type, fn);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        element[&quot;on&quot;+type] &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-事件流"><a href="#7-事件流" class="headerlink" title="7.事件流"></a>7.事件流</h3><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><blockquote>
<p>当一个元素的事件被触发时,同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为冒泡</p>
<p>说白了就是：当我们触发了子元素的某个事件后，父元素对应的事件也会触发。</p>
<p>注意这里传递的仅仅是事件 并不传递所绑定的事件函数。所以如果父级没有绑定事件函数，就算传递了事件 也不会有什么表现 但事件确实传递了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div2&quot;</span>);</span><br><span class="line">   div2.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>);&#125;;</span><br><span class="line">   div1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">2</span>);&#125;;<span class="comment">//父亲</span></span><br><span class="line"><span class="comment">//html代码</span></span><br><span class="line"> &lt;div id=<span class="string">&quot;div1&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=<span class="string">&quot;div2&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就是两个父子关系的div,然后分别加了点击事件，当我们在div2里面点击的时候，会发现弹出了一次1，接着又弹出了2，这说明点击的时候，不仅div2的事件被触发了，它的父级的点击事件也触发了，这种现象就叫做冒泡。点击了div1,自己父级的点击事件也会被触发。</p>
<p><strong>取消冒泡有两种方式</strong>：</p>
<ul>
<li><p>标准的W3C 方式：e.stopPropagation();这里的stopPropagation是标准的事件对象的一个方法，调用即可</p>
</li>
<li><p>非标准的IE方式:ev.cancelBubble=true;  这里的cancelBubble是 IE事件对象的属性，设为true就可以了</p>
</li>
</ul>
<p>封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果提供了事件对象，则这是一个非IE浏览器</span></span><br><span class="line">   <span class="keyword">if</span> ( e &amp;&amp; e.stopPropagation )</span><br><span class="line">      <span class="comment">//因此它支持W3C的stopPropagation()方法</span></span><br><span class="line">      e.stopPropagation();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="comment">//否则，我们需要使用IE的方式来取消事件冒泡</span></span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件委托（代理）"><a href="#事件委托（代理）" class="headerlink" title="事件委托（代理）"></a>事件委托（代理）</h4><ul>
<li>代码简洁</li>
<li>减少浏览器的内存占用</li>
<li>说明：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。</li>
<li>原理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给<strong>最外面的div加点击事件</strong>，那么里面的ul，li，a做点击事件的时候，都会<strong>冒泡到最外层的div上</strong>，所以都会<strong>触发</strong>，这就是事件委托，委托它们父级代为执行事件。</li>
<li>作用：为子节点实现相同的功能，这样有利减少浏览器的内存占用</li>
<li>普通方法实现点击li 弹出123 例子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;111&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    var oUl &#x3D; document.getElementById(&quot;ul1&quot;);</span><br><span class="line">    var aLi &#x3D; oUl.getElementsByTagName(&#39;li&#39;);</span><br><span class="line">    for(var i&#x3D;0;i&lt;aLi.length;i++)&#123;</span><br><span class="line">        aLi[i].onclick &#x3D; function()&#123;</span><br><span class="line">            alert(123);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的方法，减少dom操作</p>
</blockquote>
<ul>
<li>用事件委托的方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ul1&quot;</span>);</span><br><span class="line">   oUl.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，<strong>那么问题就来了</strong>，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：</p>
<p>Event对象提供了一个属性叫<strong>target</strong>，可以返回事件的目标节点，我们成为<strong>事件源</strong>，也就是说，target就可以表示为当前的事件操作的dom，但是<strong>不是真正操作dom</strong>，当然，这个是有兼容性的，标准浏览器用<strong>ev.target</strong>，IE浏览器用<strong>event.srcElement</strong>，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用<strong>nodeName</strong>来获取具体是什么标签名，这个<strong>返回的是一个大写的，我们需要转成小写再做比较</strong>（习惯问题）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ul1&quot;</span>);</span><br><span class="line">　　oUl.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">　　　　<span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">　　　　<span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line">　 　　　　　　 alert(<span class="number">123</span>);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> Add = <span class="built_in">document</span>.getElementById(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> Remove = <span class="built_in">document</span>.getElementById(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> Move = <span class="built_in">document</span>.getElementById(<span class="string">&quot;move&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> Select = <span class="built_in">document</span>.getElementById(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            Add.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;添加&#x27;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            Remove.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;删除&#x27;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            Move.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;移动&#x27;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            Select.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;选择&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用事件代理，只要操作一次dom就能完成所有的效果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> oBox = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">            oBox.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">                <span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">                <span class="keyword">if</span>(target.nodeName.toLocaleLowerCase() == <span class="string">&#x27;input&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">switch</span>(target.id)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span> :</span><br><span class="line">                            alert(<span class="string">&#x27;添加&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;remove&#x27;</span> :</span><br><span class="line">                            alert(<span class="string">&#x27;删除&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;move&#x27;</span> :</span><br><span class="line">                            alert(<span class="string">&#x27;移动&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;select&#x27;</span> :</span><br><span class="line">                            alert(<span class="string">&#x27;选择&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul>
<li><strong>onkeydown</strong> : 当用户 按下键盘上按键 时会触发<code>onkeydown</code>事件.</li>
<li><strong>onkeyup</strong> : 在当前元素上 释放键盘按键 时会触发<code>onkeyup事件.</code></li>
<li>onkeypress : 键盘按下时触发</li>
</ul>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul>
<li>onclick:单击事件</li>
<li>ondblclick：双击事件</li>
<li>onmouseover：鼠标经过事件</li>
<li>onmouseout：鼠标离开事件</li>
<li>onmousemove：鼠标移动事</li>
<li>onfocus：获得焦点事件</li>
<li>onblur：失去焦点事件</li>
<li>onmousedown:鼠标按下事件</li>
<li>onmouseup:鼠标弹起事件</li>
</ul>
<h3 id="拖拽事件"><a href="#拖拽事件" class="headerlink" title="拖拽事件"></a>拖拽事件</h3><p>在HTML5的规范中，我们可以通过为元素增加draggable=”true”来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启的。</p>
<h4 id="1-拖拽元素"><a href="#1-拖拽元素" class="headerlink" title="1.拖拽元素"></a>1.拖拽元素</h4><p>​    页面中设置了draggable=”true”属性的元素</p>
<h4 id="2-目标元素"><a href="#2-目标元素" class="headerlink" title="2.目标元素"></a>2.目标元素</h4><p>​    页面中任何一个元素都可以成为目标元素</p>
<h4 id="3-事件监听"><a href="#3-事件监听" class="headerlink" title="3.事件监听"></a>3.事件监听</h4><p><strong>拖拽元素</strong></p>
<p>​    ondrag     应用于拖拽元素，整个拖拽过程都会调用</p>
<p>​    ondragstart    应用于拖拽元素，当拖拽开始时调用</p>
<p>​    ondragleave    应用于拖拽元素，当鼠标离开拖拽元素时调用</p>
<p>​    ondragend    应用于拖拽元素，当拖拽结束时调用</p>
<p><strong>目标元素</strong></p>
<p>​    ondragenter    应用于目标元素，当拖拽元素进入时调用</p>
<p>​    ondragover    应用于目标元素，当停留在目标元素上时调用</p>
<p>​    ondrop        应用于目标元素，当在目标元素上松开鼠标时调用</p>
<p>​    ondragleave    应用于目标元素，当鼠标离开目标元素时调用</p>
<h4 id="放到何处-ondragover"><a href="#放到何处-ondragover" class="headerlink" title="放到何处 - ondragover"></a>放到何处 - ondragover</h4><p>​    ondragover 事件规定在何处放置被拖动的数据。</p>
<p>​    默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</p>
<p>​    这要通过调用 ondragover 事件的 <strong>event</strong>.preventDefault() 方法</p>
<h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><h3 id="1-非表单元素的属性"><a href="#1-非表单元素的属性" class="headerlink" title="1.非表单元素的属性"></a>1.非表单元素的属性</h3><blockquote>
<p>通过DOM设置普通标签属性，两边都会变化。常见的属性有：src、title、href、className、id等</p>
</blockquote>
<ul>
<li>innerHTML和innerText</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">box.innerHTML = <span class="string">&#x27;我是文本&lt;p&gt;我会生成为标签&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(box.innerHTML);</span><br><span class="line">box.innerText = <span class="string">&#x27;我是文本&lt;p&gt;我不会生成为标签&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(box.innerText);</span><br></pre></td></tr></table></figure>

<ul>
<li>HTML转义符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;		&quot;</span><br><span class="line">‘		&amp;apos;</span><br><span class="line">&amp;		&amp;</span><br><span class="line">&lt;		&lt;    &#x2F;&#x2F;less than  小于</span><br><span class="line">&gt;		&gt;   &#x2F;&#x2F; greater than  大于</span><br><span class="line">空格	   &amp;nbsp;</span><br><span class="line">©		&amp;copy;</span><br></pre></td></tr></table></figure>



<h3 id="2-表单元素属性"><a href="#2-表单元素属性" class="headerlink" title="2.表单元素属性"></a>2.表单元素属性</h3><blockquote>
<p>常见的表单属性有：disabled、type、value、checked、selected</p>
</blockquote>
<p>对于disabled、checked、selected三个属性来说，比较特殊。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">disabled : 禁用</span><br><span class="line">- <span class="literal">true</span> : 禁用</span><br><span class="line">- <span class="literal">false</span> : 不禁用</span><br><span class="line">checked : 多选框和单选框选中</span><br><span class="line">- <span class="literal">true</span> : 选中</span><br><span class="line">- <span class="literal">false</span> : 不选中</span><br><span class="line">selected : 菜单下拉框选中</span><br><span class="line">- <span class="literal">true</span> : 选中</span><br><span class="line">- <span class="literal">false</span> : 不选中</span><br><span class="line">在DOM对象中，他们的赋值.只要有值,很多都可以起到效果,但是为了统一规范, 我们使用 <span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-标签的自定义属性"><a href="#3-标签的自定义属性" class="headerlink" title="3.标签的自定义属性"></a>3.标签的自定义属性</h3><p>在html页面中，定义一个自定义属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">aa</span>=<span class="string">&quot;bb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 给div标签中 添加不存在的未知属性aa, 这就是自定义属性</span><br></pre></td></tr></table></figure>

<p><code>attribute</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置标签的属性</span></span><br><span class="line">box.setAttribute(name, value);</span><br><span class="line"><span class="comment">//获取标签的属性</span></span><br><span class="line">box.getAttribute(name);</span><br><span class="line"><span class="comment">//移除标签的属性</span></span><br><span class="line">box.removeAttribute(name);</span><br></pre></td></tr></table></figure>

<ul>
<li>与element.属性的区别: 上述三个方法用于获取任意的行内属性。</li>
<li>自定义属性，不能通过Dom对象的获取元素的方法，进行有关操作。</li>
<li>总结</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1. 直接给标签里添加固有的属性 title 等 标签+对象里都有显示</span></span><br><span class="line"> <span class="comment">// 2. 给标签添加自定义属性  =&gt; 标签上显示  +  对象点属性名里找不到</span></span><br><span class="line"> <span class="comment">// 3. 给对象添加自定义属性  =&gt; 标签里不显示  + 对象点属性名里可以找到                    【掌握】</span></span><br><span class="line"> <span class="comment">//    自定义:  box.aa = bb;  只能给对象里添加,, 标签内是没有的</span></span><br><span class="line"> <span class="comment">//    获取使用 : box.aa</span></span><br><span class="line"> <span class="comment">// 3. 自定义 : setAttribute 设置, 添加给标签内了获取使用 getAttribute       【掌握】</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;box&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        box.setAttribute(<span class="string">&#x27;title&#x27;</span>, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">        box.setAttribute(<span class="string">&#x27;aa&#x27;</span>, <span class="string">&quot;bb&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(box.title)  <span class="comment">// test</span></span><br><span class="line">        <span class="built_in">console</span>.log(box.aa)  <span class="comment">// undefined</span></span><br><span class="line">        box.ff = <span class="string">&#x27;Eval&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(box.ff) <span class="comment">//Eval</span></span><br></pre></td></tr></table></figure>

<h3 id="4-标签的内容属性innerText-和-innerHTML"><a href="#4-标签的内容属性innerText-和-innerHTML" class="headerlink" title="4.标签的内容属性innerText 和 innerHTML"></a>4.标签的内容属性innerText 和 innerHTML</h3><blockquote>
<p>共同点 : 都是用来获取和设置标签的内容的</p>
<p>区别 : innerHTML可以用于获取和设置标签的所有内容，包括标签和文本内容</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//innerHTML:内部的HTML</span></span><br><span class="line"><span class="comment">//  获取标签内容的时候，不管标签还是文本，都能获取到</span></span><br><span class="line"><span class="comment">//  innerHTML设置内容的时候，覆盖原来内容，标签也能生效，浏览器能解析这个标签。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>innerText可以用于获取和设置标签的文本内容，会丢弃掉标签</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//innerText:内部 文本</span></span><br><span class="line"><span class="comment">//  获取标签内容的时候，只会获取文本，标签扔掉了</span></span><br><span class="line"><span class="comment">//  设置标签内容的时候，覆盖原来内容，对标签进行转义（目的：把标签直接当文本来用）</span></span><br></pre></td></tr></table></figure>

<p>二者的区别：</p>
<ul>
<li>innerHTML能够识别标签，标签能够生效</li>
<li>innerText只识别文本，标签会被转义。</li>
</ul>
<blockquote>
<p>浏览器兼容性：指网页在各种浏览器上的显示效果不一致。或者是一些属性和方法在低版本的浏览器中不支持。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. innerText是IE提出来的属性，因此低版本的火狐浏览器不支持这个属性。</span><br><span class="line"></span><br><span class="line">2. 火狐有一个textContent属性，效果跟innerText一样，谷歌支持但是IE678不支持这个属性</span><br></pre></td></tr></table></figure>

<p>书写innerText的兼容性代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> element.innerText === <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> element.innerText;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element.textContent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在浏览器中如果某个属性不支持该浏览器，那么这个属性的类型是undefined.</p>
</blockquote>
<h3 id="5-类名操作"><a href="#5-类名操作" class="headerlink" title="5.类名操作"></a>5.类名操作</h3><p>1、Node.classList.add(‘class’) 添加class</p>
<p>2、Node.classList.remove(‘class’) 移除class</p>
<p>3、Node.classList.toggle(‘class’) 切换class，有则移除，无则添加</p>
<p>4、Node.classList.contains(‘class’) 检测/判断是否存在class</p>
<p>Node指一个有效的DOM节点，是一个通称。</p>
<h3 id="6-H5自定义属性"><a href="#6-H5自定义属性" class="headerlink" title="6.H5自定义属性"></a>6.H5自定义属性</h3><p>在HTML5中我们可以自定义属性，其格式如下：<code>data-*=&quot;&quot;</code></p>
<ul>
<li><p>例如：data-info=”我是自定义属性”</p>
</li>
<li><p>通过Node.dataset[‘info’] 我们便可以获取到自定义的属性值。</p>
</li>
<li><p>Node.dataset是以类对象形式存在的</p>
</li>
<li><p>当我们如下格式设置时，则需要以驼峰格式才能正确获取</p>
<p>data-my-name=”itcast”，获取Node.dataset[‘myName’]</p>
</li>
</ul>
<h2 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h2><blockquote>
<p>标签不仅可以通过class属性操作样式 (嵌套样式)，还可以通过style属性操作样式 (行内样式)。</p>
<p>同样的DOM对象可以通过className操作样式 (嵌套样式)，也可以通过style属性操作样 (行内样式)。</p>
<p>css : 嵌套样式 =&gt; js : 类名 div.className = ‘red’;</p>
<p>css : 行内样式 =&gt; js : style对象 div.style.color = ‘red’;</p>
</blockquote>
<h3 id="body的样式操作"><a href="#body的样式操作" class="headerlink" title="body的样式操作"></a>body的样式操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">document</span>.body :body比较常用, 并且在页面中是唯一的, 因此可以使用<span class="built_in">document</span>.body直接获取   </span><br><span class="line"><span class="comment">// 可以通过qs获取,也可直接获取</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">document</span>.documentElement :  可以获取html元素</span><br><span class="line"><span class="number">3.</span> <span class="built_in">document</span>.head : 可以直接获取head元素</span><br><span class="line"><span class="number">4.</span> <span class="built_in">document</span>.title : 可以直接获取title的文本</span><br></pre></td></tr></table></figure>

<h3 id="关于cssText"><a href="#关于cssText" class="headerlink" title="关于cssText"></a>关于cssText</h3><blockquote>
<p>使用cssText可以设置style的属性值</p>
<p>可以省略</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width:100px;height:100px&quot;&gt;哈哈哈&lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D;  document.querySelector(&#39;div&#39;);</span><br><span class="line">div.style.cssText &#x3D; &#39;background:red;color:yellow&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：可以一次性设置多个值</li>
<li>缺点：会覆盖其他值 不利于阅读</li>
</ul>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="1-节点属性"><a href="#1-节点属性" class="headerlink" title="1.节点属性"></a>1.节点属性</h3><ol>
<li><p>节点：页面中的所有内容（标签、文本text、属性、注释comment）</p>
</li>
<li><p>节点的属性:</p>
</li>
</ol>
<ul>
<li>nodeType:节点的类型：1–标签 2—属性  3—文本  8—注释</li>
<li>nodeName：节点的名字：</li>
<li>nodeValue：节点的值：</li>
<li>childNodes：获取所有的子节点</li>
</ul>
<h3 id="2-节点查找"><a href="#2-节点查找" class="headerlink" title="2.节点查找"></a>2.节点查找</h3><ol>
<li>孩子节点 </li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//childNodes:获取所有的孩子节点（包括了元素节点和其他很多类型的节点，基本不常用）</span></span><br><span class="line">★ children --- 获取所有的子元素（用途很广泛），兼容性：IE678会把注释节点算上。 </span><br><span class="line"><span class="comment">// 第几个元素</span></span><br><span class="line">children[n] 第n个元素 </span><br><span class="line"></span><br><span class="line"><span class="comment">//firstChild //第一个子节点  (基本不常用)</span></span><br><span class="line">★ firstElementChild  --- 第一个子元素 有兼容性问题（IE678） </span><br><span class="line"></span><br><span class="line"><span class="comment">//lastChild //最后一个节点  (基本不常用)</span></span><br><span class="line">★ lastElementChild --- 最后一个子元素 有兼容性问题（IE678） </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>兄弟节点</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. nextSibling:下一个兄弟节点  (基本不常用)</span></span><br><span class="line">★ <span class="number">2.</span> nextElementSibling:下一个兄弟元素（IE678不兼容）</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. previousSibling//上一个兄弟节点  (基本不常用)</span></span><br><span class="line">★ <span class="number">4.</span> previousElementSibling <span class="comment">//上一个兄弟元素 有兼容性问题 可以封装一个兼容性方法 </span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>父亲节点</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">★ <span class="number">1.</span> parentNode:父节点  <span class="comment">//没有兼容性问题</span></span><br></pre></td></tr></table></figure>

<h3 id="3-添加节点"><a href="#3-添加节点" class="headerlink" title="3.添加节点"></a>3.添加节点</h3><h4 id="appendChild-在子元素的最后添加一个新元素"><a href="#appendChild-在子元素的最后添加一个新元素" class="headerlink" title="appendChild 在子元素的最后添加一个新元素"></a>appendChild 在子元素的最后添加一个新元素</h4><p><strong>语法</strong>：parent.appendChild(newChild)</p>
<p><code>父元素.appendChild(子元素);</code><br><strong>parent</strong> : 调用者，父节点来调用</p>
<p><strong>newChild</strong> : 需要添加的那个孩子。</p>
<p><strong>作用</strong> ：把newChild添加到parent的孩子的 最后面。 (就相当于生孩子一样,最后的孩子,都是最小的最靠后的)</p>
<blockquote>
<p>注意 :: 如果添加的是页面中本来就存在的元素，是一个剪切的效果，原来的就不在了。</p>
</blockquote>
<h4 id="insertBefore-放在某个元素之前"><a href="#insertBefore-放在某个元素之前" class="headerlink" title="insertBefore : 放在某个元素之前"></a>insertBefore : 放在某个元素之前</h4><p><strong>语法</strong>：parent.insertBefore(newChild, refChild);</p>
<p><strong>parent</strong>:必须要父节点来调用</p>
<p><strong>newChild</strong>：需要添加的那个节点</p>
<p><strong>refChild</strong>:添加到哪一个节点的前面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1. 拼接到最后  (常用)</span></span><br><span class="line">div.appendChild(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加到s1之前 s2 s3之前  (常用)</span></span><br><span class="line">div.insertBefore(p,s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加到最后一个</span></span><br><span class="line">div.insertBefore(p,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 拓展 :非要添加在s2之后??</span></span><br><span class="line">div.insertBefore(p,s2.nextElementSibling);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 添加到父元素最前  (常用)</span></span><br><span class="line">div.insertBefore(p,div.children[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="4-克隆节点-重点"><a href="#4-克隆节点-重点" class="headerlink" title="4.克隆节点 (重点)"></a>4.克隆节点 (重点)</h3><p><strong>语法</strong>：var newNode = 节点.cloneNode(deep)</p>
<p><strong>功能</strong>：在内存中克隆一份节点</p>
<p><strong>参数</strong>：false / true</p>
<ul>
<li><p>false：默认值：是浅复制，只会复制标签，节点本身，不会复制节点的孩子。</p>
</li>
<li><p>true: 深度复制，会复制标签，还会复制标签的所有内容 常用</p>
</li>
</ul>
<blockquote>
<ol>
<li>克隆出来的节点跟原来的节点没有关系了，修改了也不会相互影响。</li>
<li>如果克隆的节点带了id，我们需要给id重新设置一个值，不让id冲突</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newNode = div.cloneNode(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// false : 浅复制  只复制该元素</span></span><br><span class="line"><span class="comment">// true : 深复制   不仅复制该元素 还复制其子元素</span></span><br><span class="line"><span class="built_in">console</span>.log(newNode);</span><br></pre></td></tr></table></figure>

<h3 id="5-创建节点"><a href="#5-创建节点" class="headerlink" title="5.创建节点"></a>5.创建节点</h3><h4 id="document-write"><a href="#document-write" class="headerlink" title="document.write()"></a>document.write()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;新设置的内容&lt;p&gt;标签也可以生成&lt;/p&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// 基本不用</span></span><br></pre></td></tr></table></figure>

<p>缺陷：如果在页面加载完毕后，创建的元素会覆盖之前所有内容，需要在页面加载完毕之前创建。</p>
<p>原理：页面从上往下加载的时候，会开启一个文档流，当页面加载完，文档流就会关闭。</p>
<p>document.write的本意就是在文档流上写入内容。如果页面没加载完成，文档流还是开着的，document.write直接在这个文档流上写东西</p>
<p>如果页面加载完成了，还是用document.write写东西，会重新开启一个新的文档流，往新的文档流上写东西，旧的文档流就被新的文档流覆盖了。</p>
<blockquote>
<p><code>百度新闻代码块，嵌入广告新闻块</code></p>
</blockquote>
<h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><blockquote>
<p>innerHTML创建节点的时候有一个特点，如果原来有内容的话，使用innerHTML会把原先的内容给干掉。</p>
<p>慎用：很容易出现效率问题。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">box.innerHTML = <span class="string">&#x27;新内容&lt;p&gt;新标签&lt;/p&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h4><ul>
<li>语法：<code>var div = document.createElement(&#39;div&#39;);</code></li>
<li>作用：在内存里面创建了一个节点</li>
<li>返回：一个元素</li>
</ul>
<h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><ul>
<li>innerHTML方法由于会对字符串进行解析，需要避免在循环内多次使用。</li>
<li>可以借助字符串或数组的方式进行替换，再设置给innerHTML</li>
<li>优化后与document.createElement性能相近</li>
</ul>
<h3 id="其他节点操作"><a href="#其他节点操作" class="headerlink" title="其他节点操作"></a>其他节点操作</h3><ul>
<li>插入节点：<code>document.body.appendChild(div);</code> 插入到父节点中</li>
<li>删除节点：<code>parent.removeChild(child);</code> 由父盒子调用，删除里面的一个子元素。</li>
<li>替换节点：<code>parentNode.replaceChild(newChild, oldChild);</code><ul>
<li><code>newChild</code>用来替换 <code>oldChild</code>的新节点，如果<code>newChild</code>已经存在于DOM树中，则它会被从原始位置删除。</li>
</ul>
</li>
</ul>
<h2 id="三大家族"><a href="#三大家族" class="headerlink" title="三大家族"></a>三大家族</h2><h3 id="offset家族"><a href="#offset家族" class="headerlink" title="offset家族"></a>offset家族</h3><blockquote>
<p>offset系列用于用于获取元素自身的大小和位置 ，在网页特效中有广泛应用</p>
<p>offset家族主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop</p>
</blockquote>
<p><strong>offsetHeight与offsetWidth</strong></p>
<ol>
<li>获取的是元素真实的高度和宽度</li>
<li>获取到的是数值类型，方便计算</li>
<li>offsetHeight与offsetWidth是只读属性，不能设置。</li>
<li>内容大小+border+padding</li>
</ol>
<p><strong>offsetTop与offsetLeft</strong></p>
<ol>
<li>获取的是元素到距离自身最近的（带有定位的）父元素的 顶部或者左侧 的距离</li>
<li>获取到的是数值类型</li>
<li>只读</li>
</ol>
<p><strong>style.height与style.width</strong></p>
<ol>
<li>style.height是字符串（而且带单位），而且他只能获取行内样式 ；  offsetHeight是数值（数字无单位）</li>
<li>demo.style.height可以设置行内样式，offsetHeight是只读属性</li>
</ol>
<p><strong>offsetParent</strong></p>
<ol>
<li>获取到当前元素外面的定位父盒子 HTMLElement.offsetParent 是一个只读属性</li>
<li>返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。</li>
<li>如果没有定位的元素，则 offsetParent 为最近的 table, table cell 或根元素</li>
<li>当元素的 style.display 设置为 “none” 时，offsetParent 返回 null。</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200702194328105.png" alt="image-20200702194328105"></p>
<h3 id="scroll家族"><a href="#scroll家族" class="headerlink" title="scroll家族"></a>scroll家族</h3><blockquote>
<p>scroll家族是用来获取盒子内容的大小和位置</p>
<p>scroll 家族主要有 : scrollWidth、scrollHeight、scrollLeft、scrollTop</p>
</blockquote>
<p><strong>scrollWidth与scrollHeight</strong></p>
<ul>
<li><p>scrollWidth与scrollHeight是盒子内容的真实的宽度和高度。与和盒子大小无关，仅仅与盒子的内容有关系。 (padding + 内容)</p>
</li>
<li><p>如果内容不超过盒子,盒子高度就是 scrollHeight ,(宽度同理)</p>
</li>
<li><p>如果内容超过盒子, 内容高度 就是scrollHieght</p>
</li>
</ul>
<p><strong>scrollTop 被浏览器卷去的高度</strong></p>
<ol>
<li>scrollTop用于获取内容垂直滚动的像素数。如果没有滚动条，那么scrollTop值是0</li>
<li>给内容超过盒子, 盒子设置 overflow:scroll 就可出现滚动条</li>
</ol>
<p><strong>scrollLeft</strong></p>
<ol>
<li>scrollLeft用于获取内容水平滚动的像素数</li>
<li>演示可以使用内容只是纯字母的</li>
<li>浏览器切忌这种出现水平滚动条,用户体验极差,避免</li>
</ol>
<p><strong>onscroll 事件</strong></p>
<p>对于有滚动条的盒子, 可以使用onscroll注册滚动事件,,每滚动一像素,就会触发该事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = doucment.getElementById(“div”);</span><br><span class="line">div.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(div.scrollLeft);</span><br><span class="line">    <span class="built_in">console</span>.log(div.scrollTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景 : 获取页面被卷去的高度和宽度</strong> </p>
<p>通常来说，scroll家族用的最多的地方就是用来获取页面被卷去的高度，非常的常用</p>
<ul>
<li><p>对于老式的浏览器，需要获取html或者body的scrollTop</p>
</li>
<li><p>对于现在浏览器，使用window.pageYOffset进行获取</p>
</li>
</ul>
<p>页面被卷去的高度和宽度的兼容性封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给整个页面注册滚动事件</span></span><br><span class="line"><span class="built_in">document</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop || <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">var</span> scrollLeft = <span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200702200442330.png" alt="image-20200702200442330"></p>
<h3 id="client家族"><a href="#client家族" class="headerlink" title="client家族"></a>client家族</h3><blockquote>
<p>client家族用于获取盒子可视区的大小</p>
<p>client家族有clientWidth、clientHeight、clientLeft、clientTop</p>
</blockquote>
<p>clientWidth、clientHeight 可视区宽高</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200702200525000.png" alt="image-20200702200525000"></p>
<p><strong>场景 : client系列一般用来获取页面的可视区宽高</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为求的是窗口大小所以用window</span></span><br><span class="line"><span class="built_in">window</span>.onresize =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> W = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">    <span class="built_in">console</span>.log(W);</span><br><span class="line">    <span class="keyword">var</span> H = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    <span class="built_in">console</span>.log(H);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>offset家族 : 真实宽高和位置</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> width : 内容 + border + padding;</span><br><span class="line"><span class="number">2.</span> offsetWidth : 真实宽度</span><br><span class="line"><span class="number">3.</span> offsetHeight :真实高度</span><br><span class="line"><span class="number">4.</span> offsetLeft : 真实左侧距离</span><br><span class="line"><span class="number">5.</span> offsetTop : 真实顶部距离</span><br><span class="line">使用 : </span><br><span class="line">   <span class="number">1.</span> 获取 offset系列</span><br><span class="line">   <span class="number">2.</span> 设置 style系列</span><br></pre></td></tr></table></figure>

<p><strong>scroll家族 : 内容大小</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> scrollTop : 被页面卷去的高度</span><br><span class="line"><span class="number">2.</span> div.onscroll : 给div注册滚动事件 (前提是有滚动条)</span><br><span class="line"><span class="number">3.</span> <span class="built_in">window</span>.onscroll : 给整个页面注册滚动事件</span><br><span class="line"><span class="number">4.</span> 获取 被页面卷去的高度</span><br><span class="line">  top:<span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">  left:<span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="number">0</span></span><br><span class="line"><span class="number">5.</span> 重点掌握 : pageYOffset </span><br></pre></td></tr></table></figure>

<p><strong>client 家族 可视区域大小</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">window</span>.onresize   onresize事件会在窗口被调整大小的时候发生。</span><br><span class="line"><span class="number">2.</span> 可视区域大小 : <span class="built_in">window</span>.innerWidth</span><br></pre></td></tr></table></figure>

<h2 id="音频API"><a href="#音频API" class="headerlink" title="音频API"></a>音频API</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WEB音频API测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;即将播放音频！&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//创建音乐播放的上下文实例,适配手机和PC</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> audioContext = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext||<span class="built_in">window</span>.webkitAudioContext)();</span></span><br><span class="line"><span class="javascript">            <span class="comment">//为即将到来的音频文件创建一个缓冲区</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> source = audioContext.createBufferSource();</span></span><br><span class="line"><span class="javascript">            <span class="comment">//创建Ajax请求对象，用于向服务器请求音频资源</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 使用非异步请求方式，来请求音频资源</span></span></span><br><span class="line"><span class="javascript">            request.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;./TheMountain.mp3&#x27;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 设置服务器即将返回的类型，便于浏览器解码</span></span></span><br><span class="line"><span class="javascript">            request.responseType = <span class="string">&#x27;arraybuffer&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//一旦请求内容完整返回就开始解码</span></span></span><br><span class="line"><span class="javascript">                audioContext.decodeAudioData(request.response,<span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>)</span>&#123;</span></span><br><span class="line">                    source.buffer = buffer;</span><br><span class="line"><span class="javascript">                    <span class="comment">//连接音频资源，正式播放</span></span></span><br><span class="line">                    source.connect(audioContext.destination);</span><br><span class="line"><span class="javascript">                    <span class="comment">//设置为循环播放模式</span></span></span><br><span class="line"><span class="javascript">                    source.loop = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 等待零秒后播放</span></span></span><br><span class="line">                    source.start(0);</span><br><span class="line"><span class="javascript">                &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&#x27;Audio Error!&#x27;</span>,e);</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">// 开启ajax请求</span></span></span><br><span class="line">            request.send();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">//window.onload = function()&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//  play();</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//&#125;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;play()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;播放&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="地理定位API"><a href="#地理定位API" class="headerlink" title="地理定位API"></a>地理定位API</h2><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="1-变量的解构赋值"><a href="#1-变量的解构赋值" class="headerlink" title="1.变量的解构赋值"></a>1.变量的解构赋值</h3><ol>
<li>定义：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>默认值：解构赋值允许指定默认值,当一个数组成员严格等于<code>undefined</code>，默认值才会生效。同时默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// 默认值变量之间的引用</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure>



<h3 id="2-对象的结构赋值"><a href="#2-对象的结构赋值" class="headerlink" title="2.对象的结构赋值"></a>2.对象的结构赋值</h3><ol>
<li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line">log(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与数组一样，解构也可以用于嵌套结构的对象。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>对象的解构赋值可以取到继承的属性。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>对象的解构也可以指定默认值。</li>
</ol>
<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h3 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3.字符串的解构赋值"></a>3.字符串的解构赋值</h3><ol>
<li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-数值和布尔值的解构赋值"><a href="#4-数值和布尔值的解构赋值" class="headerlink" title="4.数值和布尔值的解构赋值"></a>4.数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
</blockquote>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h3 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="comment">// 使用默认值，在解构赋值错误的时候，有效救场</span></span><br></pre></td></tr></table></figure>

<h3 id="6-解构赋值圆括号问题"><a href="#6-解构赋值圆括号问题" class="headerlink" title="6.解构赋值圆括号问题"></a>6.解构赋值圆括号问题</h3><ol>
<li><p>不能使用圆括号的情况</p>
<ul>
<li>变量声明语句</li>
<li>函数参数</li>
<li>赋值语句的模式</li>
</ul>
</li>
<li><p>可以使用圆括号的情况</p>
<ul>
<li>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p>
</blockquote>
</li>
</ol>
<h2 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ol>
<li>定义：set是一种新的数据结构，成员的值是唯一的，没有重复的值。（本身是构造函数）</li>
<li><code>add()</code>方法向set结构添加成员，同样也不能添加重复的值。</li>
<li><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</li>
<li>两个对象总是不相等的</li>
<li>可以用来数组去重<code>Array.from(new Set(array));</code></li>
</ol>
<h4 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h4><ol>
<li><p>属性</p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>add(value)：添加某个值，返回 Set 结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.from</code>方法可以将 Set 结构转为数组。</li>
</ul>
</li>
</ol>
<h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><ul>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器</li>
<li><code>Set.prototype.values()</code>：返回键值的遍历器</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<ol>
<li><code>keys()</code>，<code>values()</code>，<code>entries()</code>Set 结构没有键名，只有键值，所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>forEach()</code></li>
<li>扩展运算符(…)</li>
<li>map,filter方法</li>
<li>可以实现并集（Union）、交集（Intersect）和差集（Difference）。</li>
</ol>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="含义及用法"><a href="#含义及用法" class="headerlink" title="含义及用法"></a>含义及用法</h4><ol>
<li>定义：Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>它属于”键值对“的数据结构，而且属于构造函数</li>
<li>Map函数的参数：数组、具有Iterator接口、参数成员是一个双元素的数组的数据结构。（Set，Map都可以）</li>
</ol>
<h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><ol>
<li><code>size</code>属性返回 Map 结构的成员总数。</li>
<li><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后<strong>返回整个 Map 结构</strong>。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。可采用链式写法</li>
<li><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li>
<li><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li>
<li><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><code>clear</code>方法清除所有成员，没有返回值。</li>
</ol>
<h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><ol>
<li><p>Map 的遍历顺序就是<strong>插入顺序</strong>。它的结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li>keys() 返回键名</li>
<li>values() 返回键值</li>
<li>entries() 返回所有成员</li>
<li>forEach()  遍历所有成员</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//forEach方法还可以接受第二个参数，用来绑定this。forEach方法的回调函数的this，就指向reporter。</span></span><br><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  report: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="与其他数据结构的转化"><a href="#与其他数据结构的转化" class="headerlink" title="与其他数据结构的转化"></a>与其他数据结构的转化</h4><ol>
<li>Map结构转换为数组，扩展运算符（<code>...</code>）</li>
<li>数组转化为Map：将数组作为参数传入Map函数</li>
<li>Map结构转化为对象：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对象转化为Map：使用<code>Object.entries()</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Map转化为JSON,Map 转为 JSON 要区分两种情况。<ul>
<li>一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</li>
<li>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</li>
</ul>
</li>
<li>JSON 转为 Map，<ol>
<li>正常情况下，所有键名都是字符串。</li>
<li>特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</li>
</ol>
</li>
</ol>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>定义：Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</li>
<li>作用：在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</li>
<li>语法：<code>var proxy = new Proxy(target, handler);</code><ul>
<li><code>target</code>参数表示所要拦截的目标对象</li>
<li><code>handler</code>参数也是一个对象，用来定制拦截行为,一个拦截函数。</li>
</ul>
</li>
<li>方法：<ul>
<li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>
</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ul>
<li>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。</li>
<li>装饰器是一种函数，写成<code>@ + 函数名</code>。它可以放在类和类方法的定义前面。</li>
</ul>
<h4 id="类的装饰器"><a href="#类的装饰器" class="headerlink" title="类的装饰器"></a>类的装饰器</h4><ul>
<li>装饰器是一个对类进行处理的函数，装饰器函数的第一个参数，就是所要装饰的目标类。</li>
<li>装饰器的行为：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@decorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器本质就是编译时执行的函数</li>
<li>如果想添加实例属性，可以通过目标类的prototype对象操作。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyTestableClass();</span><br><span class="line">obj.isTestable <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="方法的装饰"><a href="#方法的装饰" class="headerlink" title="方法的装饰"></a>方法的装饰</h4><ul>
<li>装饰器不仅可以装饰类，还可以装饰类的属性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器函数可以接受三个参数。<ul>
<li>第一个参数是类的原型对象</li>
<li>第二个参数是所要装饰的属性名</li>
<li>第三个参数是该属性的描述对象。</li>
</ul>
</li>
<li>装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改属性描述对象的enumerable属性，使得该属性不可遍历。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @nonenumerable</span><br><span class="line">  <span class="keyword">get</span> <span class="title">kidCount</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.children.length; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器有注释的作用。</li>
<li>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;evaluated&#x27;</span>, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;executed&#x27;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    @dec(<span class="number">1</span>)</span><br><span class="line">    @dec(<span class="number">2</span>)</span><br><span class="line">    method()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure>



<h4 id="为什么装饰器不能用于函数"><a href="#为什么装饰器不能用于函数" class="headerlink" title="为什么装饰器不能用于函数"></a>为什么装饰器不能用于函数</h4><p>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升，而类不存在提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly = <span class="built_in">require</span>(<span class="string">&quot;some-decorator&quot;</span>);</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码也有问题，因为实际执行是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly;</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readOnly = <span class="built_in">require</span>(<span class="string">&quot;some-decorator&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果一定要装饰函数，可以采用高阶函数的形式直接执行。</p>
<h4 id="core-decorators-js"><a href="#core-decorators-js" class="headerlink" title="core-decorators.js"></a>core-decorators.js</h4><p><a href="https://github.com/jayphelps/core-decorators.js">core-decorators.js</a>是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器</p>
<ul>
<li>@autobind装饰器使得方法中的this对象，绑定原始对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; autobind &#125; <span class="keyword">from</span> <span class="string">&#x27;core-decorators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @autobind</span><br><span class="line">  getPerson() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> getPerson = person.getPerson;</span><br><span class="line"></span><br><span class="line">getPerson() === person;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>@readonly装饰器使得属性或方法不可写。</li>
<li>@override装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</li>
<li><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除。</li>
</ul>
<h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h4><p>在装饰器的基础上，可以实现<code>Mixin</code>模式。所谓<code>Mixin</code>模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。</p>
<p><code>mixins.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上面这个装饰器，为类“混入”各种方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">&#x27;./mixins&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo() <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="comment">//通过mixins这个装饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：上面的方法会改写<code>MyClass</code>类的<code>prototype</code>对象</p>
</blockquote>
<h2 id="Iterator（遍历器）"><a href="#Iterator（遍历器）" class="headerlink" title="Iterator（遍历器）"></a>Iterator（遍历器）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p>前言：JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
</li>
<li><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作</p>
</li>
<li><p>作用：</p>
<ul>
<li>一是为各种数据结构，提供统一的、简便的访问接口；</li>
<li>二是使得数据结构的成员能够按某种次序排列；</li>
<li>三是ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。</li>
</ul>
</li>
<li><p>Iterator 的遍历过程</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li>
</ol>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟</span></span><br><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。</p>
</li>
</ol>
<h3 id="默认Iterator接口"><a href="#默认Iterator接口" class="headerlink" title="默认Iterator接口"></a>默认Iterator接口</h3><p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）</p>
<ul>
<li><code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: <span class="number">1</span>,</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>原生具备 Iterator 接口的数据结构如下。<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
</li>
<li>对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，<code>Symbol.iterator</code>方法直接引用数组的 Iterator 接口。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = [][<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)] <span class="comment">// 可以执行了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似数组的对象</span></span><br><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</li>
</ul>
<h3 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h3><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p>
<ol>
<li>解构赋值：对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</li>
<li><strong>扩展运算符</strong>：扩展运算符（…）也会调用默认的 Iterator 接口。  也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</li>
<li><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口</li>
<li>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。<ul>
<li>for…of</li>
<li>Array.from()    //可以将可遍历的数据结构，转化为数组</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
</li>
</ol>
<h3 id="字符串的Iterator接口"><a href="#字符串的Iterator接口" class="headerlink" title="字符串的Iterator接口"></a>字符串的Iterator接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line"><span class="comment">// &quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: &quot;h&quot;, done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: &quot;i&quot;, done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h3><p>遍历器对象除了具有<code>next</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。如果你自己写遍历器对象生成函数，那么<code>next</code>方法是必须部署的，<code>return</code>方法和<code>throw</code>方法是否部署是可选的。</p>
<ul>
<li><code>return</code>方法的使用场合是：<ul>
<li>如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return</code>方法。</li>
<li>如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return</code>方法。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面代码中，情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；情况二会在执行return方法关闭文件之后，再抛出错误。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<code>return</code>方法必须返回一个对象，这是 Generator 规格决定的。</p>
</blockquote>
<ul>
<li><code>throw</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。</li>
</ul>
<h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>
<ul>
<li><p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、Generator 对象，以及字符串。</p>
</li>
<li><p><code>for...in</code>和<code>for...of</code>的区别：</p>
<ul>
<li><code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。   for…of可以获取键值</li>
<li>通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法</li>
<li><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回<strong>具有数字索引的属性</strong></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p>
</blockquote>
<ul>
<li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.classList.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p>
<ul>
<li>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;: &#x27;</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一个方法是使用 Generator 函数将对象重新包装一下。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, <span class="string">&#x27;-&gt;&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure>



<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>理解</strong>：语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>
<p><strong>过程</strong>：执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p><strong>特征：</strong>一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。</p>
<p><strong>运行Generator函数</strong>：<strong>首先</strong>，在函数名前加一对圆括号调用；调用后函数并不执行，返回的结果不是运行结果，而是一个指向内部转态的指针对象，即遍历器对象。<strong>下一步</strong>，必须调用遍历器对象的**<code>next</code>方法**，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next()</span><br></pre></td></tr></table></figure>

<h4 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h4><p>由于 Generator 函数返回的遍历器对象，<strong>只有调用<code>next</code>方法才会遍历下一个内部状态</strong>，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p>
<ul>
<li>运行逻辑：<ul>
<li>遇yield暂停执行之后操作，将yield之后表达式的值，作为返回值value</li>
<li>当再次调用next方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li>
<li><code>if</code>没有再遇到yield表达式，就一直运行到函数结束，直到遇到return语句</li>
<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li>
</ul>
</li>
<li><code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。例如使用forEach遍历yield，forEach内部只是一个普通的函数。</li>
<li>yield表达式如果用在另一个表达式之中，必须<strong>放在圆括号里面</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>, <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="与Iterator接口的关系"><a href="#与Iterator接口的关系" class="headerlink" title="与Iterator接口的关系"></a>与Iterator接口的关系</h4><p>Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h4><ul>
<li><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，<strong>该参数就会被当作上一个<code>yield</code>表达式的返回值。</strong></li>
<li>next()方法正是通过在不同的阶段传递不同的参数，而调整函数的行为。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 第一个next,不需要传参，他的作用是启动遍历器</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line"><span class="comment">// 没有传递参数，默认yield返回值是undefined，即下一个yield中的y为undefined</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;  </span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line"><span class="comment">// 这里第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。</p>
</blockquote>
<h4 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h4><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...numbers()] <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = numbers();</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h4 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h4><ul>
<li>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.throw(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>遍历器对象<code>i</code>连续抛出两个错误。第一个错误被 Generator 函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于 Generator 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的<code>catch</code>语句捕获。</p>
</blockquote>
<ul>
<li><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</li>
<li>不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。后者只能被函数体外的<code>catch</code>语句捕获。</li>
<li>如果 Generator 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</li>
<li><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法</li>
<li><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法。</li>
</ul>
<h4 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h4><p>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.next()        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>return</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</li>
</ul>
<h4 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h4><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p>
<ul>
<li><code>next()</code>是将<code>yield</code>表达式替换成一个值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = g(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.next(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，第二个<code>next(1)</code>方法就相当于将<code>yield</code>表达式替换成一个值<code>1</code>。如果<code>next</code>方法没有参数，就相当于替换成<code>undefined</code>。</p>
</blockquote>
<ul>
<li><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gen.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gen.return(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure>



<h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h4><p><strong>问题</strong>：当在一个Generator函数内部，调用另外一个Generator函数，需要在前者的函数体内部，自己手动完成遍历。</p>
<p><strong>解决</strong>：<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> inner();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// outer1返回一个遍历器对象</span></span><br><span class="line"><span class="keyword">var</span> gen = outer1()</span><br><span class="line">gen.next().value <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.next().value <span class="comment">// 返回一个遍历器对象</span></span><br><span class="line">gen.next().value <span class="comment">// &quot;close&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span>* inner()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// outer2返回该遍历器对象的内部值。</span></span><br><span class="line"><span class="keyword">var</span> gen = outer2()</span><br><span class="line">gen.next().value <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.next().value <span class="comment">// &quot;hello!&quot;</span></span><br><span class="line">gen.next().value <span class="comment">// &quot;close&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>语法角度分析</strong>：如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。</p>
<p><strong>理解：</strong><code>yield*</code>的作用，类似于递归函数，重复自调用，对遍历器内的值，挨个输出，直到结束。也等同于在Geneartor函数内部部署了一个<code>for...of</code>循环，可以用它替换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>yield</code>与<code>yield*</code>的区别</strong>：</p>
<ul>
<li>任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</li>
<li>yield表达式返回的是整个数据结构。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">read.next().value <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">read.next().value <span class="comment">// &quot;h&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>yield作用</strong>：</p>
<ul>
<li>如果被代理的 Generator 函数有<code>return</code>语句，那么就可以向代理它的 Generator 函数返回数据。供Geneartor使用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genFuncWithReturn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;The result&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">logReturned</span>(<span class="params">genObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* genObj;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...logReturned(genFuncWithReturn())]</span><br><span class="line"><span class="comment">// The result</span></span><br><span class="line"><span class="comment">// 值为 [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。(扩展运算符…也可以达到平铺的效果)</li>
<li>例子：遍历完全二叉树</li>
</ul>
<h4 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h4><p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整的</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Generator函数的this"><a href="#Generator函数的this" class="headerlink" title="Generator函数的this"></a>Generator函数的this</h4><p>问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line">obj.next();</span><br><span class="line">obj.a <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> f() <span class="comment">// TypeError: f is not a constructor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>Generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。</li>
<li>Generator 函数也不能跟<code>new</code>命令一起用，会报错。</li>
</ol>
</blockquote>
<p>解决方案：将Generator函数的原型（g.prototype）通过<code>call()</code>绑定，可以对它执行<code>new</code>命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.a <span class="comment">// 1</span></span><br><span class="line">f.b <span class="comment">// 2</span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<h2 id="Generator函数的异步应用"><a href="#Generator函数的异步应用" class="headerlink" title="Generator函数的异步应用"></a>Generator函数的异步应用</h2><h3 id="1-传统方法"><a href="#1-传统方法" class="headerlink" title="1.传统方法"></a>1.传统方法</h3><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><h4 id="异步-1"><a href="#异步-1" class="headerlink" title="异步"></a>异步</h4><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是”重新调用”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文件进行处理，是这样写的。</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;/etc/passwd&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h4><p>使用回调函数，执行多重嵌套的操作，就会形成回调地狱，未解决这种问题，引入了Promise这种新的写法，允许将回调函数的嵌套，改成链式调用。</p>
<p>Promise 提供<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p>
<h4 id="Generator函数-1"><a href="#Generator函数-1" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。</p>
<p><strong>异步任务的封装</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便</p>
</blockquote>
<h4 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h4><p>Thunk函数是自动执行Generator函数的一种方法。</p>
<p>含义：编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p>
<p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，<strong>而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。</p>
</blockquote>
<h4 id="Thunkify模块"><a href="#Thunkify模块" class="headerlink" title="Thunkify模块"></a>Thunkify模块</h4><p>生产环境的转换器，建议使用 Thunkify 模块。</p>
<p>安装 ：<code>npm install thunkify</code></p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);   <span class="comment">//只允许回调函数执行一次</span></span><br><span class="line">read(<span class="string">&#x27;package.json&#x27;</span>)(<span class="function"><span class="keyword">function</span>(<span class="params">err, str</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="Generator函数的流程管理"><a href="#Generator函数的流程管理" class="headerlink" title="Generator函数的流程管理"></a>Generator函数的流程管理</h4><p>Generator在执行异步的操作时，yield命令用于将程序的执行权移出Generator函数，使用Thunk函数，在回调函数里面将执行权交还给Generator函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFileThunk(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFileThunk(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gen = fn();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>

<h4 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h4><p>co 模块可以让你不用编写 Generator 函数的执行器。</p>
<p>安装：<code>npm install co</code></p>
<p>co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line">co(gen);    </span><br><span class="line"><span class="comment">// 返回Promise对象，用then添加回调函数</span></span><br><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Generator 函数执行完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>co支持并发的异步操作，允许某些操作同时进行。等到它们全部完成，才进行下一步。</p>
<ul>
<li>要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">  ];</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure>



<h4 id="基于-Promise-对象的自动执行"><a href="#基于-Promise-对象的自动执行" class="headerlink" title="基于 Promise 对象的自动执行"></a>基于 Promise 对象的自动执行</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自动执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>



<h2 id="Class的基本语法"><a href="#Class的基本语法" class="headerlink" title="Class的基本语法"></a>Class的基本语法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>传统定义类的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pointfun</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pointfun.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Pointfun(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>ES6引入<code>class</code>，它可以看作是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<p>使用class对上面的类改写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="built_in">this</span>.x&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>类的数据类型就是函数，类本身就指向构造函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> Point   <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="comment">// Point.prototype.constructor的值就是Point这个类。</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>类的所有方法都定义在类的<code>prototype</code>属性上。</p>
<ul>
<li>在构造函数中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Pointfun.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在class类中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为class的Point是一个构造函数，由此可见上面的代码成立。</p>
</blockquote>
</li>
<li><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>在ES6中class中定义的方法，是不可枚举的，而ES5的构造函数可以。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;toString&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h4><p><strong>定义</strong>：<code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<ul>
<li><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</li>
<li>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，普通函数不用<code>new</code>也可以执行。</li>
</ul>
<h4 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h4><ul>
<li>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。</li>
<li>与 ES5 一样，类的所有实例共享一个原型对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.__proto__ === p2.__proto__</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过实例的<code>__proto__</code>属性为“类”添加方法。不建议在生产中使用该属性</li>
</ul>
<h4 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h4><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;   <span class="comment">// 对prop存值</span></span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop   <span class="comment">// 对prop的取值</span></span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。返回自定义的形式。</p>
</blockquote>
<ul>
<li>存值函数和取值函数是设置在属性的 Descriptor 对象上的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">html</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">html</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, <span class="string">&quot;html&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;get&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;set&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h4><p>类的属性名，可以采用表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">&#x27;getArea&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h4><ul>
<li>与函数一样，类也可以使用表达式的形式定义</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>Me</code>，但是<code>Me</code>只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用<code>MyClass</code>引用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line">inst.getClassName() <span class="comment">// Me</span></span><br><span class="line">Me.name <span class="comment">// ReferenceError: Me is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>采用 Class 表达式，可以写出立即执行的 Class。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><strong>严格模式</strong>:类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式</p>
<p><strong>不存在提升</strong>：类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<p><strong>name 属性</strong>：本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line">Point.name <span class="comment">// &quot;Point&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Generator 方法</strong>：某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="built_in">this</span>.args) &#123;</span><br><span class="line">      <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Foo(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>

<p><strong>this 的指向</strong>：</p>
<p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<ul>
<li>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="built_in">this</span>.printName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一种方法就是使用箭头函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.getThis = <span class="function">() =&gt;</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> Obj();</span><br><span class="line">myObj.getThis() === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code></li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>定义：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。即指向Foo,而不是foo</li>
<li>父类的静态方法，可以被子类继承。</li>
<li>静态方法也是可以从<code>super</code>对象上调用的。</li>
</ul>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p>
<p>定义方法：</p>
<ol>
<li>定义在class类的外面</li>
<li>新的提案方法，就是在实例属性的前面，加上<code>static</code>关键字。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h3><p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="built_in">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好处:所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p>
</blockquote>
<h3 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h3><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>实现方法：</p>
<ol>
<li>一种做法是在命名上加以区别</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    <span class="built_in">this</span>._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  _bar(baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(<span class="built_in">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。（写在class里面）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">&#x27;snaf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    <span class="built_in">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> myClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(myClass.prototype)</span><br><span class="line"><span class="comment">// [ &#x27;constructor&#x27;, &#x27;foo&#x27;, Symbol(bar) ]</span></span><br></pre></td></tr></table></figure>

<h3 id="私有属性提案"><a href="#私有属性提案" class="headerlink" title="私有属性提案"></a>私有属性提案</h3><p>目前，有一个<a href="https://github.com/tc39/proposal-private-methods">提案</a>，为<code>class</code>加了私有属性。方法是在属性名之前，使用<code>#</code>表示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  #count = 0;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    return this.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> IncreasingCounter();</span><br><span class="line">counter.#count // 报错</span><br><span class="line">counter.#count = 42 // 报错</span><br></pre></td></tr></table></figure>

<ul>
<li>这种写法不仅可以写私有属性，还可以用来写私有方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  #a;</span><br><span class="line">  #b;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    this.#a = a;</span><br><span class="line">    this.#b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  #sum() &#123;</span><br><span class="line">    return #a + #b;</span><br><span class="line">  &#125;</span><br><span class="line">  printSum() &#123;</span><br><span class="line">    console.log(this.#sum());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>私有属性也可以设置 getter 和 setter 方法。</li>
<li>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。<code>  static #totallyRandomNumber = 4;</code></li>
</ul>
<h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>这个属性可以用来确定构造函数是怎么调用的。</p>
<p>Class 内部调用<code>new.target</code>，返回当前 Class。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="built_in">this</span>.length = length;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p>子类继承父类时，<code>new.target</code>会返回子类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, width);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
</blockquote>
<h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>继承的实现：Class可以通过<code>extends</code>关键字实现继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承注意的几点：</p>
<ol>
<li><p>在继承的过程中，子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例会报错。</p>
</li>
<li><p>ES5与ES6的继承机制不同。</p>
<ul>
<li>ES5：先创造子类的实例对象this，然后将父类的方法，添加到this上面（Parent.apply(this)）。</li>
<li>ES6：先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</li>
</ul>
</li>
<li><p>不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p>
</li>
<li><p>在子类的构造函数中，<strong>只有</strong>调用<code>super</code>之后，<strong>才</strong>可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p>
</li>
<li><p>子类的实例对象同时也是父类的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(<span class="number">25</span>, <span class="number">8</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">cp <span class="keyword">instanceof</span> ColorPoint <span class="comment">// true</span></span><br><span class="line">父类</span><br><span class="line">cp <span class="keyword">instanceof</span> Point <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li>父类的静态方法，也会被子类继承。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> hello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.hello()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>判断一个类是否继承了另一个类的方法<code>Object.getPrototypeOf(ColorPoint) === Point</code>true</li>
</ol>
<h3 id="super关键词"><a href="#super关键词" class="headerlink" title="super关键词"></a>super关键词</h3><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<ul>
<li><p>第一种情况：<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p>
<ul>
<li><code>super</code>只能用在子类的构造函数中</li>
<li><code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例</li>
<li><code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</li>
<li>在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name); <span class="comment">// 指向当前正在实行的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A   执行A类时，指向A类</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B   实行super()时，指向B类</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种情况：super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<ul>
<li>在普通方法中：<code>super</code>指向  父类<code>.prototype</code>，所以<code>super.方法或属性</code>相当于<code>父类.prototype.方法或属性</code></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的</p>
<p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到<code>A.prototype.x = 2;</code></p>
</blockquote>
<ul>
<li><ul>
<li>在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在子类中如果想通过<code>super</code>对某个属性赋值，这时的super就是子类的this。赋值的属性会变成子类实例的属性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">super</span>.x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.x); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">// super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</li>
<li>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</li>
</ul>
</li>
<li><p>由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;MyObject: &quot;</span> + <span class="built_in">super</span>.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.toString(); <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure>



<h3 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 prototype 属性和__proto__属性</h3><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<ol>
<li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li>
<li>子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</li>
</ol>
<blockquote>
<p>理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；</p>
<p>作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>extends</code>关键字后面可以跟多种类型的值。</p>
<ul>
<li>子类继承<code>Object</code>类。</li>
</ul>
</li>
<li><p>实例<code>__proto__</code>属性</p>
<ul>
<li>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</li>
<li>通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ <span class="comment">// false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h3><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
<p>ES6以前是不允许原生构造函数的继承，由于继承机制的不同，Class可以继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。</p>
</blockquote>
<h3 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h3><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  a: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  b: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b&#125;; <span class="comment">// &#123;a: &#x27;a&#x27;, b: &#x27;b&#x27;&#125;</span></span><br></pre></td></tr></table></figure>





<h1 id="JS高阶"><a href="#JS高阶" class="headerlink" title="JS高阶"></a>JS高阶</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>了解正则表达式基本语法</li>
<li>能够使用JavaScript的正则对象</li>
</ul>
<h3 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h3><h4 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h4><p>正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。<br>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>
<h4 id="正则表达式的作用"><a href="#正则表达式的作用" class="headerlink" title="正则表达式的作用"></a>正则表达式的作用</h4><ol>
<li>给定的字符串是否符合正则表达式的过滤逻辑(匹配)</li>
<li>可以通过正则表达式，从字符串中获取我们想要的特定部分(提取)</li>
<li>强大的字符串替换能力(替换)</li>
</ol>
<h4 id="正则表达式的特点"><a href="#正则表达式的特点" class="headerlink" title="正则表达式的特点"></a>正则表达式的特点</h4><ol>
<li>灵活性、逻辑性和功能性非常的强</li>
<li>可以迅速地用极简单的方式达到字符串的复杂控制</li>
<li>对于刚接触的人来说，比较晦涩难懂</li>
</ol>
<h3 id="正则表达式的测试"><a href="#正则表达式的测试" class="headerlink" title="正则表达式的测试"></a>正则表达式的测试</h3><ul>
<li><a href="https://c.runoob.com/front-end/854">在线测试正则</a></li>
<li>工具中使用正则表达式<ul>
<li>sublime/vscode/word</li>
<li>演示替换所有的数字</li>
</ul>
</li>
</ul>
<h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><ul>
<li>普通字符</li>
<li>特殊字符(元字符)：正则表达式中有特殊意义的字符</li>
</ul>
<p>示例演示：</p>
<ul>
<li><code>\d</code> 匹配数字</li>
<li><code>ab\d</code> 匹配 ab1、ab2</li>
</ul>
<h3 id="元字符串"><a href="#元字符串" class="headerlink" title="元字符串"></a>元字符串</h3><p>通过测试工具演示下面元字符的使用</p>
<h4 id="常用元字符串"><a href="#常用元字符串" class="headerlink" title="常用元字符串"></a>常用元字符串</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意单个字符</td>
</tr>
<tr>
<td>^</td>
<td>表示匹配行首的文本(以谁开始)</td>
</tr>
<tr>
<td>$</td>
<td>表示匹配行尾的文本(以谁结束)</td>
</tr>
</tbody></table>
<h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table>
<thead>
<tr>
<th>限定符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思</span><br><span class="line">[^]  匹配除中括号以内的内容</span><br><span class="line">\ 转义符</span><br><span class="line">| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱</span><br><span class="line">() 从两个直接量中选择一个，分组</span><br><span class="line">   eg：gr(a|e)y匹配gray和grey</span><br><span class="line">[\u4e00-\u9fa5]  匹配汉字</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>验证手机号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^\d&#123;<span class="number">11</span>&#125;$</span><br></pre></td></tr></table></figure>

<p>验证邮编：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^\d&#123;<span class="number">6</span>&#125;$</span><br></pre></td></tr></table></figure>

<p>验证日期 2012-5-01</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;$</span><br></pre></td></tr></table></figure>

<p>验证邮箱 <a href="mailto:&#x78;&#x78;&#120;&#x40;&#105;&#x74;&#x63;&#x61;&#115;&#116;&#x2e;&#99;&#110;">&#x78;&#x78;&#120;&#x40;&#105;&#x74;&#x63;&#x61;&#115;&#116;&#x2e;&#99;&#110;</a>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^\w+@\w+\.\w+$</span><br></pre></td></tr></table></figure>

<p>验证IP地址 192.168.1.10</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;\(.\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)&#123;<span class="number">3</span>&#125;$</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-中使用正则表达式"><a href="#JavaScript-中使用正则表达式" class="headerlink" title="JavaScript 中使用正则表达式"></a>JavaScript 中使用正则表达式</h2><h3 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h3><p>方式1：构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> Regex(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> Regex(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;gi&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>方式2：字面量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/i</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/gi</span>;</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>g</td>
<td>全局匹配</td>
</tr>
<tr>
<td>gi</td>
<td>全局匹配+忽略大小写</td>
</tr>
</tbody></table>
<h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配日期</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2015-10-10&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(dateStr));</span><br></pre></td></tr></table></figure>

<p>###匹配正则表达式<br>//        console.log(/./.test(“除了回车换行以为的任意字符”));//true<br>//        console.log(/.*/.test(“0个到多个”));//true<br>//        console.log(/.+/.test(“1个到多个”));//true<br>//        console.log(/.?/.test(“哈哈”));//true<br>//        console.log(/[0-9]/.test(“9527”));//true<br>//        console.log(/[a-z]/.test(“what”));//true<br>//        console.log(/[A-Z]/.test(“Are”));//true<br>//        console.log(/[a-zA-Z]/.test(“干啥子”));//false<br>//        console.log(/[0-9a-zA-Z]/.test(“9ebg”));//true<br>//        console.log(/b|(ara)/.test(“abra”));//true<br>//        console.log(/[a-z]{2,3}/.test(“arfsf”));//true</p>
<pre><code>    console.log(/\d/.test(&quot;998&quot;));//true
    console.log(/\d*/.test(&quot;998&quot;));//true
    console.log(/\d+/.test(&quot;998&quot;));//true
    console.log(/\d&#123;0,&#125;/.test(&quot;998&quot;));//true
    console.log(/\d&#123;2,3&#125;/.test(&quot;998&quot;));//true
    console.log(/\D/.test(&quot;eat&quot;));//true
    console.log(/\s/.test(&quot;  &quot;));//true
    console.log(/\S/.test(&quot;嘎嘎&quot;));//true
    console.log(/\w/.test(&quot;_&quot;));//true
    console.log(/\W/.test(&quot;_&quot;));//true</code></pre>
<p>###正则表达式案例<br>1.验证密码强弱<br>2.验证邮箱：[0-9a-zA-Z_.-]+[@][0-9a-zA-Z._-]+([.][a-zA-Z]+){1,2}<br>3.验证中文名字[\u4e00-\u9fa5]</p>
<h3 id="正则提取"><a href="#正则提取" class="headerlink" title="正则提取"></a>正则提取</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 提取工资</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;张三：1000，李四：5000，王五：8000。&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取email地址</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\w+@\w+\.\w+(\.\w+)?/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 分组提取  </span></span><br><span class="line"><span class="comment">// 3. 提取日期中的年部分  2015-5-10</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2016-1-5&#x27;</span>;</span><br><span class="line"><span class="comment">// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(dateStr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提取邮件中的每一部分</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w+)@(\w+)\.(\w+)(\.\w+)?/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 替换所有空白</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;   123AD  asadf   asadfasf  adf &quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/\s/g</span>,<span class="string">&quot;xx&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换所有,|，</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc,efg,123，abc,123，a&quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/,|，/g</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>

<h3 id="案例：表单验证"><a href="#案例：表单验证" class="headerlink" title="案例：表单验证"></a>案例：表单验证</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">QQ号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtQQ&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtEMail&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">手机：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtPhone&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">生日：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtBirthday&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取文本框</span></span><br><span class="line"><span class="keyword">var</span> txtQQ = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtQQ&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> txtEMail = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtEMail&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> txtPhone = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtPhone&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> txtBirthday = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtBirthday&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> txtName = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txtName&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">txtQQ.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前文本框对应的span</span></span><br><span class="line">  <span class="keyword">var</span> span = <span class="built_in">this</span>.nextElementSibling;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;5,12&#125;$/</span>;</span><br><span class="line">  <span class="comment">//判断验证是否成功</span></span><br><span class="line">  <span class="keyword">if</span>(!reg.test(<span class="built_in">this</span>.value) )&#123;</span><br><span class="line">    <span class="comment">//验证不成功</span></span><br><span class="line">    span.innerText = <span class="string">&quot;请输入正确的QQ号&quot;</span>;</span><br><span class="line">    span.style.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//验证成功</span></span><br><span class="line">    span.innerText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    span.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//txtEMail</span></span><br><span class="line">txtEMail.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前文本框对应的span</span></span><br><span class="line">  <span class="keyword">var</span> span = <span class="built_in">this</span>.nextElementSibling;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/^\w+@\w+\.\w+(\.\w+)?$/</span>;</span><br><span class="line">  <span class="comment">//判断验证是否成功</span></span><br><span class="line">  <span class="keyword">if</span>(!reg.test(<span class="built_in">this</span>.value) )&#123;</span><br><span class="line">    <span class="comment">//验证不成功</span></span><br><span class="line">    span.innerText = <span class="string">&quot;请输入正确的EMail地址&quot;</span>;</span><br><span class="line">    span.style.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//验证成功</span></span><br><span class="line">    span.innerText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    span.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>表单验证部分，封装成函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regBirthday = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span>;</span><br><span class="line">addCheck(txtBirthday, regBirthday, <span class="string">&quot;请输入正确的出生日期&quot;</span>);</span><br><span class="line"><span class="comment">//给文本框添加验证</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCheck</span>(<span class="params">element, reg, tip</span>) </span>&#123;</span><br><span class="line">  element.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前文本框对应的span</span></span><br><span class="line">    <span class="keyword">var</span> span = <span class="built_in">this</span>.nextElementSibling;</span><br><span class="line">    <span class="comment">//判断验证是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(!reg.test(<span class="built_in">this</span>.value) )&#123;</span><br><span class="line">      <span class="comment">//验证不成功</span></span><br><span class="line">      span.innerText = tip;</span><br><span class="line">      span.style.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//验证成功</span></span><br><span class="line">      span.innerText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      span.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过给元素增加自定义验证属性对表单进行验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;frm&quot;</span>&gt;</span></span><br><span class="line">  QQ号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtQQ&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;qq&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtEMail&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  手机：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtPhone&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;phone&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  生日：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtBirthday&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;date&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txtName&quot;</span> <span class="attr">data-rule</span>=<span class="string">&quot;cn&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有的验证规则</span></span><br><span class="line"><span class="keyword">var</span> rules = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;qq&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^\d&#123;5,12&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的QQ&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;email&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^\w+@\w+\.\w+(\.\w+)?$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的邮箱地址&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;phone&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^\d&#123;11&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的手机号码&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的出生日期&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">    reg: <span class="regexp">/^[\u4e00-\u9fa5]&#123;2,4&#125;$/</span>,</span><br><span class="line">    tip: <span class="string">&quot;请输入正确的姓名&quot;</span></span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">addCheck(<span class="string">&#x27;frm&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//给文本框添加验证</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCheck</span>(<span class="params">formId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">      len = <span class="number">0</span>,</span><br><span class="line">      frm =<span class="built_in">document</span>.getElementById(formId);</span><br><span class="line">  len = frm.children.length;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = frm.children[i];</span><br><span class="line">    <span class="comment">// 表单元素中有name属性的元素添加验证</span></span><br><span class="line">    <span class="keyword">if</span> (element.name) &#123;</span><br><span class="line">      element.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 使用dataset获取data-自定义属性的值</span></span><br><span class="line">        <span class="keyword">var</span> ruleName = <span class="built_in">this</span>.dataset.rule;</span><br><span class="line">        <span class="keyword">var</span> rule =getRuleByRuleName(rules, ruleName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> span = <span class="built_in">this</span>.nextElementSibling;</span><br><span class="line">        <span class="comment">//判断验证是否成功</span></span><br><span class="line">        <span class="keyword">if</span>(!rule.reg.test(<span class="built_in">this</span>.value) )&#123;</span><br><span class="line">          <span class="comment">//验证不成功</span></span><br><span class="line">          span.innerText = rule.tip;</span><br><span class="line">          span.style.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//验证成功</span></span><br><span class="line">          span.innerText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">          span.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据规则的名称获取规则对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRuleByRuleName</span>(<span class="params">rules, ruleName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">      len = rules.length;</span><br><span class="line">  <span class="keyword">var</span> rule = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rules[i].name == ruleName) &#123;</span><br><span class="line">      rule = rules[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
